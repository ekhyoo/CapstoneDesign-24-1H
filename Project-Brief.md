# List of Teams/Projects
|팀번호|팀명|프로젝트|
|:---|:---|:---|
|01|[Optimus GPrime](#team-01)|Lamp: GPU Microarchitecture Simulator 용 Large Language Model (LLM) Benchmark 개발 연구
|02|[박김배](#team-02)|DoongDoongMaster: 드럼 초보자의 연습을 도와주는 어쿠스틱 드럼 채점기​
|03|[Munchkins](#team-03)|식료품 스마트 컨슈밍 어시스턴트, 트루태그(TruthTag)
|04|[심가탕후루](#team-04)|김약사: 노년층을 위한 머신러닝과 광학 문자 인식을 통한 약 복용 관리 모바일 앱
|05|[A.A](#team-05)|모락모락: 개인 맞춤형 헤어스타일을 추천받고 다양한 조건을 비교하여 본인에게 맞는 헤어 디자이너를 찾을 수 있도록 매칭해주는 서비스
|06|[너도 멸종되지 않게 조심해](#team-06)|Inkspire: GPT 생성 게임 스크립트 기반 사용자 맞춤형 텍스트 RPG
|07|[루스](#team-07)|Once : 카드 다보유자를 위한 결제 전 최대 할인 카드를 추천해 주는 AI 챗봇 서비스
|08|[ECST](#team-08)|Learning Mate : 실시간 집중도 분석과 동기 부여 시스템을 통한  자기 주도 학습 증진 서비스
|09|[강철몽둥이](#team-09)|AI 기반 교내 스마트 중고거래 플랫폼
|10|[Qt](#team-10)|잇터뷰(iterview) : IT 취준생을 위한 CS 기술 구두 면접 대비 & 학습 플랫폼
|11|[로캣단](#team-11)|망하지망고 : 망고 초보 재배자를 위한 이미지 객체 검출 및 분류 기반 농작물 질병 식별 앱 서비스
|12|[팀팀탱탱후라이팬](#team-12)|어린이를 위한 비주얼 프로그래밍 기반 코딩 학습 모바일 게임: 메르헨 코더
|13|[스윗팡이크루](#team-13)|Agent.I : Generative Agent를 적용한 Human-like NPC와 상호 작용하는  사회 시뮬레이션 게임
|14|[CoB](#team-14)|PitchFinder: 사용자 음높이 기반 가요 필터링 서비스 개발
|15|[감자도리](#team-15)|다시: 은퇴한 시니어 전문가를 위한 긱 워킹 채용 플랫폼
|16|[깡총](#team-16)|주변 소리를 인식하여 상황별 알람을 받을 수 있는 서비스: 쫑긋
|17|[출발드림팀](#team-17)|AI 객체 인식과 프롬프트 엔지니어링을 활용해 맞춤형 건강 조언을 제공하는 과민대장증후군 관리 어플리케이션, BellyWelly
|18|[뽀로로에디](#team-18)|Prompirit: Automatic Prompt Engineering Assistance to Improve AI-Generative Art Using User Emotion
|19|[TMM](#team-19)|캣치타임: 효율적인 시간 관리를 돕는 타이머 기반 모바일 육성 게임
|20|[쿠킹마마](#team-20)|식재료 관리를 통한 1인 가구의 식비 절감 지원 웹앱 서비스
|21|[AtoB](#team-21)|일기장 속 친구 :감정 이해와 조언의 동반자 PSYLOG
|22|[쓰리박](#team-22)|Fairy Tairy : 동화같은 그림을 자동으로 생성해주는 AI 일기 서비스
|23|[새우타코](#team-23)|Stroke-based Collaborative Drawing between Robot(AI) and Human
|24|[망고젤리](#team-24)|Grounding Dino를 활용한 객체 탐지 기반 CCTV 속 흉기 난동 상황 모니터링 SDK
|25|[S](#team-25)|스케줄 추천 및 일정 관리 서비스
|26|[ETT](#team-26)|DISLODGED :  TTS 기술을 활용한 익명 감성 위로 커뮤니티
|27|[E모지](#team-27)|MosaicNow
|28|[달리리](#team-28)|속마음을 담은 일기 교환을 통해 현대인의 소외감 해소를 돕는 교환일기 웹 서비스 <비밀친구>
|29|[츄라이](#team-29)|AI를 활용한 영어 스피킹 시험 준비 앱
|30|[일구어냄](#team-30)|CATCHUP: 컴퓨터공학과 학생에게 맞춤형 선수 학습사항 자료를 제공해주는 LLM 챗봇 웹서비스
|31|[BCS](#team-31)|DreamGuard: 더 좋은 잠을 위한 수면장애 위험도 진단 및 수면 트래킹 서비스
|32|[머니캐처](#team-32)|HobHub: 일상 속 활력 충전을 위한 AI 기반 취미 추천 및 취미 기록 아카이빙 웹 서비스
|33|[Donuts](#team-33)|공유니폼 : 야구 팬을 위한 사용자 기반 추천 유니폼 대여 앱 및 대여 자판기
|34|[고등어](#team-34)|돈워리(Be happy) - 일정 및 소비데이터를 활용한 예산 사용량 예측 AI 기반 모바일 웹 서비스
|35|[log](#team-35)|영상 일기 플랫폼 log: NLP를 활용한 간편하고 생생한 일기 기록
|36|[레쏘](#team-36)|Neverland: 생성형 AI 기반 단체 추억 아카이빙 앱 서비스
|37|[re:coding](#team-37)|사용자와 자유로운 상호작용이 가능한 Gen AI 기반 스마트 스케줄링 웹 서비스
|38|[화이](#team-38)|스킨트리: 협업필터링과 머신러닝을 활용한 성분 맞춤형 화장품 추천 서비스
|39|[순간포착](#team-39)|객체 인식과 OCR을 활용한 객관·단답식 시험지 채점 AI 소프트웨어
|40|[흰토끼](#team-40)|FingerSpell: 초등학생 장애 인식 개선을 위한 모션인식 수화 게임
|41|[초이배리](#team-41)|MATHORY: 재미있는 프롬포트 생성 기반 스토리텔링형 초등 수학 교육 게임
|42|[왈라비](#team-42)|DRIVE GUARDIAN : 운전자 모니터링 앱 서비스
 
# Team-01
| (1) 과제명 | Lamp: NVIDIA GPU Microarchitecture Simulator 용 LLM Hardware Performance Estimator 개발 연구
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 01-Optimus GPrime |
| (3) 팀원 역할 분담 | 황재은 (2176427): 리더, CUDA Kernel 프로파일링, GEMM 구현<br>정은비 (2173109): 팀원, NVTX Range 프로파일링, Softmax구현<br>최이경 (2276327): 팀원, GPU Memory 프로파일링, All-Reduce 구현			 |
| (4) 팀 지도교수 | 윤명국 |
| (5) 팀 멘토 | 전원 / ETRI / 연구원 |
| (6) 과제 키워드(keywords) | GPU Simulator, LLM, Hardware Performance Estimator  |
| (7) 과제 내용 요약 | 현재, GPU Microarchitecture Simulator에서 실험할 수 있는 LLM 성능 평가 application의 부재로, GPU Architecture 측면에서의 LLM 연구가 활성화되기 어려운 실황이다. 따라서, GPU Microarchitecture Simulator에서 실행 가능한 LLM Performance Evaluator를 구현하여 오픈소스로 배포함으로써, 원활한 GPU Architecture LLM 연구 환경을 제공하고자 한다. 						 |
| (8-1) 과제: 문제의 정의 | GPU Microarchitecture Simulator란 GPU (Graphic Processing Unit)의 설계와 성능 최적화를 위해 사용하는 도구이다. 연구자들이 다양한 구조적 변화를 시뮬레이션 함으로써 Hardware에서 실행 없이 그 효과를 예측할 수 있다는 유용함을 제공한다. 특히, 더 복잡해지고, 요구하는 연산 능력이 증가하고 있는 대규모 언어 모델 (이하 LLM)을 효율적으로 지원하기 위한 GPU 구조에 관한 연구의 중요성이 강조되고 있다. <br>그러나, 현재 GPU Microarchitecture Simulator에서 사용할 수 있는 성능 분석 application들은 LLM의 활발한 사용 이전에 개발되었기 때문에 대부분 CNN, LSTM 등과 같은 전통적인 인공지능 모델에 초점을 맞추고 있다. 즉, GPT와 같은 모델에서 사용하는 Transformer의 특성을 반영한 성능 평가 방법은 전무하다. 이는 연구자들이 최신 기술을 위한 새로운 architecture 설계나, 최적화 기법의 효과를 정확히 평가하기 어렵게 만든다. 따라서, LLM에 특화된 Performance Evaluator를 개발함으로써 이러한 문제를 해결하여 LLM을 위한 GPU Architecture 연구를 활성화하고자 한다.  |
| (8-2) 과제: 기존연구와의 비교 | 본 팀은 다양한 GPU Microarchitecture Simulator 용 Application을 조사하였다. 그 중 대표적인 Benchmark Suite(Application의 집합)는 아래 두 가지이다. <br><br>1) Polybench Benchmark Suite [2]<br>- Polybench는 2D Convolution, 2D Matrix Multiplication, GEMM(General Matrix Multiplication)과 같은 GPU 용 커널로 이루어진 Benchmark Suite이다. 다양한 Application으로 구성되어 GPU Microarchitecture의 성능을 측정하는 데에 주로 활용되어 왔으나, 이는 2012년에 개발된 것으로 Outdated Application이 많다. 특히, 최근 중요도가 급부상한 DNN 및 LLM Application이 포함되지 않는다는 한계점이 있다.<br><br>2) Tango Benchmark Suite [3]<br>- Tango는 GPU simulator 및 FPGA 환경에서 실행할 수 있는 LSTM, CNN과 같은 DNN Model Application으로 이루어진 Benchmark Suite이다. DNN 라이브러리 또는 프레임워크의 설치 없이 실행 가능한 Application이라는 것에 의의가 있으며, 유명한 CNN 모델 5개와 RNN 모델 2개를 포함하고 있다. 하지만 Tango 또한 2019년에 개발된 것으로, LLM Application이 부재 한다.<br><br>본 연구에서는 GPU Simulator에서 실행하고 성능을 측정할 수 있는 LLM Application을 구현하여, LLM의 Hardware Performance를 측정해주는 프레임워크를 구현하고자 한다. |
| (8-3) 과제: 제안 내용 | GPU Microarchitecture Simulator에서 실행 가능한 LLM Hardware Performance Estimator를 개발하는 것을 목표로 한다. 이는 LLM Application과 Simulation Performance Results를 제공하는 Evaluator를 포함한 LLM Framework로 구현하여 제공될 예정이다. 해당 LLM Application은 LLM의 연산 구조적 특징을 반영하여 설계될 것이며, 기존 LLM의 Kernel과 본 팀이 구현한 Kernel 간의 성능 Correlation 그래프를 제시하고, 성능 유사도 80%를 달성하는 것을 목표로 한다. |
| (8-4) 과제: 과제의 주요 기능 | Lamp는 LLM의 연산 구조를 반영한 LLM Application과 Hardware 연산 성능을 측정하는 Performance Evaluator를 포함한다. <br><br>1) LLM Application : LLM 연산을 위한 Kernel과 Input data를 제공한다. <br>2) Performance Evaluator :  CUDA Runtime Library를 통해 GPU Microarchitecture Simulator인 GPGPU-Sim[7]에서 LLM Kernel들을 실행하며, 각 Kernel의 성능 결과를 분석하여 요약해주는 역할을 한다. <br><br>이를 통해 연구자들은 LLM 연산에 관한 Hardware Performance 결과를 얻음으로써 LLM 최적화 GPU Architecture 연구의 발전을 도모할 수 있다.   |
| (8-5) 과제: 구현 방법 | 1) LLM Application<br>① Data <br>- 목적: Application를 실행하기 위한 각 Kernel의 Input Tensor를 제공한다.<br>- 기능: 다양한 크기와 형태의 입력 데이터를 포함하며, 실제 LLM (LLaMA) Task를 반영한 데이터 구조를 사용한다. 이때, Input Tensor의 전처리, 로딩, 초기화를 담당하는 모듈을 포함한다.<br>② LLM Kernel Code<br>- 목적: LLM 연산을 수행하는 Core Kernel 코드를 제공한다.<br>- 기능: GEMM, GEMM_RELU, splitKreduce, softmax 와 같은 LLM 연산의 대표성을 띄는 Kernel Code를 포함한다. 다양한 GPU Architecture에서의 성능을 평가할 수 있도록 최적화하여 구현하도록 한다. (Kernel 선정 방식은 보고서 참고)<br>③ LLM Application Host Code<br>- 목적: Application Kernel을 실행한다.<br>- 기능: LLM Application의 각 Kernel을 호출하고, 실행하는 함수를 포함한다.<br>④ README (사용자 매뉴얼)<br>- 목적: 사용자가 Lamp를 쉽게 사용할 수 있도록 돕는 매뉴얼을 제공한다.<br>- 기능: 설치 방법, 실행 방법, 결과 분석 방법과 같은 Lamp Framework를 활용하기 위해 사용자가 필요로 하는 정보를 제공한다.<br><br>2) Performance Evaluator<br>Performance Evaluator는 LLM Application의 Kernel 시뮬레이션을 통해 얻은 데이터를 분석하고 성능을 평가하는 데 필요한 도구들을 제공한다. 구체적으로는 다음과 같은 두 부분으로 구성된다:<br>① Runner (GPGPU-Sim Executor)<br>- 목적: GPGPU-Sim 환경에서 LLM Application의 다양한 Kernel들을 실행하는 주체이다. 이는 실제 GPU 환경을 모사하여, Kernel 코드의 실행 결과와 성능을 산출한다.<br>- 기능: GPU Configuration과 LLM Application에 필요한 설정을 마친 후, LLM Application Simulation을 위한 GPGPU-Sim 코드들을 실행한다. <br>② Summarizer (성능 요약기)<br>- 목적: 실행된 Kernel들의 성능 결과를 종합적으로 분석하고 요약하는 역할을 한다. <br>- 기능: GPGPU-Sim에서 산출된 Kernel들의 성능 지표들을 요약하여, 사용자가 쉽게 이해할 수 있는 형태로 성능 결과를 제공한다. 이는 연구자들이 LLM Application의 실행 결과를 바탕으로, GPU Architecture 성능을 평가하는 데 도움을 준다. |
| (8-6) 과제: 세부 기술 | 1) CUDA [8]<br>NVIDIA에서 제공하는 CUDA(Compute Unified Device Architecture)는 NVIDIA GPU를 사용하여 Application 실행을 가속화하기 위해 필요한 병렬 컴퓨팅 플랫폼이자 API 모델이다. 본 연구에서는 CUDA를 사용하여 GPU의 병렬성을 최대한으로 활용될 수 있도록 Benchmark Kernel을 구현하고자 한다. <br><br>2) GPGPU-Sim [7]<br>GPGPU-Sim은 NVIDIA GPU를 모델링한 사이클 수준의 시뮬레이터(cycle-level simulator)이다. GPGPU-Sim에서는 CUDA와 OpenCL 기반의 다양한 GPU 연산 워크로드(computing workloads)를 실행하고 성능을 측정할 수 있다. 본 연구에서는 GPGPU-Sim을 타겟 GPU microarchitecture simulator로 사용할 예정이며, GPGPU-Sim에서 실행 가능한 CUDA 기반의 LLM 성능 분석 application를 구현할 예정이다. 추가로 GPGPU-Sim에서 실행한 다수의 커널 결과를 토대로, 전체 LLM Performance Evaluator의 성능을 종합적으로 분석하기 위한 코드를 추가할 계획이다.<br><br>3) CUTLASS Library [6]<br>CUTLASS (CUDA Templates for Linear Algebra Subroutines and Solvers)는 NVDIA에서 개발한 고성능 CUDA C++ 템플릿 라이브러리로써, 고차원 행렬곱 (GEMM) 연산 및 기타 선형 대수 연산을 위한 구현을 제공한다. <br>그러나, CUTLASS Library는 현재 GPU Microarchitecture Simulator에서 일부 커널의 연산이 지원되지 않아 LLM Performance Evaluator 구현에 장애물이 되기 때문에, 해당 커널을 분석하여 CUTLAS와 유사한 커널을 구현하고자 한다. <br><br>4) NVIDIA Nsight Profiling Tools [4][5]<br>NVIDIA에서 제공하는 Nsight Profiling Tools (Nsight Systems, Nsight Compute)는 CPU 및 GPU에서의 Application과 Kernel 실행 성능을 시스템적으로 분석하기 위한 도구이다. 본 연구에서는 Profiling을 통해 실행되는 소프트웨어의 메모리 사용 양상과 계산 양상을 파악하여 프로그램의 Bottleneck을 파악하고 개선해 나가는 일련의 과정을 통해 시스템의 Memory Resource와 Computation Resource가 경제적으로 사용되도록 소프트웨어를 최적화하고자 한다. |
| (8-7) 과제: 기대 효과 및 의의 | 1) GPU Microarchitecture Simulator에서 실행 가능한 LLM Hardware Performance Estimator의 개발을 통해 연구자들은 LLM의 Workload를 반영하는 실험 환경을 구축할 수 있다. <br>2) GPU Architecture 설계와 최적화 과정에서 보다 정확한 결정을 내릴 수 있게 하며, LLM을 효율적으로 지원하는 더 발전된 GPU 구조의 개발로 이어지게 될 것이다. <br>3) 연구자들이 동일한 기준으로 성능을 측정하고, 결과를 비교할 수 있게 되어, 공유와 협업을 촉진함으로써 지식의 축적과 빠른 기술 발전을 도모할 수 있다. |
| (9) 데모 내용 |  Performance Evaluator에 구현한 Runner를 활용하여 본 팀이 구현한 LLM의 GEMM Kernel을 실행하는 과정을 보인다.  <br><br> 먼저, 본 팀에서 사용할 NVIDIA GPU 기반 GPU Simulator인 GPGPU-Sim을 빌드하고, Runner 내의 Application 이름과 GPU Configuration을 설정한다. 이후 Runner 스크립트를 실행하여 GPGPU-Sim의 Simulation Kernel을 Launch 하고, Simulation Output이 출력되는 모습을 보인다. |
| (10) 기타 | 참고자료<br>[1] Touvron, Hugo, et al. "Llama: Open and efficient foundation language models." arXiv preprint arXiv:2302.13971 (2023).<br>[2] Grauer-Gray, Scott, et al. "Auto-tuning a high-level language targeted to GPU codes." 2012 innovative parallel computing (InPar). Ieee, 2012.<br>[3] Karki, Aajna, et al. "Tango: A deep neural network benchmark suite for various accelerators." 2019 IEEE International Symposium on Performance Analysis of Systems and Software (ISPASS). IEEE, 2019.<br>[4] NVIDIA Nsight Systems. https://developer.nvidia.com/nsight-systems <br>[5] NVIDIA Nsight Compute. https://developer.nvidia.com/nsight-compute <br>[6] CUTLASS Library. https://github.com/NVIDIA/cutlass <br>[7] GPGPU-Sim GitHub Repository. https://github.com/gpgpu-sim/gpgpu-sim_distribution<br>[8] CUDA C++ Programming Guide. https://docs.nvidia.com/cuda/cuda-c-programming-guide/<br>[9] Ashish Vaswani, et al. “Attention Is All You Need” arXiv preprint arXiv:1706.037 (2017). |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-02
| (1) 과제명 | DoongDoongMaster: 드럼 초보자의 연습을 도와주는 어쿠스틱 드럼 채점기​
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 02-박김배 |
| (3) 팀원 역할 분담 | 배수아 (2071027): 리더, 서버 개발 <br>김재서 (2071015): 팀원, OMR 모델 개발<br>박지영 (2076168): 팀원, 앱 개발|
| (4) 팀 지도교수 | 오세은 |
| (5) 팀 멘토 | 소준섭 / 블루펭귄 / 대표 |
| (6) 과제 키워드(keywords) | 드럼, ADT(Automatic Drum Transcription), OMR(Optical Music Recognition) |
| (7) 과제 내용 요약 | 박자감 및 자기확신이 부족한 초보 드러머를 위해, 악보 프롬프트와 어쿠스틱 드럼 채점 기능을 갖춘 어플리케이션을 통해서 초보 드러머의 연습을 돕고자 합니다. |
| (8-1) 과제: 문제의 정의 | 초보 드러머의 경우, 악보 해석 능력이 부족해서 박자 자체를 이해하지 못하는 경우도 있고, 이해하더라도 가사가 없는 부분에서 박자를 놓치기 쉽다. 또한, 속도가 빠르고 박자가 복잡한 경우에도 어려움을 겪는다. 자신의 연주가 정확한지, 틀렸다면 정확히 어떤 부분이 어떻게 틀렸는지를 초보자가 혼자 판단하기 어렵기 때문에 이를 해결하고자 한다. |
| (8-2) 과제: 기존연구와의 비교 | Cantabile: 실제 피아노 소리를 인식해, 피드백을 제공하고 채점해주는 등 피아노 연습을 도와주는 앱<br><br>- 지원 악기: 어쿠스틱 피아노, 디지털 피아노 등 모든 피아노<br>- 실시간으로 악기 연주 피드백 제공 및 연주 완료 후 채점을 AI를 통해 제공<br>- “피드백 모드”, “연주 모드”, “자동 음악 연주” 모드가 있어 다양하게 연습 가능<br>- 앱 내 등록된 곡들만 연주 가능하다는 한계 존재<br><br>Melodics: MIDI 기기와 연동하여 곡을 연습해 볼 수 있는 Desktop App<br><br>- 지원 악기: 키보드, 핑거 드럼, 전자 드럼 등의 MIDI 악기<br>- 실시간으로 연주가 기록되는 형태로 피드백 제공<br>- 연주가 끝난 후, 종합 점수 제공<br>- 게이미피케이션을 통해 지속적 연습에 대한 동기 부여<br><br>Yamaha 전자드럼: 전자드럼에 내장되어 연습을 돕는 소프트웨어<br><br>- 연주가 끝난 후, 각 악기 별 점수 제공<br>- 장르 별로 준비된 곡에 대해 강습 기능 존재<br>- 스트로크 연습 가능<br><br>Real Drum Online : 앱/웹으로 드럼 연습 혹은 연주<br><br>- “수업”모드에서 서비스가 제공하는 드럼 연주를 사용자가 따라 연주한 후, 별점 및 점수 형태로 피드백 제공<br>- “루프”모드에서 원하는 장르 및 bpm인 곡을 선택 후, 선택한 곡의 박자에 맞게 드럼 연주<br>- 메트로놈 기능 제공(프리미엄)<br>- 앱 내 등록된 곡들만 연주 가능하다는 한계 존재 |
| (8-3) 과제: 제안 내용 | 1. 사용자 연주 전사: 사용자의 연주를 녹음한 후, Automatic Drum Transcription AI를 통해 전사한다.<br>2. 사용자 연주 채점: 사전에 입력받은 악보 데이터와 사용자의 연주 기록을 비교하여 소리 및 박자 정확도를 기준으로 채점한다.<br>3. 악보 프롬프트 : 현재 연주 중인 박자를 프롬프트 바로 시각화하여 지도해줌으로써, 혼자 연습할 수 있도록 도움을 준다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 드럼 전사 기능: 사용자의 연주를 녹음한 파일에서 드럼 소리의 파형을 분석해 어떤 박자에 어떤 악기를 쳤는지 인식하여 드럼 연주를 데이터화 한다.<br>2. 채점기능: 드럼 전사 기술을 통해 데이터화 한 사용자의 연주를 정답 악보 데이터와 비교해 음정과 박자를 채점하고, 해당 결과를 시각적으로 사용자에게 제공한다. <br>3. 악보 전사 기능: 사용자가 가지고 있는 악보 이미지를 파싱하여 데이터화 한다.<br>4. 프롬프팅 기능: 악보 전사 기술을 통해 데이터화 한 악보를 진행 속도에 맞추어 자동으로 넘겨주어, 이용자가 연주 중 악보를 넘기지 않도록 한다. 또한, 현재 진행 중인 음표를 표기하여 박자를 놓치지 않도록 돕는다. |
| (8-5) 과제: 구현 방법 |1. 드럼 전사 AI (Automatic Drum Transcription) <br>: 시스템의 주요 기능으로, 사용자가 입력한 소리를 전사하여 사용자의 연주를 인식하는데 사용됨. ![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/ed5c9636-56b7-41ed-9f44-97c184cd7b72)<br>1-1. Segment & Classify <br>1-1-1. Onset Detect [박자 전사] - python library인 librosa의 Onset Detection 함수 활용 <br> 1-1-2. Feature extraction <br> 1-1-3. Classification(CRNN) [악기 전사] <br><br>1-2. Separate & Detect <br> 1-2-1. Feature extraction <br> 1-2-2. CRNN [악기 전사] <br> 1-2-3. Peak Detection [박자 전사] - python library인 librosa의 Peak Picking 함수 활용 <br><br> 2. 악보 인식 AI (Optical Music Recognition) <br>: 사용자에게 악보를 사진으로 입력 받기 위함으로, 사용자의 연주와 비교하기 위한 악보 입력 방식 ⇒ 채점을 하기 위한 기술<br>➔ 사용 기술: OpenCV 4.5, CRNN ![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/741e89ef-928e-4c13-9486-18c4b462fc0b)<br><br>3. 아키텍처<br>클라우드: AWS EC2(Ubuntu 20.04), S3 / firebase<br>프레임워크: flutter, FastAPI<br>AI: librosa, Tensorflow, essentia, RedisAI (모델 서빙 서버)<br>etc: redis ![image](https://github.com/bsa0322/CapstoneDesign-24-1H/assets/68186101/514ea24c-026b-4a4d-936c-48d5aa48db55)|
| (8-6) 과제: 세부 기술 | **드럼 전사 AI (Automatic Drum Transcription)**<br>- 내용: 드럼 전사 AI는 채점 기능에 사용된다. 먼저, 사용자가 앱의 연습 기능을 통해 악보 프롬프트 화면을 보면서 곡을 연주하면, 앱은 연주가 끝난 후 녹음된 음성 데이터로 서버에 전사 요청을 보낸다. 앱은 ADT 모델이 전사한 결과를 받아 악보 데이터와 비교하여 점수를 계산하고, 악보와 다르게 연주된 부분을 사용자에게 보여준다. 사용자는 이 결과를 보고 자신이 어떤 구간에서 실수를 하는지, 어느 마디를 집중해서 쳐야 하는지 알 수 있다.<br>- 기술검증: 드럼 연주 데이터셋을 수집하여 학습한 모델을 실제 연습실 환경에서 테스트했을 때, 하이헷, 스네어, 킥 악기에 대해서 사용자의 연주를 전사하고, 이를 정답 악보와 비교하여 채점이 원활히 이루어지는 것을 검증했다.<br><br>**악보 인식 AI (Optical Music Recognition)**<br>- 내용: 악보 인식 AI는 채점 및 프롬프트 기능을 위해 사용자가 등록한 악보 이미지를 파싱하기 위해 사용된다. 사용자가 이미지 형태의 악보를 등록하면, 앱은 서버에 파싱 요청을 보낸다. 전송된 이미지는 OMR 모델과 후처리를 거쳐 MusicXML 형식으로 변환된다. 앱은 변환된 MusicXML을 활용해 곡의 정보를 파악하고, 악보를 다시 이미지화하여 사용한다.<br>- 기술검증: 악보 이미지로부터 추출한 note의 pitch와 duration을 각각 구분 가능하다는 것을 검증했다. 현재 모델은 pitch, duration을 각각 훈련했기 때문에 한 번에 구분하기 어렵다는 한계가 있다. 이후 pitch와 duration을 합친 class로 한 번에 구분할 수 있는 모델로 구상하여 메모리를 아끼고 시간을 단축할 수 있을 것으로 예상한다.|
| (8-7) 과제: 기대 효과 및 의의 |악보를 기반으로 객관적인 피드백을 제공함으로써 사용자는 자신의 드럼 연주 능력에 따라 개선이 필요한 부분을 시각적으로 볼 수 있다. 해당 결과를 바탕으로 사용자는 보다 구체적인 연습 목표를 설정할 수 있다.<br>자신의 드럼 연주에 대해 수치화된 점수를 받음으로써 사용자는 연주에 재미를 느낄 수 있다.|
| (9) 데모 내용 | 0. 소셜 로그인을 통해 앱에 접속한다.<br>1. 악보 등록 과정: 악보를 이미지로 등록하면, 모델을 통해 파싱된 결과를 받아온다.<br>2. 연습장 생성: 연습추가 버튼을 눌러 앞서 등록한 악보를 고른 후, 새로운 연습장을 추가한다.<br>3. 완곡 연습 시작: 추가한 연습장에서 완곡 연주 버튼을 눌러 연습을 시작하고, 악보 프롬프트 화면으로 넘어간다.<br>4. 악보 프롬프트: 앞 과정에서 파싱된 데이터를 통해 사용자가 지정한 속도에 맞추어 악보 프롬프트가 동작한다. 이 때 실제 드럼을 연주하기 어렵기 때문에 녹음본을 재생할 계획이다.<br>5. 채점 결과 확인: 연주가 끝나고 모델 서버에서 처리가 끝나면 앱에 푸시 알림을 통해 결과가 전달된다. 최종적으로 점수, 연주의 정확도를 확인할 수 있으며 악보 내에서 사용자가 잘못 친 부분 또한 확인이 가능하다.<br>6. 연습 기록 확인: 연습장에서 그간의 연습 기록을 볼 수 있다. 또한 점수 및 정확도의 변화 추이를 그래프로 확인할 수 있다.<br>7. 구간 반복 연습 레포트 확인: 미리 만들어놓은 구간을 선택 후, 반복 연습에 대한 레포트 화면을 확인한다. |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-03
| (1) 과제명 | 식료품 스마트 컨슈밍 어시스턴트, 트루태그(TruthTag)
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 03-Munchkins |
| (3) 팀원 역할 분담 | 김현수(2176113): 리더, 프론트엔드 프로그래밍<br>김경민(2062008): 팀원, 백엔드 프로그래밍, 클라우드, UI/UX 디자인<br>한현경(2176410): 팀원, 딥러닝 모델링(OCR, 챗봇) |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 박건영 / 토스증권 / 개발자 |
| (6) 과제 키워드(keywords) | 스마트컨슈밍, 식료품의 슈링크/스킴 플레이션, 대체 유사품 추천 챗봇 |
| (7) 과제 내용 요약 | 식료품을 판매하는 기업이 소비자 모르게 가격은 동결시킨 채로 용량이나 원재료 구성을 바꿈으로써 소비자들에게 비용을 전가하는 슈링크/스킴플레이션이 발생할 때마다 이에 대한 정보를 실시간으로 업데이트해 알려주고, 한 상품의 가격/원재료 변화 추이를 그래프 및 표의 형식으로 보여주며, 슈링크/스킴플레이션이 일어난 제품을 대체할 수 있는, 현재 구매하고 있던 상품과 가격 혹은 원재료 측면에서 가장 유사한 타사의 제품을 챗봇을 통해 추천해줌으로써 식료품 소비자가 기업에 대항하여 현명한 소비를 할 수 있게끔 돕는 모바일 웹애플리케이션입니다. |
| (8-1) 과제: 문제의 정의 | 최근 물가 상승으로 인해 위축된 소비 심리를 자극하지 않으면서 이윤을 취하려는 기업이 많아지며 제품의 가격은 그대로 유지하는 대신 크기, 중량을 줄이는 '슈링크플레이션'과 가격을 인상 대신 품질을 낮추는 '스킴플레이션'이 빈번히 발생하고 있습니다. 또한 설문 조사 결과, 정보의 부재 때문에 이런 현상에 적절하게 대응하지 못하는 소비자들이 다수 있음을 확인했습니다. 그럼에도 식료품의 가격이나 원재료 정보 등을 트래킹 및 시각화하여 변화 정도를 보기 쉽게 알려주고, 비합리적인 가격 인상이나 원재료 변경이 생긴 제품 대신 대체품을 추천해주는 서비스가 없습니다. 따라서 저희는 물가 상승으로 인해 변동 사항이 많은 식료품 업계에서 현명한 소비를 하고자 하는  이들에게, 스킴플레이션과 슈링크 플레이션을 감지하고 비합리적인 상품에 대해서는 대체제를 찾는 소비를 돕는 서비스를 제공하고자 합니다. |
| (8-2) 과제: 기존연구와의 비교 | 1. '소비자24' 사이트<br>장점: 제품 정보를 트래킹 후 시각화 기능을 제공한다. 슈링크플레이션 신고 기능이 있습니다.<br>단점: 가격의 변동을 보여주는 기능은 있지만, 그 제품 대신 소비할 수 있는 대체품을 추천해주지는 않습니다. |
| (8-3) 과제: 제안 내용 | 1) 소비자들이 슈링크/스킴 플레이션이 발생한 사실을 바로 알 수 있어야 합니다. 이에 저희는 알림 기능을 생각하여 슈링크/스킴 플레이션이 발생한 식료품에 대해 사용자가 바로 알림을 받아볼 수 있게 하였고, 홈 화면의 대시보드 기능을 통해 최근에 슈링크/스킴 플레이션이 발생한 항목들을 소비자들이 확인할 수 있게끔 하였습니다. <br>2) 소비자들이 슈링크/스킴 플레이션이 발생한 식료품에 대해 슈링크/스킴 플레이션이 일어나기 전의 가격, 용량, 원재료에 대한 정보를 알고 있어야 한다고 생각했습니다. 그래야 기존에 비해 얼마나 큰 차이가 있었는지 알고, 자신의 소비를 바꿀 것인지에 대한 주체적인 의사결정이 가능하다고 생각했기 때문입니다. 따라서 가격 / 용량 그래프와 원재료 표의 히스토리 기능을 제공함으로써, 그 전에 몇 번의 슈링크/스킴 플레이션이 언제 있었으며 그때마다 얼마만큼의 변동이 있었는지 소비자들이 확인할 수 있게끔 하였습니다. <br>3) 슈링크/스킴 플레이션이 일어났고, 이를 알게 된 소비자가 기존에 소비하던 상품의 소비를 중지하고, 유사한 다른 제품을 찾으려고 할 때, 이를 돕기 위해 대체제 유사품 챗봇 서비스를 생각했습니다. 사용자가 기존에 소비하던 상품과 가격 혹은 원재료 구성에서 가장 유사한 대체품을 챗봇이 추천해줌으로써 소비자의 고민을 덜어줍니다. |
| (8-4) 과제: 과제의 주요 기능 | 1) 가격 대비 용량 그래프 시각화, 식료품의 원재료표 변화 시각화<br>2) 상품 별 가격/용량/원재료 변동추이 대시보드<br>3) 슈링크플레이션 / 스킴플레이션 알림 |
| (8-5) 과제: 구현 방법 | 1. 변동사항 알림 기능<br> [FE]: 리액트 쿼리의 캐싱 기능을 이용해 데이터를 페칭해온다.<br> [BE]: FCM을 통해 알림을 구현한다.<br> 2. 스킴/슈링크플레이션 정보 시각화 대시보드<br> [FE]: nivo 차트 라이브러리를 이용해 차트를 구현한다.<br> [BE]: Python selenium 및 beautiful soup을 사용하여 정보를 크롤링하고 DB에 저장한다.<br> [ML]: Yolov5 및 EasyOCR 모델을 finetuning하여 상품 정보를 자동으로 DB화하는 파이프라인을 형성한다.<br> 3. 대체품 추천 챗봇<br> [FE]: 라이브러리를 이용하지 않고, useEffect 를 이용해 챗봇의 자동 응답을 비동기적으로 처리한다.<br> [BE]: API 서버와 모델 서버 간의 통신을 통해 사용자가 원하는 기능의 종류를 파악하고, usecase로 관리된 service 함수에 따라 기능을 수행한다.<br> [ML]: KoBERT 모델을 finetuning하여 사용자의 채팅을 서비스 기능 중 하나로 분류한다. |
| (8-6) 과제: 세부 기술 | FE: cloudflare 로 배포한 next.js ver.14 의 SSG 환경 사용,  typescript 를 사용하여 정적 타이핑 검사 진행, 빌드 툴로는 yarn3 를 사용함으로써 빌드 속도를 가장 높였다.<br> BE: aws를 통해 배포한 jdk 17 기반 Spring Boot 3 기반 api 서버와 flask 기반 model 서버로 기능을 제공한다. 빌드 툴로는 gradle을 사용하고, KotlinDSL을 통해 gradle 파일을 작성하였다.<br> ML: python과 pytorch 기반 AI 모델링 진행, 자연어처리 모델 베이스라인으로는 KoBERT, OCR 모델 베이스라인으로는 EasyOCR을 사용했으며, 상품 태그 영역 인식을 위해 yolov5를 새로 학습했다. |
| (8-7) 과제: 기대 효과 및 의의 | 1. 변동사항 알림 기능<br> 슈링크/스킴플레이션이 발생했을 때, 소비자가 이를 놓치지 않고 바로 발견함으로써, 자신이 알고 있던 상품 정보가 자신도 모르는 사이에 바뀌어 있는 일을 방지한다. 상품 변동에 대한 투명성 증가가 기업의 잦은 슈링크/스킴플레이션을 억제하는 효과가 있을 것으로 기대된다.<br> 2.  스킴/슈링크플레이션 정보 시각화 대시보드<br> 소비자가 상품 변동 정보에 쉽게 접근할 수 있게 되어, 스팀/슈링크플레이션 발생 상품의 구매를 지속할지에 대한 판단을 주체적으로 할 수 있게 된다. 해당 기능을 통해 현명하고 합리적인 소비를 촉진할 것으로 예상된다.<br> 3. 대체품 추천 챗봇<br> 슈링크/스킴 플레이션이 발생한 어떤 상품을 알리는 것에 그치지 않고, 이에 대한 대체제를 추천한다는 데에 의의가 있다. 소비자의 소비 선택의 폭을 확장하고 유연한 소비를 유도할 것으로 기대된다. |
| (9) 데모 내용 |  1. 홈 화면에서 알림 화면으로 이동해, 슈링크 / 스킴 플레이션이 발생한 식료품들의 알림을 확인했습니다.<br> 2. 홈 화면에서 검색 화면으로 이동해, 원재료 검색과 상품명 검색 기능을 확인했습니다.<br> 3. 홈 화면에서 카메라 화면으로 이동해, 상품의 태그를 찍고, 찍힌 상품의 정보를 불러왔습니다.<br> 4. 카메라 화면에서 태그를 찍은 상품의 상품 상세 화면으로 이동해, 용량 및 가격 그래프와 날짜별 원재료 리스트 변화를 확인했습니다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-04
| (1) 과제명 | 김약사: 노년층을 위한 머신러닝과 광학 문자 인식을 통한 약 복용 관리 모바일 앱
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 04-심가탕후루 |
| (3) 팀원 역할 분담 | 이승민(2076308): 리더, 백엔드, 머신 러닝<br>신단아(2144015): 팀원, 프론트엔드, OCR<br>조윤아(2171047): 팀원, 백엔드, DB |
| (4) 팀 지도교수 | 심재형 교수님 |
| (5) 팀 멘토 | 서진원 / 한화시스템/ICT / ICT RM팀 과장 |
| (6) 과제 키워드(keywords) | 노인친화적, 약 복용, 건강 |
| (7) 과제 내용 요약 | 이름 모를 약의 정보가 궁금해지는 경우, 약의 사진을 찍어 바로 찾을 수 있는 서비스는 드뭅니다. 또한, 약 먹을 때를 까먹는 것은 약 복용에 있어 치명적인 불편함으로 작용합니다. 이와 같은 불편함은 많은 약을 장기 복용하는 노년층에게 더욱 치명적입니다.<br>김약사는 이러한 노년층이 겪는 문제점을 해결하기 위해 머신러닝을 이용한 분류로 알약을 이미지만으로 검색할 수 있게 하고, OCR 기능으로 약 봉투를 인식하여 편리하게 약 복용 알람을 등록할 수 있게 하는 모바일 앱입니다. |
| (8-1) 과제: 문제의 정의 | 1. 이름을 모르는 알약의 정보를 쉽게 찾을 수 있는 서비스가 필요하다. 현재 이름을 모르는 낱알의 알약의 사진을 찍어 찾을 수 있는 서비스는 드물다. 사진을 찍어 누군가에게 질문을 하거나, 생김새를 바탕으로 직접 필터링을 하여 고를 수 있는 서비스가 이를 대체하고 있다. 노년층의 경우, 단순히 궁금해서가 아니라 건강 상의 이유로 이러한 알약 검색 기능이 필요한 특수한 상황이 생긴다. 예를 들어, 항혈전제를 꾸준히 복용하던 환자가 내시경을 앞두고 있는 경우, 출혈을 예방하기 위해서 항혈전제를 잠시 중단해야 한다. 만약 평소 복용하는 약이 많아 어떤 것이 항혈전제인지 찾지 못하는 사람에게 사진만으로 알약을 찾을 수 있는 기능이 있다면, 편리하게 약을 골라낼 수 있게 될 것이다.<br>2. 약 복용 여부를 알려주고 체크할 수 있게 해주는 서비스가 필요하다. 약을 잊지 않고 꾸준히 복용하는 것은 중요한 요소이다. 약 복용을 잊어버리는 것은 약을 복용하는 모든 사람들에게 고질적인 문제이고, 이는 기억력이 저하되지만 복용해야하는 약은 많은 노년층에게 더욱 치명적인 문제점이 된다.<br>3. 노인을 위한 약 복용 도움 서비스가 필요하다. 우리나라의 노인 인구 중 약물 과다 복용 및 부적절한 복용을 하는 인구가 증가하고 있는 추세이다. (우리나라 노인들, ‘과다 및 부적절 약물’ 복용 많다, 팜뉴스, 2023.11.27) 이렇듯 노년층의 약 복용을 돕는 서비스의 필요성이 크지만, 현재 시장에 약 복용을 돕는 헬스 케어 앱 중에서 노년친화적인 서비스는 극히 드물다는 문제점이 있다. |
| (8-2) 과제: 기존연구와의 비교 | 1. (이름 모를 알약의 정보를 쉽게 찾을 수 있는 서비스가 필요하다.)<br>아하 <br>장점 : 약사를 직접 찾아가지 않아도, 약사에게 질문을 할 수 있다. 답변에 대한 신뢰도가 높다.<br>단점 : 직접 결과를 알 수 없고, 약사의 답변이 올 때까지 기다려야 한다. 노인친화적이지 못한 UI/UX<br><br>약학정보원 식별 정보 입력<br>장점 : 알약의 생김새를 바탕으로 검색을 할 수 있다.<br>단점 : 번거롭다.<br><br>2,3 (약 복용 여부를 알려주고 체크할 수 있게 해주는 서비스가 필요하다.)<br>파프리카 케어<br>장점 : 약 복용을 원활하게 해줄 수 있는 많은 기능이 갖춰져 있다.<br>단점 : 노인친화적이지 못한 UI/UX |
| (8-3) 과제: 제안 내용 | 1. (이름 모를 알약의 정보를 쉽게 찾을 수 있는 서비스가 필요하다.) : 알약의 사진을 찍어 알약의 이름 및 정보를 검색할 수 있는 기능 제공<br>2. (약 복용 여부를 알려주고 체크할 수 있게 해주는 서비스가 필요하다.) : 약 봉투의 사진을 찍어 복용하는 약물 목록을 추출하고, 복용 정보를 인식해 자동으로 알람을 등록해주는 기능 제공<br>3. (노인을 위한 약 복용 도움 서비스가 필요하다.) : 약 복용 시 주의 사항 제공 / 노인친화적인 UI/UX |
| (8-4) 과제: 과제의 주요 기능 | 1. 알약의 사진을 찍어 알약의 이름 및 정보를 검색할 수 있는 기능 제공 : MobileNetV2 분류 모델 이용<br>2. 약 봉투의 사진을 찍어 복용하는 약물 목록을 추출하고, 복용 정보를 인식해 자동으로 알람을 등록해주는 기능 제공 : NAVER CLOVA OCR 이용<br>3. 약 복용 시 주의 사항 제공 : DUR 정보 연동 |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-05
| (1) 과제명 | 모락모락: 개인 맞춤형 헤어스타일을 추천받고 다양한 조건을 비교하여 본인에게 맞는 헤어 디자이너를 찾을 수 있도록 매칭해주는 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 05-A.A |
| (3) 팀원 역할 분담 | 김지원(2176100): 리더, 백엔드 구현 및 서버 배포<br>오예린(2176218): 팀원, 프론트엔드 및 UI/UX 디자인<br>황서정(2076456): 팀원, 백엔드 구현 및 AI 기능 구현 |
| (4) 팀 지도교수 | 김명 |
| (5) 팀 멘토 | 김정민 / KT / R&D 전임 연구원 |
| (6) 과제 키워드(keywords) | 헤어스타일, 얼굴형, 헤어 디자이너 포트폴리오 |
| (7) 과제 내용 요약 | 일반 사용자들은 본인의 얼굴형에 따른 best 와 worst 헤어스타일을 추천받을 수 있고, 헤어디자이너와의 매칭까지 하나의 로직 안에서 경험해볼 수 있으며, 헤어디자이너들에게는 개인의 작업물을 모아 자신을 홍보 및 브랜딩 할 수 있는 기회를 제공합니다.  |
| (8-1) 과제: 문제의 정의 | 자신의 얼굴형에 어울리는 헤어스타일이 무엇인지 궁금한, 어떤 헤어스타일을 해야 할 지 고민인 20대 여성들이 많으며, 미용실 혹은 자신을 헤어 디자이너 자체로서 어떻게 홍보해야할지 어려움을 겪는 헤어 디자이너들이 많다는 문제가 존재한다.  현재는 주로 인스타그램/개인 블로그를 통한 홍보가 많이 이뤄지기 때문에  정보가 많이 분산 되어 있어 고객들이 찾기 힘들고 , 디자이너들은 홍보 효과 보지 못하고 있다.   |
| (8-2) 과제: 기존연구와의 비교 | 1 헤어핏 <br> - 가상 체험을 통해 다양한 헤어스타일을 체험 가능. <br>- 별도 기능으로 주변 디자이너들에게 시술 예약 가능.<br>- 하지만, 전체적으로 합성 과정이 어색하며 결과물이 자연스럽지 못함.<br>- 사용자에게 잘 어울리는 헤어스타일을 제공하지 않고 사용자가 직접 머리를 합성해봐야함 <br>- 합성을 했다고 그게 그 헤어스타일을 잘 하는 디자이너와 바로 연결되지 않음. 따라서 등록된 디자이너들이 많아도 디자이너들에 대한 홍보 효과는 부족함. <br>2 카카오헤어샵<br>- 헤어 디자이너들의 포트폴리오를 확인하기에는 유용한 서비스. <br>- 스토리북 기능이 있어 마음에 드는 헤어스타일의 사진을 클릭 시 어떤 헤어 디자이너가 그 머리를 했는지 확인할 수 있음.<br>- 하지만 개인 헤어스타일 추천 시스템은 존재하지 않으며, 오직 디자이너들의 홍보에 초점을 맞춘 느낌임.<br> 3. 결론:<br>- 사용자 맞춤 헤어스타일을 추천해주는 서비스는 존재하지 않는다. <br>- 특히, 헤어디자인에 가장 핵심적인 요소인 얼굴형을 고려한 서비스는 더더욱 존재하지 않는다.<br>- 헤어스타일을 가상으로 체험해봐도 해당 헤어를 잘하는 디자이너를 추천받을 수 있는 앱은 없다. 즉, 사용자들은 가상 헤어 기능까지만 체험하고 맞춤 디자이너까지 찾아보지는 않으므로, 현존하는 앱들을 이용해 디자이너들은 고객 유치가 힘들다. |
| (8-3) 과제: 제안 내용 | 사용자들에게 헤어스타일을 추천해주기 위해서 얼굴형을 분석하여 어울리는 헤어 합성 사진을 볼 수 있는 기능과 어울리지 않는 합성 사진이 동시에 제공되는 방법을 제시하였다. 또한 헤어 추천 기능과 디자이너의 포트폴리오를 확인할 수 있는 기능이 하나의 서비스에 합쳐진 것이 우리 서비스의 장점이라고 할 수 있다.  |
| (8-4) 과제: 과제의 주요 기능 | 사용자 얼굴 사진으로 얼굴형 분석<br>사용자에게 가장 잘어울리는, 가장 안어울리는 헤어스타일 추천<br>디자이너 포트폴리오 전체 조회<br>디자이너 검색<br>디자이너가 자신의 포트폴리오 생성  |
| (8-5) 과제: 구현 방법 | - AI<br>Kaggle 에서 얼굴형을 5가지 Heart, Oblong, Oval, Round, Square 로 분류한 dataset을 이용하여 colab을 통해 얼굴형 판단 EfficientNet 모델을 파인튜닝한 뒤, 학습시킨 EfficientNet-B4 모델을 이용하여 사용자의 얼굴형 예측을 진행합니다. 예측된 얼굴형과 가장 낮은 확률로 예측된 얼굴형에 대해 사용자 얼굴 사진과 미리 데이터를 넣어놓은 헤어스타일 사진을 합성하여 이미지를 생성하고, 이 결과 이미지를 AWS S3에 업로드 하고 presigned URL 기능을 통해 URL만 다운로드 하여 사용할 수 있게 합니다. 해당 ai모델은 google cloud platform을 통해 gpu를 할당받아 배포함으로써 서비스의 속도를 높였습니다. <br>- 백엔드 <br>프론트엔드로부터 들어온 API 요청 및 유저 인증 로직을 Spring Boot를 사용해 코드로 작성하였습니다. 카카오톡 유저인증(회원가입, 로그인)부터 헤어디자이너의 포트폴리오 작성, 필터링, 드롭다운 기능 및 일반 손님의 얼굴형에 어울리는 헤어디자이너 추천, 헤어디자이너 포트폴리오 좋아요 및 조회 등의 API에 대한 로직을 Spring Security 프레임워크를 통해 인증 및 인가하였습니다. 전체 코드를 Docker image로 만들어 Docker Hub로 푸시하도록 구현했으며 github action을 통한 CI/CD 파이프라인을 구성함으로써, 매 푸시(push)마다 자동으로 업데이트된 내용을 포함해 서버 재배포가 되게 하였습니다.서버는 AWS의 EC2에 도커 이미지를 풀(pull)해 작업환경과 같은 배포환경을 만들어 사용하였습니다. 데이터베이스로 RDS를 private 서브넷에 둔 후 EC2에서 SSH연결을 함으로써 접근하여 사용했으며, Route53과 loadbalancer, 인증서를 통해 TLS통신을 구현함으로써 보안 및 비용적인 부분의 효과를 높였습니다. <br>-프론트 <br> 프론트 측에서는 사용자 친화적인 UI/UX를 구상해 구현하는 데 초점을 맞췄으며, 적절한 애니메이션 효과를 넣었습니다. 유저 인증 과정에서 빠르고 효과적인 인증 과정을 위해 Next.js의 미들웨어 기능을 활용하였습니다. 또한 서버로부터 사진 등의 크기가 큰 리소스를 불러오는 데 지연 시간을 줄이기 위하여 서버사이드 렌더링을 최대한 활용하려 노력하였습니다. 디자이너가 스스로를 홍보할 수 있는 화면(디자이너 포트폴리오 등록, 디자이너 리스트, 디자이너 상세 페이지)와 사용자 플로우(가상 헤어 체험, 디자이너 리스트 필터링 페이지, 좋아요 누르기 등) 기능 및 화면을 구현하였습니다. 마지막 배포는 vercel을 이용해서 진행하였습니다. |
| (8-6) 과제: 세부 기술 | 1. 얼굴형 판단 <br> Kaggle dataset을 이용하여 얼굴형 판단 EfficientNet B4 모델을 파인튜닝한다. 사용자로부터 입력받은 이미지를 전처리하여 모델에 적합한 형식으로 전환한다. 그 다음 전처리된 이미지를 입력으로 받아 얼굴형을 예측하는 함수를 통해 가장 알맞은 얼굴형과 가장 낮은 확률로 예측된 얼굴형을 결과로 출력한다. <br> 2. 얼굴 합성 <br> FaceSwap 모델을 서비스에 맞게 수정한 후 기존에 쌓아놓은 데이터베이스의 헤어 데이터와 사용자에게 바로 입력받은 이미지를 합성하도록 한다. 얼굴형 판단을 통해 나온 결과를 토대로 어울리는 헤어스타일 및 어울리지 않는 헤어스타일을 매칭하여 해당 헤어 이미지와 합성하도록 한다.       |
| (8-7) 과제: 기대 효과 및 의의 | 이 프로젝트를 통해 사용자들은 자신의 얼굴형에 대한 이해와 헤어스타일 선택에 도움을 받을 수 있으며, 헤어 디자이너들과의 연결까지 제공받을 수 있다. 자신의 얼굴형 판단 결과에 대한 호기심을 갖고, 동시에 자신의 얼굴형에 맞는 헤어스타일을 예측하며 추천받고 싶어하는 20대 여성들이 얼굴형 예측 결과를 제공받을 수 있다. 뿐만 아니라 그에 따른 헤어스타일과 사용자 얼굴 합성 사진을 다양하게 제공받을 수 있다. 동시에 자신에게 추천되는 헤어스타일을 주력으로 하는 디자이너를 추천받고 디자이너의 포트폴리오와 관련된 정보를 제공받을 수 있다.디자이너들은 자신의 헤어스타일 작품을 모아 포트폴리오로 생성할 수 있으며 이를 서비스의 다양한 사용자들에게 노출시킴으로써 자신을 홍보할 수 있고 나아가 고객을 확보하는 지름길이 될 수 있다. |
| (9) 데모 내용 | 1) 카카오 로그인 하기 <br> 2) 일반 유저 선택하기 <br> 3) 팀장 얼굴 사진 업로드하기 <br> 4) 헤어스타일링 합성사진 받기 <br> 5) 헤어 디자이너 추천 받기  |
| (10) 기타 | <b>서비스 아키텍처</b><br> ![image](https://github.com/SeojungH/CapstoneDesign-24-1H/assets/86144019/96ce2aaa-bbc5-4e5d-9823-7aa1224b8341) |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-06
| (1) 과제명 | Inkspire: GPT 생성 게임 스크립트 기반 사용자 맞춤형 텍스트 RPG
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 06-너도 멸종되지 않게 조심해 |
| (3) 팀원 역할 분담 | 오수현(1928019): 팀원, 백엔드 서버 구축 (SpringBoot, AWS 서버 배포), GPT api 호출 프롬프트 엔지니어링<br>이소민(2071035): 팀원, 클라이언트 Unity 개발, 전투 / 플레이 시스템 기획 및 개발, GPT api 호출 프롬프트 엔지니어링<br>이가빈(2176240): 리더, 클라이언트 Unity 개발, 맵 생성 및 이벤트 시스템 기획 및 개발, GPT api 호출 프롬프트 엔지니어링 |
| (4) 팀 지도교수 | 박상수 교수님 |
| (5) 팀 멘토 | 유원준 / 네이버 클라우드 / 연구원 |
| (6) 과제 키워드(keywords) | 텍스트RPG, ChatGPT, 실시간 상호작용 |
| (7) 과제 내용 요약 | Inkspire는 사용자에게 풍부한 맞춤형 게임 경험을 제공하는 어플리케이션이다. 사용자가 선택한 스크립트 배경과 장르, 게임을 진행하며 주어지는 선택지에 따라 각자 다른 형태와 내용의 스크립트가 생성되어 사용자는 다양하고 흥미로운 게임 세계를 탐험할 수 있다. 뿐만 아니라 시나리오 작성, 미션 및 퀘스트 설계, 대화 시스템 구축 등과 같은 작업의 자동화로 끊임없이 새로운 아이디어를 도출해야 하는 게임 개발자들에게도 혁신적인 이점을 제공한다. |
| (8-1) 과제: 문제의 정의 | 최근 몇 년 동안 인공지능(AI) 기술의 혁신적인 발전은 다양한 산업 분야에 변화를 가져오고 있다. 이러한 변화들은 맞춤형 콘텐츠의 제공이라는 공통점을 지니고 있다. 즉, 인공지능은 빅데이터, 기계학습 및 자연어 처리 기술을 통합하여 사용자별로 맞춤형 경험을 제공하는데 이상적인 툴이 되었다. 이러한 기술 발전과 더불어 소비 경향도 변화하고 있다. Insight M과 CJ AI center에서 조사한 2023년 소비 트렌드 시리즈에 따르면 오늘날의 소비자는 다음과 같은 요구사항을 가지고 있다. 응답자의 72%가 기업이 소비자를 개인으로 인식하고 개인의 관심사를 알기를 기대하고, 71%의 소비자는 개인화된 커뮤니케이션과 제품을 제공받기를 원하며 76%의 소비자가 개인화된 브랜드에서 구매를 고려할 가능성이 더 높다고 답했다.<br>이러한 맥락 속에서 게임 산업도 AI의 발전에 영감을 받아 혁신적인 변화를 겪고 있다. 플레이어들은 개별화된 게임 경험을 원하며, 자신의 선택과 선호도에 따라 게임 세계를 탐험하고 싶어한다. 이와 같이 사용자의 취향에 맞는 "맞춤형 콘텐츠"에 대한 소비자들의 수요가 증가함에 따라 창작자의 취향에 맞추어 창작된 기존의 시나리오는 그들의 기대를 충족시키기 어렵다는 한계점을 가지고 있다. 하지만, 기존 게임 시장에서는 맞춤형 컨텐츠 서비스를 제공하는 사례가 적으며 게임 개발자들이 이러한 사용자 맞춤형 콘텐츠를 만들기 위해서는 많은 노력과 시간을 투자해야 한다. 시나리오 작성, 다양한 미션 및 퀘스트 설계, 대화 시스템 구축 등 직접 맞춤형 콘텐츠를 제작하는 데에는 복잡한 작업들이 따른다. 실제로 시청자들의 선택에 따라 이야기가 달라지는 넷플릭스의 ‘블랙미러: 밴더스내치’ 제작자는 “인터랙티브는 노동집약적인 작업” 이라고 평가하는 등 맞춤형 컨텐츠 제작 과정 중 스크립트 작업에 많은 시간을 투자해야함을 강조하기도 했다. 또, 기존의 생성형 AI의 답변에는 매끄럽지 않은 부분이 많고, 특히 일관적인 내용이나 말투를 생성하는데 어려움이 있다. 따라서 이러한 문제들을 해결하고 사용자의 몰입감과 만족도를 높일 수 있는 AI 게임 스크립트 생성 어플리케이션을 개발할 계획이다. |
| (8-2) 과제: 기존연구와의 비교 | <b>AI 던전</b><br>OpenAI의 AI 던전은 자연어 처리 및 기계학습 기술을 활용하여 맞춤형 텍스트 기반 어드벤처 게임을 생성하는 플랫폼이다. 플레이어는 자신의 선택에 따라 게임의 진행을 조작하며, AI는 플레이어의 입력에 따라 실시간으로 스토리와 상호작용을 생성한다. 이를 통해 각 플레이어에게 맞춤형 경험을 제공하고 있다.<br>그러나, AI 던전은 영어 기반의 텍스트로 훈련시킨 모델을 사용했기 때문에 한국어와 같은 다른 언어로의 번역이나 맥락 파악에 있어서 아직 완벽하지 않은 경우가 있다. 때로는 한국어로 게임을 플레이 했을 때 입력된 텍스트의 맥락을 정확하게 이해하지 못하거나, 부적절한 답변을 생성하기도 한다. 더 심각한 문제로는 AI에 과부하가 걸려 게임이 진행되지 않는 상황도 발생할 수 있다. 영어로 플레이를 하더라도 플레이어가 각종 설정을 세부적으로 설정하지 않으면 스토리가 제대로 진행되지 않는다는 단점이 있다. 또한, 게임의 목표나 보상이 불분명하여 게임이 아닌 AI와 함께 소설을 쓰는 과정과 유사하게 느껴질 수 있다.<br><br><b>메이비(Maybe)</b><br>시나몬 게임즈의 메이비는 네이버 인기 웹툰 및 웹소설을 기반으로 플레이어가 특정 작품을 선택하면 각 상황에 따른 질문이 주어지고, 플레이어의 선택(답변)에 따라 메인 스토리가 전개되는 게임이다. 게임 내에는 다양한 직업과 능력이 있어 플레이어들은 자신만의 캐릭터를 발전시키고 특수 기술을 습득할 수 있으며, 플레이어의 다양한 선택에 따라 본인만의 엔딩을 만들어 갈 수 있기 때문에 기존 네이버웹툰 독자뿐만 아니라 새로운 유저들도 함께 즐길 수 있다.<br>하지만, 이는 네이버 웹툰 혹은 웹소설과 같이 정해진 스토리와 캐릭터를 기반으로 진행되는 게임이기 때문에 플레이어의 게임 내 자유도가 높다고 볼 수 없으며, 사용자의 취향에 맞는 새로운 서사구조를 맞춤형으로 제공한다고 보기는 어렵다.<br><br><b>고스트라이터 (Ghostwriter)</b><br>유비소프트의 고스트라이터는 AI 대사를 재구성하는 LLM으로 게임용 NPC의 기본 대사 초안을 생성하는 AI 도구로 많은 수의 NPC를 구현해야 하는 게임에서 사용되고 있다. NPC가 많은 게임의 경우, NPC 구현에만 10만 줄이 넘는 대화 스크립트를 작성해야 해서 스크립트 작업에 많은 시간이 소요되는데, 이러한 대화 작성 작업을 고스트라이터를 통해 자동화하여 업무 시간을 줄이고 더욱 효율적으로 게임을 개발할 수 있다. 또한, 고스트라이터는 복수 대사를 출력하기 때문에 각본가는 이 중 원하는 옵션을 선택할 수 있고 출력한 대사를 자유롭게 편집할 수 있다.<br>그러나, 고스트라이터는 개발 단계에서 사용하는 툴로, 시나리오 작성 시 제작자를 보조하는 수준으로 사용되고 있으며 플레이어와 NPC의 실시간 상호작용 및 대화를 지원하지는 않는다.  또한, NPC 대사 생성 기능에만 초점을 맞추고 있어 전체적인 게임 시나리오를 개인화하여 제공한다고 보기는 어렵다. |
| (8-3) 과제: 제안 내용 | <b>맞춤형 게임 경험 제공</b><br>Inkspire는 사용자의 선택과 선호를 기반으로 AI가 게임 시나리오 및 목표를 자동으로 생성하는 시스템을 구축하여 개인 맞춤형 게임 경험을 제공한다. 자연어처리를 기반으로 한 알고리즘을 사용하여 플레이어의 행동과 선호를 분석하고, 이에 따라 게임의 스토리, 미션, 아이템, 적, 난이도 등을 적절하게 조절하여 즐겁고 흥미로운 게임 경험을 선사할 것이다. 최종 산출물이 나온 후 6월 첫째주 동안 베타 테스트를 진행하여 맞춤형 게임 경험에 대하여 70% 이상의 만족도를 이끌어내는 것을 목표로 프로젝트를 진행할 예정이다.<br><br><b>자동화된 시나리오 생성 및 콘텐츠 제작</b><br>자연어 처리 기술을 활용한 대화 시스템을 개발하여 플레이어의 질문 및 행동에 따라 실시간으로 적절한 대화를 생성하고 스토리를 진행시키며 상호작용할 수 있는 게임 내 시나리오 진행 시스템을 구축할 것이다. 이를 통해 사용자는 보다 적극적으로 게임 스토리에 개입할 수 있으며 제작자는 콘텐츠 제작 과정에서 시나리오 작성에 소요되는 자원을 크게 줄일 수 있다. |
| (8-4) 과제: 과제의 주요 기능 | <b>1. 사용자 식별 및 보상 시스템</b><br> - 사용자는 로그인/회원가입을 할 수 있다.<br> - 사용자는 자신의 탐험 목록(캐릭터 이름 및 장르)을 확인할 수 있다.<br> - 사용자는 과거에 플레이했던 내용을 확인할 수 있다.<br> - 사용자는 엔딩을 본 스크립트에 따른 보상을 획득할 수 있다.<br> - 사용자는 최종 엔딩에 성공한 스크립트 개수에 비례하여 칭호를 획득할 수 있다.<br><br><b>2. 게임 초기 설정</b><br> - 사용자는 캐릭터 이름, 장르, 시/공간적 배경을 입력하여 자신이 원하는 테마의 게임을 생성할 수 있다.<br> - 입력받은 장르와 시/공간적 배경을 바탕으로 게임의 세계관, npc 시스템, 장소 시스템, 목표 시스템을 생성할 수 있다.<br> - 사용자는 플레이 할 캐릭터의 초기 스탯 값을 설정할 수 있다.<br><br><b>3. 게임 진행</b><br> - 사용자는 장소 리스트 중 스토리를 진행할 장소를 선택할 수 있다.<br> - 사용자는 캐릭터의 행동 지문을 입력하여 게임을 진행할 수 있다.<br> - 사용자가 챕터 목표와 관련 없는 전투 이벤트가 발생하는 장소에 진입할 경우 캐릭터의 스탯을 이용하여 전투에 참여할 수 있다.<br> - 사용자가 챕터 목표와 관련 없는 전투에서 승리할 경우 보상 아이템을 획득할 수 있다.<br> - 사용자가 챕터 목표와 관련 있는 장소에 진입할 경우 장소를 탐색하며 정보 혹은 아이템을 획득할 수 있다.<br> - 사용자가 챕터 목표 달성에 성공하면 다음 챕터 장소에 진입할 수 있게 되며, 실패할 경우 해당 챕터를 재 진행한다.<br> - 사용자가 챕터 목표 달성에서 일정 횟수 이상 실패할 경우 PNPC를 통해 힌트를 획득하거나 다음 챕터 진행을 선택할 수 있다. |
| (8-5) 과제: 구현 방법 | ![Inkspire_SW_solution](https://github.com/SuHyeon00/CapstoneDesign-24-1H/assets/90602694/1c5f1589-9134-47e7-b66a-e870e30a08a7)<br><b>게임 초기 설정</b><br>- 기본 스크립트 골격 생성<br>플레이어로부터 입력받은 게임의 장르, 공간/시간적 배경을 토대로 GPT 모델을 활용하여 게임의 전체적인 배경이 될 세계관을 생성한다. 생성된 세계관을 토대로 게임 내 등장할 npc와 최종 목표 및 챕터별 목표를 생성한다.<br>- NPC 생성<br>NPC는 게임의 기본 세계관에 따라 이에 어울리는 조력자 NPC와 적대자 NPC가 생성된다. 이렇게 생성된 NPC는 사용자가 게임을 플레이하는 과정에서 등장하며 스토리에 개입한다. NPC는 게임이 진행되는 동안 일관된 말투를 사용하며 사용자와의 이전 대화 내용을 저장하여 기억하는 형태로 구현하였다.<br>- map 생성<br>게임의 세계관을 바탕으로 플레이어가 탐색할 수 있는 장소를 생성한다. 장소는 최종 챕터에서 한 곳, 일반 챕터 당 세 곳 씩 총 열 세 곳이 생성되며 세 장소 중 하나에는 챕터 목표 달성을 위한 퀘스트가 주어진다. 목표 달성과 관련 없는 장소에서는 랜덤한 확률로 잡몹과의 전투, 아이템 획득, 적대자 NPC 등장 등의 일반 이벤트가 발생하며 플레이어는 자유롭게 장소를 탐색하며 게임을 진행할 수 있다.<br>- 플레이어 스탯<br>플레이어는 공격, 방어, 민첩, 정신, 행운의 5가지 스탯을 1-100 범위 내의 숫자로 설정할 수 있다. 단, 스탯 합 제한범위 내에서 스탯을 배분한다. 그 이상의 스탯은 추후 스크립트 플레이 중몬스터와 전투를 통해 얻는 보상으로 상승시킬 수 있다. 스탯은 실제 플레이어의 스탯을 저장하는 PlayerStatManager.cs 코드와 스탯 시스템의 구조와 함수를 정의해둔 Stats.cs 코드를 분리해 안전성을 높였다. 플레이어 스탯의 변동은 자주 일어나지 않고 변동의 중요도가 높으므로, 변동시마다 서버와 통신하여 DB에 저장되어있는 내용을 갱신한다.<br><br><b>게임 플레이</b><br>- 대화 시스템<br>게임은 장소 중심 대화형식으로 진행된다. 각 챕터마다 새로운 장소가 열리며, 플레이어는 이 장소들을 조사하며 게임 스토리의 실마리를 얻는다. 플레이어가 행동이나 대사 지문을 입력하고 전송하면, 프로그램은 이를 GPT에 입력하고 GPT를 호출해 다음 진행될 스크립트를 생성하게 한다. 각 장소에는 판정을 하여 아이템을 얻거나 NPC와 조우하는 등의 이벤트가 숨어 있는데, 이 이벤트 발동 조건을 충족하는 행동을 하는 지문을 입력할 시 주사위 이벤트가 진행된다. 발동 조건은 매 턴 사용자의 입력과 GPT의 답으로 구성된 스크립트를 자연어 기반 유사도 알고리즘을 통해 만든 이벤트 트리거 체커에 의해 충족되었는지 판단한다.<br>- 주사위 시스템<br>이벤트 트리거 체킹 시스템에 의해 이벤트가 발생하면 GPT는 현재 진행중인 스크립트와 개연성 있는 진행으로 이벤트의 발생 상황을 출력하며 이벤트 발생을 알린다. 이후 일정 기준치가 주어짐에 따라 사용자는 주사위를 굴려 기준치보다 높은 값을 얻어야만 이벤트 판정에 성공하게 된다. 이런 주사위 판정 시스템은 고전 스토리 게임 장르인 TRPG에서 차용한 것이며 게임에 랜덤성을 부여하여 예측할 수 없는 운의 요소를 개입시킨다. 주사위 판정이 끝나면 GPT는 각각 성공/실패 여부에 맞는 스토리 스크립트를 생성하며 게임을 이어간다.<br>- 전투 시스템<br>플레이어가 전투 이벤트가 존재하는 장소에 들어가게 되면 전투 이벤트가 발생한다. 몬스터의 스탯 수치는 일정 범위 내에서 무작위로 생성되며, 플레이어와 몬스터는 턴제 전투를 시행하게 된다. 전투에 참여한 구성원은 각자 공격 턴, 방어 턴을 번갈아 갖게 되는데 이때 턴의 종류에 따라 수행할 수 있는 행동이 달라진다. 시스템적으로 일관되지 않은 게임은 플레이어로 하여금 재미가 아닌 혼란을 느끼게 할 수 있으므로 전투 시스템에서는 일관된 규칙을 적용하고 GPT의 개입을 배제하여 게임성을 높이고 사용자가 느낄 수 있는 복잡도를 줄였다. |
| (8-6) 과제: 세부 기술 | <b>GPT prompt</b><br>GPT-3.5 turbo 모델을 사용하여 사용자 입력에 따른 적절한 대화를 생성하고 스토리를 진행시킬 수 있는 프롬프팅 환경을 구축하여야 한다. 따라서 세부 기능별로 다른 프롬프팅 환경을 구축하고 이를 유기적으로 연결하는 과정을 통하여 일관된 내용이 출력되도록 조정하였다. OpenAI-Unity 외부 패키지를 이용하여 GPT 모델과 게임 엔진의 통합 가능성을 확인하였으며, 해당 모델이 사용자와의 자연스러운 상호작용을 위한 게임 시나리오와 일관된 대화를 생성하는지 확인하였다.<br><br><b>Unity와 웹 통신</b><br>게임 데이터 저장 및 사용자 구분을 위한 웹 통신 환경을 구축하여야 한다. 따라서 유니티 엔진의 Networking 패키지를 이용하여 aws 클라우드 서버에 배포된 웹서버와의 통신 가능성을 확인하였다. |
| (8-7) 과제: 기대 효과 및 의의 | 게임 플레이어 측면에서의 기대 효과로는 플레이어의 경험 개선 등을 기대할 수 있다. 증가하는 맞춤형 콘텐츠에 대한 수요에 맞춰 플레이어들에게 게임 세계와 캐릭터에 대한 맞춤형 시나리오를 제공하여 게임 경험의 다양성을 향상시킬 것으로 기대된다. 플레이어들은 이 자동화된 시나리오를 통해 전보다 더욱 다양한 컨텐츠 및 높은 자유도 속에서 게임 세계에 더욱 깊이 참여하고 상호작용할 수 있으며, 게임의 흥미와 재미를 높일 것으로 예상된다.<br>게임 개발자 측면에서의 기대 효과로는 게임 개발 생산성 향상과 스토리 라인의 다양성 등을 기대할 수 있다. 자연어 처리를 이용한 자동화된 시나리오 생성을 통해 다른 개발 단계에 전보다 많은 시간과 노력을 투자할 수 있어 개발 시간을 단축하고 최종적으로는 보다 빠른 게임 출시를 가능하게 할 것이다. 또한, 게임 개발자들의 무한한 창작 부담을 덜 수 있는 계기가 되어 게임의 스토리 라인을 더욱 다양하게 확장하고 풍부하게 만들 수 있도록 돕는 효과도 있을 것이다.<br>더 나아가 자연어 처리 기술을 게임 개발 분야에 적용하여 게임 개발과 엔터테인먼트 산업에 새로운 가능성을 제시하고 미래 게임 개발에 영감을 줄 수 있을 것이다. Inkspire는 기존 하나의 게임을 관통하는 세계관, 시나리오를 기반으로 제작되던 게임 서비스에서 벗어나 하나의 게임으로 다양한 세계를 탐험할 수 있는 게임 서비스로 나아갈 수 있는 시발점이 될 것이다. 이러한 기술 혁신은 게임 산업의 성장과 향상에 기여할 것으로 예상된다. |
| (9) 데모 내용 | 1. 사용자 계정 생성 및 로그인<br>2. 플레이어 캐릭터의 스탯(능력치) 설정<br>3. 사용자 입력 기반 게임 기본 정보(세계관, 인트로, 목표, 이벤트, npc, 장소) 생성<br>4. NPC와의 대화 상호작용<br>5.주사위 이벤트 진행 - 성공 / 실패 시나리오<br>6.전투 이벤트 진행<br>7. 최종 목표 클리어 후 에필로그 진행<br><br>데모는 안드로이드 모바일 앱에서 동작한다. |
| (10) 기타 | <b>SW 아키텍처</b><br>![Inkspire_SW_Architecture](https://github.com/SuHyeon00/CapstoneDesign-24-1H/assets/90602694/d53b0542-6f9d-4c48-89da-c3d408f530d7) |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-07
| (1) 과제명 | Once : 카드 다보유자를 위한 결제 전 최대 할인 카드를 추천해 주는 AI 챗봇 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 07-루스 |
| (3) 팀원 역할 분담 | 유지민(2171031) : 팀원, Flutter 프론트엔드, Spring Boot 백엔드, 크롤링, Figma 디자인, 위치 기반 푸시 알림 구현<br>이해원(2171040) : 리더, Flutter 프론트엔드, Spring Boot 백엔드, 크롤링, Figma 디자인, 인공지능 모델 개발<br>허채린(2171052) : 팀원, Spring Boot, AWS 백엔드, 크롤링, 인공지능 모델 개발, 위치 기반 푸시 알림 구현 |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 김동수 / 엘핀 / CTO |
| (6) 과제 키워드(keywords) | 카드, 최대 할인, 챗봇 |
| (7) 과제 내용 요약 | ‘원스’는 사용자가 보유한 여러 장의 카드 중, 결제처에서 최대 할인을 받을 수 있는 카드를 추천해 주는 핀테크 서비스입니다.<br>좋은 혜택을 가진 카드를 발급받는 것도 중요하지만, 더 중요한 것은 발급받은 카드의 혜택 조건을 꼼꼼히 챙기는 것입니다.<br>결제 전 어떤 카드를 쓰는 것이 좋을지 고민된다면, 원스 챗봇에게 먼저 물어보세요. <br>보유 중인 카드의 최신 혜택을 분석하여, 해당 결제처에서 최대 할인을 받을 수 있는 카드를 추천해 드립니다. |
| (8-1) 과제: 문제의 정의 | 우리나라 1인당 신용카드 보유 수는 평균 4.4장에 달하지만, 이중 1373만장은 1년 동안 사용되지 않는 휴면카드이다. <br>카드 발급량은 매년 늘어나지만, 실제 사용으로 이어지지 못하는 이유는 무엇일까?<br>이는 소비자들이 다수의 카드를 보유하고 있지만, 모든 카드의 혜택을 충분히 파악하고 적절히 활용하는 데 어려움을 겪고 있음을 의미한다.<br>수많은 금융상품이 쏟아지고 변화하는 상황 속에서, 소비자들은 자신이 보유한 모든 카드의 혜택 정보를 파악하기 어렵다. <br>'Once'는 사용자가 보유한 카드 중 특정 결제처에서 최대 할인을 받을 수 있는 카드를 추천함으로써, 소비자가 모든 카드의 혜택을 최대한 손쉽게 활용할 수 있는 솔루션을 제공한다. |
| (8-2) 과제: 기존연구와의 비교 | 원스가 정의한 문제를 풀기 위해 비슷한 해결책을 제시한 서비스는 크게 **토스, 카드 고릴라, 뱅크샐러드**가 있다.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;1. **토스** : 카드 발급 추천 서비스는 사용자가 새로운 카드를 발급받기 전, 소비 유형과 신용 정보를 바탕으로 가장 유리한 혜택을 가진 카드를 추천한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 강점 : 유리한 혜택을 가진 카드를 개인에게 맞게 자동 추천해 준다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 약점 : 카드를 발급받지 않으면 그 혜택을 온전히 누리기 어렵다.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;2. **카드 고릴라** : 소비자가 원하는 혜택 유형과 분야에 따라 신용카드를 찾아주는 서비스를 제공한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 강점: 원하는 혜택 분야를 여러 개 선택할 수 있고, 전월 실적을 입력하면 이를 고려해 추천해준다는 점에서 소비자가 자신에게 최적화된 카드를 찾기 편리하다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 약점: 전체 카드 상품 중에서 추천하는 서비스로, 해당 카드를 만들지 않으면 혜택을 받기 어렵다. 카드 상품 자체의 혜택 이외에 카드사별 단기 이벤트, 실제 자신의 전월 실적, 포인트 활용을 고려하지 못한다.<br><br>&nbsp;&nbsp;&nbsp;&nbsp;3. **뱅크샐러드** : 소비자가 입력한 카드 종류, 카드사, 월 지출액 및 원하는 브랜드를 기반으로 카드를 추천해 준다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 강점: 사용자가 원하는 업종별 카테고리를 세부적으로 입력할 수 있도록 하여, 보다 맞춤화된 카드 추천 서비스를 제공한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;- 약점: 사용자가 직접 자신의 정보를 입력해야 한다는 점에서 번거롭고 접근성이 낮다. 또한 발급받을 카드에 집중되어 있어, 소지 카드 중 사용할 카드를 고르는 데에는 적합하지 않다.<br><br>위 세 개의 경쟁 서비스 모두 사용자가 어떤 카드를 발급받으면 좋을지 추천해 주는 "**카드 발급 전 추천**"에 초점이 맞춰져 있다.<br>반면 원스는 사용자가 이미 보유한 카드의 혜택을 최대한 활용할 수 있도록 돕는 "**카드 발급 후 사용 추천**"에 중점을 둔다. <br>즉 발급받으면 좋은 카드를 추천해 주는 일회성 서비스가 아닌, 이미 사용자가 **보유한 카드를 더 효과적으로 활용하는 방법을 지속해서 추천**해 준다는 점에서 가장 큰 차별점이 있다. <br><br>앞서 언급한 3개의 경쟁 서비스와 원스의 포지셔닝 맵은 다음과 같다. <p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/592a4120-d9c3-4e94-8f9e-db39e90301bc" width="500"/></p>|
| (8-3) 과제: 제안 내용 | 원스는 40-50대 카드 다보유자 및 20대 짠테크족을 타겟으로 하여 사용자가 보유한 카드 중 결제처에서 최대 할인을 받을 수 있는 카드를 추천함으로써, 모든 카드의 혜택을 손쉽게 활용할 수 있도록 돕는다.<br><br>이를 위해 주 1회 카드 혜택 크롤링 및 일 1회 이벤트성 혜택 크롤링을 진행하여 사용자에게 보다 정확한 최신 혜택 정보를 제공한다. 본질적으로는 카드사와 소비자 간의 정보 비대칭 문제 해결에 기여하고자 한다.<br><br>또한, Beacon 및 GPS 기술을 이용하여, 단골 매장 근처에서 최대 할인을 받을 수 있는 카드를 미리 알려주는 푸시 알림 서비스를 제공한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. [주요 서비스] 결제 카드 추천<br>&nbsp;&nbsp;&nbsp;&nbsp;- 결제 전 최대 할인을 받을 수 있는 카드를 추천한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 보유 카드를 기반으로 하여 개인 맞춤형 카드 추천 서비스를 제공한다.<br>2. [주요 서비스] GPS 기반 푸시 알림<br>&nbsp;&nbsp;&nbsp;&nbsp;- 단골 매장 근처에서 결제 카드를 미리 추천해 주는 푸시 알림을 전송한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 앱에 접속하지 않아도 되는 높은 사용성을 제공한다.<br>3. [주요 서비스] 마이 월렛 <br>&nbsp;&nbsp;&nbsp;&nbsp;- 주 1회 주기적인 크롤링을 통해 보유 카드의 모든 최신 혜택 정보를 제공한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 카드 실적 관리를 간편하게 제공한다.<br>4. [부가 서비스] 월별 혜택 조회<br>&nbsp;&nbsp;&nbsp;&nbsp;- 월별 목표 금액을 설정하고 달성 여부를 손쉽게 확인할 수 있다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 카테고리별로 받은 구체적인 할인 혜택 금액을 제공한다.<br>5. [부가 서비스] 원스와의 대화<br>&nbsp;&nbsp;&nbsp;&nbsp;- 과거 검색 키워드와 카드 추천 내역을 한눈에 제공한다.<br>6. [부가 서비스] 주카드 관리<br>&nbsp;&nbsp;&nbsp;&nbsp;- 주카드 등록을 통해 카드 실적 우선 관리 기능을 제공한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- CODEF API를 이용한 안전한 카드 관리 서비스이다. |
| (8-5) 과제: 구현 방법 |- 필요 기술 1 : 스크래핑 기반 금융 API를 이용한 사용자 카드 정보 조회 (*스크래핑 : 각 카드사와 통신하여 실제 데이터를 제공)<br>&nbsp;&nbsp;&nbsp;&nbsp;→ `CODEF API` 를 이용하여 사용자 보유 카드 목록, 실적 충족 여부, 카드 승인 내역을 조회한다.<br><br>- 필요 기술 2 : 주 1회 6개 카드사 혜택 정보 수집 및 일 1회 6개 카드사 이벤트성 혜택 실시간 크롤링<br>&nbsp;&nbsp;&nbsp;&nbsp;→ 파이썬 크롤링 라이브러리 `BeautifulSoup`, `Selenium`, `Requests` 를 이용하여 카드별 최신 상세 혜택 정보를 수집한다.<br><br>- 필요 기술 3 : 프롬프트 엔지니어링을 이용한 카드 혜택 요약 및 파인튜닝 된 `GPT-3.5 Turbo`를 활용한 사용처에서 최대 할인을 제공하는 카드 추천<br>&nbsp;&nbsp;&nbsp;&nbsp;→ 프롬프트 엔지니어링을 통해 크롤링한 카드 혜택 정보를 요약하여 정형화하고, 파인튜닝 된 모델에 결제처, 결제 금액, 혜택 요약 정보를 input으로 넣어 보유 카드 중 최고의 할인을 제공하는 카드를 추천한다.<br><br>- 필요 기술 4 : GPS를 이용한 Geofencing 및 Beacon 기술을 이용하여 사용자 위치 추적<br>&nbsp;&nbsp;&nbsp;&nbsp;→ 위치 정보를 추적하여 사용자의 현재 위치가 단골 매장 근처인지 확인 후, 최대 할인 카드를 미리 알려주는 알림 서비스를 제공한다. |
| (8-6) 과제: 세부 기술 | <p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/d401261d-f2b4-431b-9a00-171b025ed954" width="400"/></p> 카드 추천 AI 모델을 위한 세부 기술 프로세스는 크게 **1) 카드 혜택 요약** 및 **2) 카드 추천** 프로세스로 이루어진다.<br> 1) 카드 혜택 요약 <br>&nbsp;&nbsp;&nbsp;&nbsp;1-1) `GPT-3.5 Turbo`를 이용하여 크롤링한 카드 혜택 정보를 요약하여 정형화한다. <br>&nbsp;&nbsp;&nbsp;&nbsp;1-2) 토큰 수가 부족하거나 출력 형식이 잘못된 경우, `GPT-4-Turbo-Preview`를 이용하여 혜택 요약을 다시 진행한다.<br><br>2) 카드 추천<br>&nbsp;&nbsp;&nbsp;&nbsp;2-1) 결제처, 결제 금액, 사용자 보유 카드 정보를 활용하여 카드 추천 프롬프트를 작성한다. <br>&nbsp;&nbsp;&nbsp;&nbsp;2-2) 파인튜닝된 `GPT-3.5 Turbo`에 요청을 보내 보유 카드 중 최대 할인을 제공하는 카드 추천 결과를 응답받는다.|
| (8-7) 과제: 기대 효과 및 의의 | 먼저 카드 혜택을 적절히 활용하는 데 어려움을 겪던 소비자들이, 보유한 카드의 혜택 서비스를 적극적으로 이용하도록 장려함으로써, 휴면카드 활성화에 도움이 될 것으로 기대된다.<br><br>사용자는 카드 결제 전, 보유한 카드 중 결제처에서 최대 할인을 받을 수 있는 카드를 추천받을 수 있다. 또한, 보유한 카드의 매달 실적, 혜택, 포인트 정보를 시각적으로 한눈에 보여주어, 손쉬운 카드 관리 서비스를 제공한다. 이때 주기적인 크롤링으로 최신 혜택 정보 업데이트를 제공하여 사용자는 보유 카드의 모든 최신 혜택 정보를 손쉽게 파악하고 관리할 수 있다. 이는 금융 분야에서 소비자와 카드사 간 정보 비대칭 문제 해결에 기여할 것으로 보인다.|
| (9) 데모 내용 | 1. 편의점을 자주 이용하는 '원스' 계정으로 로그인한다. <br>&nbsp;&nbsp;&nbsp;&nbsp;1-1. 마이월렛 페이지에서 보유 중인 카드 목록, 최신 카드 혜택 정보 및 실적 현황을 보여준다. <br>&nbsp;&nbsp;&nbsp;&nbsp;1-2. 결제처 후보 키워드 중 'CU' 선택 및 결제 금액을 입력한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;1-3. CU에서 최대 할인을 제공하는 카드 추천 결과를 확인한다. <br><br>2. 카페를 자주 이용하는 '라떼' 계정으로 로그인한다. <br>&nbsp;&nbsp;&nbsp;&nbsp;2-1. 결제처로 '카페' 타이핑 및 결제 금액을 입력한다. <br>&nbsp;&nbsp;&nbsp;&nbsp;2-2. 카페에서 최대 할인을 제공하는 카드 추천 결과를 확인한다. <br><br> 두 가지 데모 시나리오를 통해 **사용자 맞춤형 카드 추천 서비스**를 제공하는 원스의 주요 기능을 보여준다.|
| (10) 기타 | [SW Architecture] <p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/fc11431a-7c75-4d13-b2e5-f8c546397b03" width="600"/></p> <br> [프론트엔드 실제 애플리케이션 화면] <p align="center"><img src="https://github.com/ekhyoo/CapstoneDesign-24-1H/assets/94354545/69c48e11-e393-491e-a3fa-fc42444c8e31" width="600"/></p>|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-08
| (1) 과제명 | Learning Mate : 실시간 집중도 분석과 동기 부여 시스템을 통한  자기 주도 학습 증진 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 08-ECST |
| (3) 팀원 역할 분담 | 이희원(2171087): 리더, 백엔드 서버 프로그래밍, 프론트엔드(UI/UX 프로그래밍) 보조<br>이하나(2171089) : 팀원, 프론드 엔드(UI/UX 프로그래밍)<br>김지윤(2171085) : 팀원, AI프로그래밍, 프론트엔드(UI/UX 프로그래밍) 보조 |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 이한솔 / 노서치 / CTO |
| (6) 과제 키워드(keywords) | 자기주도적 학습, 집중도 감지, 실시간 영상 처리 |
| (7) 과제 내용 요약 | 자기 주도 학습 능력을 극대화하기 위해 실시간 웹캠 영상 분석으로 공부시간, 집중도의 체계적 기록, 집중도 경쟁과 상금으로 동기를 부여, 스터디 벌금 시스템으로 책임감을 강화를 통해 학습효율 증진을 위한 서비스를 만들고자 합니다. |
| (8-1) 과제: 문제의 정의 | <br>온라인 교육 디바이스의 다양성과 기술의 발전으로 온라인 교육 콘텐츠가 지속적으로 확장되고 있습니다. 특히 코로나 팬데믹 이후 웹 기반의 비대면 교육 서비스가 빠르게 확대되고 있는 추세입니다. 이러한 변화로 자연스럽게 자기 주도적 학습의 중요성이 부각되고 있습니다. 그러나, 비대면 수업은 대면 수업과 달리 현장감과 긴장감의 부족으로 학습자들의 집중도가 낮아지는 경향이 있습니다. 지금까지 교사의 지도 아래에서 학습해온 학습자들은 이러한 새로운 학습 환경에 적응하기 어려워하며, 자기 주도적 학습 능력이 부족한 경우도 많습니다. 이로 인해 학습 성적의 격차가 발생하고 있습니다. 이러한 문제를 해결하기 위해 Learning Mate를 고안했습니다.<br>각자 자신의 학습 능력과 선호도에 따라 대면 수업 보다는 비대면 수업을 선호하는 경향이 증가하는 현 상황에서 Learning Mate는 개인의 학습 방식을 파악하고 개선을 통해 효율적인 학습을 촉진할 것으로 기대됩니다. |
| (8-2) 과제: 기존연구와의 비교 | 기존에 자기주도학습에 활용할 수 있는 서비스는 많습니다. 하지만 학습 의지를 주는 서비스는 보지 못했습니다. 더 많은 사람들이 스스로 공부할 수 있도록 경쟁 심리를 이용하는 것이 좋다고 생각했습니다. 초기에는 친구들끼리 소액의 참가비를 지불하고, 가장 공부 집중도가 높은, 효율이 좋은 사람 순위를 매겨 상금을 지급하도록 합니다. 이후 학교 대항전을 통해 가장 집중도가 높은 학교를 대상으로 이벤트 진행을 계획중입니다. '열품타' 애플리케이션을 많이 사용하고 있지만, 공부 의욕이 있는 사람들이 많이 사용하고 있습니다. 하지만 저희는 공부를 열심히 하는 사람들만을 타겟으로 삼지 않고 공부를 하고자 하는 모든 사람들을 타켓으로 모두가 공부를 할 수 있는 서비스를 만들고자 합니다. 공부 중에 웹캠으로 집중도를 분석해 본인이 얼마나 집중하고 있는지 수치화할 수 있고, 이 수치를 통해 반성하고 더 집중할 수 있습니다. |
| (8-3) 과제: 제안 내용 | 집중도 향상과 학습 효율 증진을 위한 전략으로 크게 (1) 집중도 분석, (2) 집중도 대결 을 제안합니다.<br>'집중도 분석'의 경우, 학습자의 학습 메타인지를 키울 수 있게 할 것입니다. 얼마나 집중했느냐는 학습에 중요한 요소인데, 이러한 부분은 객관적인 지표로 확인하기 어렵다는 문제가 있습니다. 저희가 제안하는 과제는 이런 부분을 충족 시켜줄 것이며, 학습자는 본인이 학습에 얼마나 집중하고 있는 지 확인할 수 있을 것입니다. 이러한 기능은 물리적으로 오랜 시간 공부해도 그만큼의 효율이 나지 않는 사람들에게 도움을 줄 수 있을 것입니다.<br>'집중도 대결'의 경우, 학습자 경쟁심리를 자극해 학습 효율을 증진할 수 있게 할 것입니다. 학교 대항전처럼 일정 기간을 두고 집중도 대결 및 순위권 학습자에게 상금을 지급한다면, 학습자에게는 공부를 해야하는 동기가 생길 것입니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 실시간 영상 데이터 활용을 통한 집중도 분석 기능<br>2. To do List 별 공부 시간 + 집중도 기록<br>3. 졸음 감지 및 알림 시스템<br>4. 집중도 대결 및 순위권 상금 지급 (ex. 학교 대항전)<br>5. 학술 동아리 및 스터디 벌금 관리 기능 |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-09
| (1) 과제명 | AI 기반 교내 스마트 중고거래 플랫폼
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 09-강철몽둥이 |
| (3) 팀원 역할 분담 | 김해인(1771017): 리더, 개발, 백엔드<br>조주연(2076392): 팀원, 기획, 프론트엔드<br>최혜민(1876431): 팀원, 디자인, 백엔드 |
| (4) 팀 지도교수 | 반효경 |
| (5) 팀 멘토 | 최철호 / 온새하 / 대표 |
| (6) 과제 키워드(keywords) | 중고거래,대학생,시간표매칭 |
| (7) 과제 내용 요약 | 캠플'은 대학교 내 중고 거래를 위한 AI 기반 플랫폼으로, 사용자의 수업 시간표를 기반으로 한 거래 시간/장소 매칭과 적정가 자동산출 기능을 제공합니다. 이를 통해 거래의 편의성과 신뢰도를 높이며, 학교 커뮤니티 기능을 통해 사용자 간 소통과 거래의 안전성을 강화합니다. '캠플'은 교내 중고 거래의 활성화와 사용자 만족도 향상을 목표로 합니다. |
| (8-1) 과제: 문제의 정의 | 현재 대학생들 사이에서 중고 거래는 흔하지만, 거래 장소와 시간 조율의 어려움, 물품의 적정 가격 파악의 어려움, 그리고 거래의 신뢰도 문제가 주요한 장애물로 남아있습니다. 이러한 문제들은 거래자 간의 신뢰를 저하시키고, 중고 거래의 활성화를 방해합니다. |
| (8-2) 과제: 기존연구와의 비교 | 다른 연구나 프로젝트에서는 중고 거래 플랫폼에 사용자 평가 시스템을 도입하거나, 공공장소에서의 안전한 거래를 위한 '안전거래소'를 설치하는 방법을 제안했습니다. 또한, AI 기반 가격 추천 시스템을 통해 물품의 적정 가격을 제시하는 방법도 있습니다.<br><br>장점 / 단점 비교<br>사용자 평가 시스템: 거래 후 사용자 간 평가를 통해 신뢰도를 제고할 수 있으나, 초기 사용자 확보가 어렵고, 부정적인 평가로 인한 분쟁이 발생할 수 있습니다.<br>안전거래소: 실제로 안전한 거래를 보장할 수 있으나, 고정된 장소에 의존해야 하며, 모든 사용자에게 접근성이 좋은 위치를 확보하는 것이 어렵습니다.<br>AI 기반 가격 추천 시스템: 물품의 적정 가격을 쉽게 파악할 수 있으나, 시장 변동이나 특수한 물품의 경우 정확도가 떨어질 수 있습니다. |
| (8-3) 과제: 제안 내용 | 캠플'은 교내 중고거래의 특수성을 고려하여 개발된 플랫폼으로, 다음과 같은 해결책을 제안합니다.<br><br>시간표 매칭/스케쥴링 시스템을 통해 거래 장소와 시간 조율의 편의성을 대폭 향상시키며, 교내에서의 거래이기 때문에 신뢰도도 높습니다.<br><br>자체 제작한 품질 등급 시스템과 거래 이력 데이터를 기반으로 중고 물품의 적정 가격을 자동으로 산출해 사용자가 합리적인 가격에 거래할 수 있도록 돕고, 시장의 활성화를 촉진합니다 |
| (8-4) 과제: 과제의 주요 기능 | 1.교내 중고거래 플랫폼<br>2.거래장소/시간 자동 스케쥴링 기능<br>사용자의 수업 시간표를 기반으로 거래자와 판매자가 공강 시간에 만날 수 있는 최적의 시간과 장소를 자동으로 추천합니다. 이는 거래 장소와 시간 조율의 편의성을 대폭 향상시키며, 교내에서의 거래이기 때문에 신뢰도도 높습니다.<br>3.중고물품 적정가 추천 알고리즘<br>자체 제작한 품질 등급 시스템과 거래 이력 데이터를 기반으로 중고 물품의 적정 가격을 자동으로 산출합니다. 이는 사용자가 합리적인 가격에 거래할 수 있도록 돕고, 시장의 활성화를 촉진합니다. |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-10
| (1) 과제명 | 잇터뷰(iterview) : IT 취준생을 위한 CS 기술 구두 면접 대비 & 학습 플랫폼
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 10-Qt |
| (3) 팀원 역할 분담 | 이서진(2176258):	팀장, 프론트엔드 개발, UI 디자인<br>임채영(2176316): 백엔드 개발, GPT 튜닝, 채점 알고리즘 설계<br>이채원(2168022): 인공지능 모델 개발, STT, TTS, 표정 분석, 모델 서버 구축 |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 맹수연 / SAP / 개발자 |
| (6) 과제 키워드(keywords) | 기술 면접, 종합적 평가와 첨삭, 반복 학습 |
| (7) 과제 내용 요약 | iterview는 IT 분야에서의 기술 구두 면접 대비 및 학습을 위한 플랫폼으로, 사용자는 맞춤형 면접을 선택할 수 있어 효율적인 학습이 가능합니다. 비언어적 특성 분석을 포함한 객관적인 점수와 첨삭을 제공하며, 면접 기록과 피드백을 아카이빙하여 성장을 추적할 수 있습니다. 이를 통해 사용자는 자신의 지식 수준과 부족한 부분을 파악하여 개선할 수 있습니다. |
| (8-1) 과제: 문제의 정의 | 첫째로, 기술 분야의 면접은 특정 기술에 대한 이해와 능력을 검증하는 과정인 만큼, 기술적인 질문에 대한 실제 경험적인 연습이 필요합니다. 그러나 기존의 면접 연습 플랫폼은 주로 인성 면접 질문에 중점을 두어 왔기 때문에, 기술적인 측면에 대한 충분한 대비가 이루어지지 않았습니다.<br><br>둘째로, 수치화된 면접 결과를 얻을 수 없다는 한계가 있습니다. 이는 면접 성과를 객관적으로 평가하고 개선할 수 있는 중요한 요소입니다. 기술적인 면접에서는 정확한 기술적 지식과 능력을 확인하기 위해 객관적인 평가가 필요한데, 기존 플랫폼은 이를 충분히 제공하지 못하고 있습니다.<br><br>그렇기 때문에 이러한 한계를 극복하기 위해 기술 분야의 면접 연습 플랫폼이 필요합니다. 이를 통해 사용자들은 실제 기술적인 질문에 대한 대비가 가능하며, 수치화된 결과를 통해 자신의 역량을 정확히 파악할 수 있습니다. 이는 취업 준비자들에게 실질적인 도움을 줄 수 있을 것입니다. |
| (8-2) 과제: 기존연구와의 비교 | 1. pramp 이라는 It 개발자를 위한 기술 면접 연습 플랫폼이 있음. code 위주의 기술 면접 플랫폼으로, 사용자끼리서로 면접자와 면접관 역할을 돌아가면서 연습을 할 수 있음. 이 경우에 code 등 볼 수 있는 자료들이 제시된다는 장점이 있지만, 혼자 연습할 수 없다는 단점이 있음. 또한 채점 결과나 면접자에 대한 비언어적 표현이나 평가를 받을 수 없다는 단점이 있음. <br><br>2. 사람인 Ai 면접 코칭이라는 서비스가 있음. 이는 chatGPT 기반 면접 질문 제시 및 답변 첨삭 플랫폼으로 면접 질문을 자동으로 생성하여 제공한다는 장점이 있음. 그러나 면접 피드백의 경우 구체적인 수치나 비언어적 표현에 대한 평가를 주지 않아 모호하다는 단점이 있음. |
| (8-3) 과제: 제안 내용 | 1. 사용자가 자신이 원하는 과목을 선택하여 진행하는 맞춤형 면접으로 높은 효율성 제공<br>2. 면접 중 사용자의 표정, 말 더듬는 시간, 응답 지연 시간 등 다양한 비언어적 특성을 분석하여 제공<br>3. 사용자의 면접 기록과 피드백 결과를 아카이빙, 재학습하며 성장과정 트래킹 가능<br>이 세가지 아이디어를 통해 사용자는 “내가 무엇을 알고 무엇을 모르는지를 아는” 메타인지 학습이<br>가능하게 되어 자신의 부족한 지식이 무엇인지 인지할 수 있을 것으로 기대함 |
| (8-4) 과제: 과제의 주요 기능 | 1. 과목 선택 기능: 사용자는 자신이 원하는 컴퓨터 과학 분야의 특정 주제나 기술에 대한 면접을 선택할 수 있습니다. 이를 통해 사용자는 자신의 관심 분야나 역량을 중점적으로 향상시킬 수 있습니다.<br>2. 면접 채점 및 수치화: iterview는 사용자의 면접을 종합적으로 평가하고, 비언어적인 특성뿐만 아니라 답변의 정확도도 평가합니다. 이를 통해 사용자에게 객관적인 수치화된 평가 결과를 제공합니다. 이는 사용자가 자신의 역량을 정확하게 파악하고 개선할 수 있는 기반을 마련해줍니다.<br>3. 면접 오답 노트 기능: 사용자는 자신의 면접 기록과 피드백 결과를 아카이빙할 수 있습니다. 이를 통해 사용자는 자신의 성장 과정을 추적하고, 부족한 부분을 식별하여 재학습할 수 있습니다. 이는 사용자가 지속적인 학습과 성장을 위한 피드백을 제공합니다.<br>4. ChatGPT API 연동: 사용자의 답변을 채점하고 피드백을 생성하기 위해 ChatGPT를 활용합니다. 이를 통해 사용자는 실제 면접과 유사한 상황에서 자신의 답변을 평가받을 수 있습니다.<br>5. 음성 분석 및 STT 기술: 면접 음성을 텍스트로 변환하기 위해 음성 분석 및 STT(Speech-to-Text) 기술을 사용합니다. 이를 통해 사용자는 면접 응답을 텍스트로 확인하고 분석할 수 있습니다.<br>6. 표정 감정 인식 FER 기술: 면접 영상에서 표정을 감지하고 감정을 분석하기 위해 FER(Facial Expression Recognition) 기술을 사용합니다. 이를 통해 면접자는 자신의 표정에 대한 피드백을 받아 개선할 수 있습니다.<br><br>이러한 기능들을 통해 "iterview"는 사용자가 자신의 기술 면접에 대비하고 향상시킬 수 있는 유용한 도구로 작용합니다. |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-11
| (1) 과제명 | 망하지망고 : 망고 초보 재배자를 위한 이미지 객체 검출 및 분류 기반 농작물 질병 식별 앱 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 11-로캣단 |
| (3) 팀원 역할 분담 | 박서연(2144010): 팀장, UI 디자인, React Native 프런트엔드 개발, 애플리케이션 배포<br>정유진(2062084): 팀원, Spring Boot 백엔드 개발, AWS 관리, 인공지능 개발<br>조하은(2144026): 팀원, Spring Boot 백엔드 개발, AWS 관리, 인공지능 개발<br>최윤지(2171050): 팀원, UI 디자인, React Native 프런트엔드 개발, 애플리케이션 배포 |
| (4) 팀 지도교수 | 반효경 |
| (5) 팀 멘토 | 박재현/프리랜서/개발자 |
| (6) 과제 키워드(keywords) | 망고, 질병, 대처 |
| (7) 과제 내용 요약 | 저희 팀의 주제는 “고소득 작물인 망고의 잎 사진 분석을 통해 망고의 질병을 식별하여 망고 초보 재배자들이 망고의 질병에 빠르게 대처할 수 있도록 도와주는 모바일 앱 서비스”입니다. 망고 재배 관련 정보를 쉽게 얻지 못하는 재배자들이 잎 사진을 찍어 올리기만 하면 망고의 질병 식별 및 질병에 따른 대처 방법 정보를 신속하게 알려주어 실패 없는 망고 재배 경험을 제공하고자 합니다. |
| (8-1) 과제: 문제의 정의 | [재배가 까다로운 작물, 망고]<br>망고는 매년 꾸준히 재배면적이 늘고 있지만 아직 재배 기술이 보편화되지 않아 재배 농가의 망고 재배 성공률은 비교적 낮은 편입니다. 반드시 유지해야 할 재배 조건을 지키지 않을 경우 열매가 열리지 않거나 열매가 열리더라도 품질이 좋지 않아 실질적으로 소득으로 이루어지지 않습니다.<br><br>[망고 병해충 관리 정보, 여러 사이트에 흩어져 있고 개인의 상황에 적용하기 어려움]<br>현재 여러 사이트 및 유튜브, 블로그 등에서 망고 재배 관련 정보를 제공하고 있습니다. 그러나 망고의 질병 진단 및 대처 방법에 대한 정확한 정보를 제공하는 것은 국가농작물병해충관리시스템 뿐이고, 이 마저도 일방적인 정보 제공이기 때문에 재배자 개인의 망고 재배 상황에 맞는 대처 방법을 알기는 어렵습니다.<br><br>[국가농작물병해충관리시스템의 병해충상담, 24시간 소요]<br>국가 농작물병해충관리시스템(NCPMS)에서 농업종사자 개인 재배 상황에 맞추어 농촌진흥청의 분야별 전문가가 병해충 관련 상담을 제공하나, 이는 6단계 [로그인-사진 촬영-상담내용 작성-상담신청 접수-전문가 답변 작성-답변 확인] 로 이루어지며 이는 평균 24시간이 소요됩니다.<br><br>위와 같은 이유로, 망고 질병에 대해 빠르게 알고, 대처 방법에 대한 정보 및 망고 재배 관련 정보를 한꺼번에 신속하게 제공하는 서비스가 필요합니다. |
| (8-2) 과제: 기존연구와의 비교 | 대표적인 해외 식물 직별 식별 앱 서비스인 [Agrio - Plant health app]와의 비교를 진행해보겠습니다. Agrio는 재배자와 작물 조언자가 식물 질병, 해충 및 영양 결핍을 예측, 식별 및 치료할 수 있도록 돕는 정밀 식물 보호 솔루션입니다. 인공 지능과 컴퓨터 비전 알고리즘을 활용하여 농작물 관리 및 식물 질병 식별을 돕는 서비스입니다.<br><br>[Agrio]는 [망하지망고]와 비교했을 때, 더욱 높은 수준의 기술력을 구현함으로써 재배자들의 식물 재배 및 총체적인 관리에 도움을 주고 있습니다. 그러나 구독 서비스가 아닌 무료 버전을 사용하면 질병 식별의 정확도가 낮아지고, 현재 영문 서비스만 제공한다는 점이 한계로 작용합니다. |
| (8-3) 과제: 제안 내용 | 망고 잎의 질병 여부를 파악하기 위해 이미지 객체 인식 및 분류 딥러닝 모델을 사용하였습니다. YOLOv5를 사용하여 망고 잎과 병변부위 이미지 객체를 추출하고, resnet50을 사용하여 해당 잎에 대한 정상/질병 여부와 어떤 질병인지 판단합니다. React Native 프레임워크와 Spring 프레임워크를 활용하여 각각 프런트엔드와 백엔드를 분리하여 모바일 어플의 화면과 서버를 개발합니다. 누구나 다운받아 사용할 수 있는 어플이므로 AWS EC2(Ubuntu 22.04)와 RDS(MySQL)를 사용하여 클라우드 서비스에서 서버를 구축하여 많은 사용자들이 사용할 수 있도록 합니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 망고 질병 검사를 통한 망고 질병 정보 및 질병에 따른 대처 방법 정보 제공<br>2. 망고 재배 관련 정보(팁)들을 모아서 제공 |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-12
| (1) 과제명 | 어린이를 위한 비주얼 프로그래밍 기반 코딩 학습 모바일 게임: 메르헨 코더
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 12-팀팀탱탱후라이팬 |
| (3) 팀원 역할 분담 | 김미진(1976046):  리더, 기획, 그래픽 소스 제작, 노드 개발, 챕터 2 담당<br>김지우(2026007): 팀원, 기획, 노드 개발, 플레이어 이동, 대화 시스템(다이얼로그) 구현, 챕터 시스템 구현, 꾸미기 모드, 로컬 저장<br>이도현(1876263): 팀원, 기획, 노드 개발, UI/UX, 노드 실행과 채점 시스템 구현, 로컬 저장, 백엔드 서버 프로그래밍, DB |
| (4) 팀 지도교수 | 김명 교수님 |
| (5) 팀 멘토 | 이정현 / 주식회사 젬팩 / 대표이사 |
| (6) 과제 키워드(keywords) | 어린이코딩교육, 비주얼프로그래밍, 모바일게임 |
| (7) 과제 내용 요약 | 코딩 교육의 중요성은 나날이 증가하고 있지만 기존 코딩 학습 서비스는 플랫폼 한계, 한정적인 학습 방법, 높은 진입장벽 등의 문제점이 있다. 우리 팀은 그러한 문제점을 해결하기 위해 초등학교 고학년을 타겟으로 한 새로운 코딩 교육 모바일 게임, 메르헨 코더를 제작한다. 메르헨 코더는 동화 세계를 배경으로 하여 문제 상황을 코딩을 통해 해결한다는 컨셉의 게임이다. 유니티와 C# 스크립트를 활용하여 직접 개발한 비주얼 프로그래밍 도구를 제공하여 이용자가 코딩의 기본적인 구조와 컴퓨팅 사고력을 기를 수 있을 것을 기대한다. |
| (8-1) 과제: 문제의 정의 | 1. 플랫폼의 한계: <br>- 대부분의 코딩 학습 플랫폼은 PC나 자사 학습 패드를 이용해 코딩 교육을 진행<br>- 자사 학습패드는 패드가 없는 경우 접근성에 문제가 생기며, PC의 경우에는 간단히 즐기거나 학습하기 어렵다<br><br>2. 한정적인 학습 방법<br>- 대부분의 어린이용 코딩 학습은 한정적인 문제들로만 이루어져 있어 종종 일정한 방식으로만 문제를 해결하도록 유도한다. 알고리즘 시티, 구글 코딩 토끼 게임과 같은 미로 게임이 대표적인 예이다.<br>- 2024년에 사용될 예정인 중학교 소프트웨어 교과서 15종 가운데 14종이 '엔트리' 프로그램을, 1종이 '스크래치' 프로그램을 활용했다고 한다. 엔트리와 스크래치가 에듀 테크 시장을 점유하고 있기에 학습의 다양성이 부족하다. <br><br>3. 학습 플랫폼의 높은 진입장벽<br>- 플랫폼의 학습 가이드라인이 불친절하여 학습 능력이 부족한 어린이에게 진입장벽이 높다. 학업 성취도가 낮은 어린이도 쉽게 배우고 학습할 수 있는 플랫폼 혹은 콘텐츠가 필요하다. |
| (8-2) 과제: 기존연구와의 비교 | - 차근차근 게임코딩(서비스): 게임 기기와 게임 구매비용이 발생한다. 특정 기기에 최적화된 개발 방식이라 다른 코딩을 할 때 응용하기 어렵다. 코딩의 기능을 구현해놓기보다는 게임의 기능들을 구현하여 코딩을 배우기보다는 게임을 어떻게 만드는지에 초점을 맞추었다<br>- 스크래치 : 다양한 기능을 구현할 수 있지만, 학습 가이드라인의 미비함으로 초보자들이 아무것도 모르고 접근하기에 접근성이 좋지 않다.<br>- 어린이용 학습 패드로 배우는 코딩: 고가의 학습 패드를 구매해야 하고 블록 코딩 위주의 단순한 시스템만이 갖추어져 있다. 고급 프로그래밍 언어와 간극이 크다. (예시) 뽀로로 한글 코딩 패드, 콩순이 코딩 컴퓨터<br>- 알고리즘 시티, 구글 코딩 토끼 게임 : 한정적인 학습 내용만을 가르친다는 문제가 있다. 특히 길찾기 문제만을 주로 활용해서 다양한 응용 문제에 적용할 수 없다는 치명적인 단점이 있다.<br>- 유니티 노드: 코딩을 배운 사람도 아무 설명 없이 접근하기엔 어렵고 불친절하다. 공식 문서도 별로 없어 혼자 배우긴 쉽지 않다. 그래서 초보자가 아무것도 모르고 접근한다는 건 거의 불가능에 가깝다. |
| (8-3) 과제: 제안 내용 | <메르헨 코더>는 기존 코딩 교육 서비스들과 비교했을 때 다음과 같은 특징 및 개선점을 갖는다.<br><br>1. 태블릿으로 구동 가능한 모바일 게임<br>안드로이드에서 구동 가능한 모바일 게임을 제작함으로써 학습용 기기를 따로 구매하는 등의 금전적인 부담을 줄이고 접근성을 높일 수 있도록 한다. <br><br>2. 비주얼 프로그래밍 도구 제공<br>쉽고 직관적인 프로그래밍 교육이 가능하다는 블록 코딩 방식 타 서비스들의 장점은 유지하되, 프로그램의 흐름과 논리 구조를 이해하는데 더 도움이 되는 새로운 비주얼 스크립팅 도구를 만들어 제공한다. 비전공자도 코드 작성 없이 배우고 활용할 수 있다는 유니티 비주얼 스크립트의 장점을 가져와 어린이 학습 플랫폼으로 만든다.<br>이를 통해 블록 코딩과 같은 하나의 코딩 도구에만 익숙해져서 제한된 컴퓨팅 사고를 갖는 것을 방지하고, 여러 도구와 여러 언어를 사용함으로써 청소년들이 다양한 컴퓨팅 사고를 펼칠 수 있도록 돕는다.<br><br>3. 스토리와 함께 진행되는 점진적 학습 제공<br>학습자가 게임을 진행하며 자연스럽게 학습의 난이도 및 범위를 높여갈 수 있도록, 문제 상황의 발생과 해결을 게임의 스토리와 밀접하게 연관시켜 배치한다. 사용자는 간단한 입출력으로 시작하여 자료형, 조건문, 반복문 등을 접하며 자연스럽게 학습의 범위를 넓히게 된다. 개념을 익힌 뒤에도 스토리의 진행과정에 유사한 문제를 배치해 복습할 수 있도록 도우고, 최종적으로는 배운 내용을 응용하여 더 복잡한 문제를 해결할 수 있도록 한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 비주얼 프로그래밍: 스토리에 맞는 문제가 제공되면 사용자는 노드를 연결하는 방식으로 프로그래밍을 진행할 수 있습니다.<br>- 시작/ 끝 : 시작 노드와 끝 노드가 있으며 노드를 실행할 때 어디서부터 실행해야 하고 어디서 끝나는지를 알려주는 역할을 합니다.<br>- 입력 노드 : 문제에서 주어지는 변수들을 사용할 수 있습니다. 코딩 테스트에서 주어지는 입력과 같은 역할을 수행합니다<br>- 자료형 : 숫자 노드 ,문자 노드, 불린 노드가 있으며 숫자 노드에서는 숫자를, 문자 노드에서는 문장을 입력할 수 있으며 불린 노드에서는 참과 거짓을 선택할 수 있습니다.<br>- 액션 노드 : 말하기 노드 등의 기능이 있으며 실행 화면에서 캐릭터가 어떻게 행동할지를 지시할 수 있습니다.<br>- 변수 노드 : 값 설정하기, 값 가져오기 노드가 있으며 변수를 만들거나 변수의 값을 가져올 수 있습니다.<br>- 산술 연산 노드 : 덧셈 노드 ,뺄셈 노드, 곱셈 노드, 나눗셈 노드, 나머지 노드가 있으며 자료형이 숫자인 노드들의 계산을 할 수 있습니다.<br>- 비교 연산 노드 : 크다, 작다, 크거나 같다. 작거나 같다, 같다, 같지않다 노드가 있으며 자료형이 숫자인 노드들을 비교할 수 있습니다.<br>- 논리 연산 노드 : 그리고, 또는, 아니다 노드가 있으며 불린 값을 비교할 수 있습니다.<br>- 제어 : 조건, 조건 반복, 횟수 반복, 탈출 노드가 있으며 조건 노드는 if문을, 조건 반복 노드는 while문을, 횟수 반복 노드는 for문의 기능을 수행합니다. 탈출 노드는 특정 조건이 됐을 때 다른 제어 노드들을 종료하는 역할을 수행합니다.<br>- 함수 : 사용자 함수 노드, 매개변수 노드, 반환 노드가 있으며 이를 통해 사용자가 자신만의 노드를 만들 수 있습니다.<br>2. 실행 및 채점: 코딩 문제 학습에 있어서, 로직의 실행과 문제의 채점을 구분하여 제공합니다. 사용자는 비주얼 스크립팅 도구를 사용해 로직을 만든 뒤, 실행 버튼을 눌러 자신의 로직이 성공적으로 작동하는지 테스트해볼 수 있습니다. 노드의 작동은 결과 패널을 통해 시각적으로 표시되어 사용자는 그 로직의 문제점을 쉽게 파악하여 로직을 수정할 수 있습니다. 모든 수정이 끝나고 채점 버튼을 누르면 해당 로직이 제대로 구현되었는지 테스트케이스를 이용해 정답 여부를 판단합니다. 사용자가 테스트케이스를 통과하지 못한 경우 다시 시도해보라는 알림을 띄웁니다.<br><br>3. 로그인: 사용자는 회원가입을 통해 아이디와 비밀번호를 만들 수 있습니다. 로그인 후 게임을 플레이하면 게임의 진행 상황과 플레이어의 정보가 서버와 연결되어 저장됩니다. 게임을 삭제 후 재설치하더라도 해당 계정으로 로그인하면 게임의 진행 상황과 플레이어의 정보를 받아올 수 있습니다.<br><br>4. 복습하기: 사용자가 푸는 데 어려움을 느꼈던 문제를 복습하고 싶거나, 이미 풀었던 문제를 다른 방식으로 풀어보고 싶을 때 이미 클리어한 문제에 한해서 문제를 다시 풀어볼 수 있는 복습하기 기능을 제공합니다.  |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-13
| (1) 과제명 | Agent.I : Generative Agent를 적용한 Human-like NPC와 상호 작용하는  사회 시뮬레이션 게임
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 13-스윗팡이크루 |
| (3) 팀원 역할 분담 | 정다소(2071043) : 팀장, Django Back-end<br>장재원(1976343) : 팀원, Unity Front-end<br>성원희(2176180) : 팀원, Back-end, Chat GPT prompt engineering |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 김도균 / 넷스트림 / CTO |
| (6) 과제 키워드(keywords) | Generative AI, Human-like NPC, 시뮬레이션 게임 |
| (7) 과제 내용 요약 | Agent.I는 기존의 일방향적인 NPC와의 소통을 뛰어넘어, Generative Agent를 활용하여 Human-like NPC와의 상호작용하는 사회 시뮬레이션 게임입니다. 플레이어는 스스로 사고하고 행동하는 NPC와 상호작용하며 '사이비 종교 확산 방지'라는 목표를 이루어내야 합니다. 이 과정에서 플레이어는 시시각각 달라지는 게임의 흐름을 통해 다양한 게임 플레이 경험과 즐거움을 느낄 수 있습니다. |
| (8-1) 과제: 문제의 정의 | 기존 게임에서 NPC는 유저에게 게임의 진행 방향을 알려주고 유저와의 소통을 통해 게임의 재미를 증진시켜주는 역할을 맡았습니다. 하지만 기존의 NPC는 고정된 선택지와 정해진 대사의 반복으로 인해 일방향적인 소통이 이루어졌고, 이로 인해 유저의 참여도와 세계관의 신뢰도가 감소하는 문제를 가지고 있었습니다. 이러한 문제점을 인식하고, 최근 생성형 AI를 NPC에 적용하는 시도가 증가하고 있습니다. 하지만 연구 결과, 인공지능 NPC 게임은 체험을 풍부하게 만들지만, 대화 기능과 시스템 간의 연결에 미흡하다는 평가를 받고 게임 시스템과 밀접하게 연관되지 않는다는 지적을 받고 있습니다.  |
| (8-2) 과제: 기존연구와의 비교 | 최근 게임 업계에서는 앞서 언급한 문제점들을 인식하고, 해결하기 위해서 AI를 이용한 챗봇을 NPC에 적용하여 유저와 대화할 수 있는 시스템을 도입하는 등 생성형 AI를 NPC에 적용하는 시도가 증가하고 있습니다. 이러한 방식으로 인공지능을 NPC에 도입한 결과, 인공지능을 도입하지 않은 게임들보다 체험을 풍부하게 만들고, 게임의 유연성과 재미를 증진시킨다는 장점이 있습니다. 하지만 현재 생성형 AI를 도입한 게임들은 게임과의 결합에서 해당 기능의 성숙도가 아직 부족하고, 대화 기능과 시스템 간의 연결이 미흡하다는 평가를 받아 사용성 평가에서 낮은 수치를 보인다는 단점을 가지고 있습니다. |
| (8-3) 과제: 제안 내용 | 기존 게임의 획일적인 상호작용에서 벗어나기 위해 NPC에 AI를 적용하여 실제 사람과 상호작용하는 듯한 경험을 제공합니다. Human-Like NPC를 제작하기 위해 연구 논문 [Generative Agents: Interactive Simulacra of Human Behavior]에서 연구한 Generative Agents의 구조를 반영합니다.  Generative Agent는 NPC들이 스스로 직접 생각하고 다음 행동을 결정하여 여러가지 새로운 이벤트를 생성한다는 점에서 정해진 패턴에 따라 움직이던 기존 게임에서의 NPC들과 다른 양상을 보여줍니다. <br><br>Generative Agent들이 게임의 승패를 결정하며 게임 시스템의 핵심을 이룹니다. 시나리오는 '종교 집회'의 목적을 가진 사이비 종교의 ‘주교 NPC’를 유저가 저지하는 내용입니다. 주교는 대화를 통해 집회를 퍼트리고 다른 NPC들은 종교 집회에 올지 안 올지 결정합니다. 유저는 NPC들과 대화하면서 퀴즈를 통해 종교 집회의 참석자 수를 낮출 수 있습니다. |
| (8-4) 과제: 과제의 주요 기능 | [능동적이고 상호 소통 가능한 NPC 제작]<br><br>1. AI 기반의 NPC 행동 결정 시스템 (Generative Agent)<br>    - 페르소나와 메모리 시스템을 가지고 스스로 행동을 결정하는 NPC 제작<br>    - 주변의 다른 NPC를 인지하고, 대화할 수 있음<br>    - 대화 내용을 메모리에 저장하고 새로운 정보를 추론할 수 있음<br>    - 스스로 장소를 이동하거나 이모지로 자신의 행동을 표현할 수 있음<br><br>2. 페르소나 기반의 AI 챗봇<br>    - 페르소나의 정보와 AI 기반으로 유저와 대화하며 예측 불가능한 양방향 소통을 제공함 |
| (8-5) 과제: 구현 방법 | 스스로 행동을 결정하는 NPC는 다음 세가지 과정으로 구성하여 구현됩니다. <br>1. Perceive : 주변의 다른 NPC를 인지하고, 대화할 수 있습니다. 주변의 NPC의 존재를 확인하고, 대화하기 적절한 상대이면 대화를 시도합니다.<br>2. Memory System : 대화 내용을 메모리에 저장하고 새로운 정보를 추론할 수 있습니다. 이를 통해 인간처럼 사고하는 과정을 모방하고 고차원적인 정보를 메모리에 저장할 수 있습니다.  <br>3. Act : 스스로 장소를 이동합니다. 이모지와 텍스트로 자신의 행동을 표현할 수 있습니다.<br>이 과정을 약 20초마다 모든 NPC에서 반복하며 자신만의 메모리 시스템을 만들어갑니다. |
| (8-6) 과제: 세부 기술 | 1. Django / AWS EC2 <br> - Unity 엔진에서 NPC가 생성하는 정보를 받아옵니다.<br> - 게임 NPC들의 페르소나 정보 및 기억을 Chat GPT3.5로 전송하여 GPT Prompt를 생성합니다. <br> - GPT Prompt로 결정된 대화 및 행동을 Unity 엔진으로 전송합니다.<br> - 유저와 NPC의 대화 정보를 실시간으로 전송하고 저장합니다. <br>2. Chat GPT 3.5<br> - Chat GPT 3.5는 서버에서 전송받은 데이터를 통해 대화를 생성합니다.<br> - GPT Prompt를 이용하여 NPC들의 행동을 결정합니다. <br>3. Unity<br> - Django 서버로부터 전달받은 NPC 페르소나 정보 및 기억을 프론트엔드 차원에서 구현합니다.<br> - Unity 엔진을 이용하여 Windows 운영체제를 기반으로 하는 PC게임 빌드 파일을 구성합니다.<br> Unity에서 생성된 정보를 Django 서버로 전달합니다. 이를 NPC의 페르소나를 기반으로 GPT Prompt를 작성하여 Chat GPT 3.5에 전달합니다. Chat GPT는 전달받은 prompt를 기반으로 각 NPC의 대화를 생성하고 행동을 결정합니다. 이렇게 생성된 NPC의 대화와 행동은 Django 서버를 통해 Unity로 전달됩니다. Unity에서는 서버에서 전달받은 데이터를 기반으로 NPC의 대화를 UI로 구현하고, Behavior Tree를 통해 NPC들의 행동을 구현합니다.|
| (8-7) 과제: 기대 효과 및 의의 | 1. 현실감과 예측 불가능한 NPC : 생성형 AI를 기반으로한 스스로 판단하고 상호작용하는 Human-like NPC를 게임에 적용함으로써, 유저에게 현실감 있는 게임 세계를 제공합니다. NPC는 각자의 페르소나에 기반한 행동 패턴을 갖추며, 유저가 상호작용을 시도하면, 정해진 패턴이 아니라 고유한 행동패턴을 기반으로 때에 따라 다르게 반응합니다. 이를 통해 유저들은 획일화된 플레이가 아닌, 생동감 있는 플레이를 할 수 있습니다.<br>2. 게임 플레이의 다양성 : 생성형 AI를 기반으로 하는 NPC가 게임에 도입되면, 유저의 선택과 행동에 따라 게임의 흐름이 변화합니다.이를 통해 유저는 각각의 상황에 따른 게임 플레이 전략을 세워야하고 새로운 문제에 대응해야 합니다. 이로써 유저들의 게임 경험을 더욱 개인화하고 다양한 게임 플레이를 즐길 수 있습니다.<br>3. 생성형 AI의 게임적 활용 : 생성형 AI가 게임에 도입된 사례가 많지 않다는 점에 주목하여 이 프로젝트는 생성형 AI를 게임 환경에 효과적으로 적용하고 최적화하는 기술적인 도전 과제를 이행하고 있습니다. 이에 대한 결과물은 게임 산업에서 생성형 AI 기술을 더욱 확장하는 토대가 될 수 있습니다.|
| (9) 데모 내용 | 1) Agent의 행동을 ChatGPT를 이용하여 생성하고 이모지와 텍스트로 출력<br>2) Agent가 다른 Agent를 인식하여 대화하는 기능<br>3) Agent와 유저가 대화하고 퀴즈를 푸는 기능 <br>4) 최종 결과창 <br> |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-14
| (1) 과제명 | PitchFinder: 사용자 음높이 기반 가요 필터링 서비스 개발
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 14-CoB |
| (3) 팀원 역할 분담 | 이나현(2076292): 팀장, 전반적인 일정 관리, 메인, 마이페이지 뷰 개발<br>김채리(2071018): 데이터 수집 및 서버 API 개발<br>김선영(2071010): 음역대 측정 뷰 및 기능 개발 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 김유리 / SAP / 개발자 |
| (6) 과제 키워드(keywords) | 음역대, FFT, 노래 |
| (7) 과제 내용 요약 | ‘들을’ 노래가 아닌 ‘부를’ 노래를 찾기 위해 개인 음역대를 측정하고 측정된 음정을 기반으로 노래를 필터링 하여 추천하는 서비스 |
| (8-1) 과제: 문제의 정의 | 노래방에 가서 평소 자주 들었던 노래를 불러봤다가 너무 어려웠던 경험,<br>분명 시작 음정이 낮아서 야심차게 불렀는데 갑자기 높아진 음역대에 삑사리가 난 경험, 다들 한번씩 있지 않으셨나요?<br><br>개인의 음역대는 다양하고 이에 따라 잘 '부를 수 있는' 노래는 달라집니다. 우리는 노래방에 가거나 공연 무대에 서기 위해 노래를 고를 때 어떤 노래가 부르기 쉽고 내게 맞을지 오랜 시간을 고민합니다.<br><br>자주 듣는 노래 순위를 보여주는 스트리밍 서비스의 차트와 노래방에서 많이 불린 노래들을 보여주는 인기 차트는 전혀 다르고, 포털 사이트에서는 '노래방 노래 추천 남자' '노래방 노래 추천 20대'와 같은 검색어들이 검색됩니다. 부르기 좋은 노래를 추천받고 싶은 수요는 많지만 듣기 좋은 노래를 추천해주는 기존 서비스들은 이 수요를 충족시키지 못하고 있습니다. |
| (8-2) 과제: 기존연구와의 비교 | 접근성 좋은 객관적인 음역대 측정 기능의 부재<br>- 개인이 음역대를 측정할 때 영상이나 글로 추상적으로 설명하는 음역대 측정 컨텐츠로 주관적으로 판단하는 방식만 있음<br>- 현재 정교하고 객관적으로 음역대 측정을 하기 위해서는 장비나 전문가가 필요합니다.<br><br>선호도 기반의 기존 노래 추천 서비스<br>- 노래 추천 서비스를 제공하는 기존 음원 플랫폼들은 협업 필터링 알고리즘을 이용하여 이용자로부터 수집한 피드백 데이터와 다른 이용자의 경험을 바탕으로 판단합니다.<br>- 이때 사용하는 데이터들은 전부 이용자들이 '들은' 노래를 기반으로 판단하기 때문에 개인이 듣고 싶은 노래의 선호도에는 잘 맞을 수 있으나, '부르기 편한' 노래를 추천해주는 것과는 거리가 멀다. |
| (8-3) 과제: 제안 내용 | 사용자의 음역대를 측정해서 최고 음정, 최저 음정, 정확도가 높았던 음정들을 기반으로 사용자가 쉽게 잘 부를 수 있는 노래를 추천해줍니다.<br><br>1. 개인 음역대 측정<br>사용자가 지정된 노래를 부르거나 지정된 미션을 수행하고 이를 녹음하게 하는 방식의 음역대 측정을 통해 사용자로부터 정확도가 높은 음정, 낮은 음정, 최고 음정, 최저 음정 등 추천에 필요한 데이터를 뽑아냅니다.<br><br>2. 노래 추천<br>음역대가 사용자의 최고음정 ~ 최저음정 사이에 존재하는 노래들만 필터링합니다. 필터링된 노래들 중 노래별로 유저의 정확도가 높은 음정 순서대로 정렬합니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 사용자가 제공되는 샘플 음원을 부르면 음역대를 측정한다.<br>2. 음역대에 맞는 노래 1~10순위를 추천해준다.<br>3. 순위에 있는 노래를 클릭하면 해당 노래의 유튜브 링크로 이동한다.<br>4. 고음/저음 연습을 통해 도달할수 있는 음역대의 노래들도 추천 |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-15
| (1) 과제명 | 다시: 은퇴한 시니어 전문가를 위한 긱 워킹 채용 플랫폼
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 15-감자도리 |
| (3) 팀원 역할 분담 | 최한비(2076429): 리더, UI/UX 디자인, 프론트엔드 및 백엔드 개발<br>권태영(2171004): 팀원, UI/UX 디자인, 프론트엔드 개발, 이력서 텍스트 추출 AI 개발<br>김서현(2176063): 팀원, 백엔드 개발, 서비스 아키텍처 설계 및 배포, 인재풀 추천 AI 알고리즘 개발 |
| (4) 팀 지도교수 | 김명 교수님 |
| (5) 팀 멘토 | 이채은 / 삼성전자 / 사원 |
| (6) 과제 키워드(keywords) | 시니어 전문가, 긱 워킹, 채용  |
| (7) 과제 내용 요약 | '다시'는 고령화되는 사회 속에서 은퇴 후에도 경력을 살려 시니어 전문가로 활약할 수 있도록 기업에게 저렴하고 전문적인 긱 워커를 추천해주는 채용 플랫폼이다. 은퇴 후 본인의 전문성을 충분히 살리지 못하는 시니어와 유동적인 노동 수요를 가진 기업을 연결하는데 초점을 두고 있다. 시니어 친화적 UI, AI 추천 알고리즘을 이용한 빠른 매칭과 저렴한 중개 수수료를 통해 여타 채용 플랫폼과의 차별성을 확보했다. 이외에도 텍스트 인식 AI 및 생성형 AI를 통해 시니어 전문가의 이력서 및 전문가 소개 작성을 돕는다. |
| (8-1) 과제: 문제의 정의 | 은퇴 후에도 경력을 살려 일하고 싶은 시니어가 많지만, 현실적인 이유로 재취업에 어려움을 겪고 다른 일자리로 이직해야 하는 전문가 비율이 높았다. <br><br>기존 시니어 일자리 플랫폼은 저숙련 노동 직업군 위주인데다 시니어가 사용하기에 UI가 복잡하다는 문제가 있었다. 또한 기업 입장에서도 원하는 조건을 일일이 필터링하여 인재를 찾아야 한다는 불편함이 있었다. <br><br>이러한 문제 상황과 더불어 기업의 필요에 맞게 초단기 노동을 제공하는 긱 워커(Gig Worker)의 수가 증가하고 있다는 채용 시장의 변화를 발견했다. 이에 은퇴한 시니어 전문가가 기업의 수요에 맞게 단기로 일할 수 있도록 기업과 시니어를 매칭해주는 시니어 긱 워킹 채용 플랫폼을 고안하게 되었다. |
| (8-2) 과제: 기존연구와의 비교 | <b>[시니어 채용 서비스]</b><br><b>1. 중장년 워크넷</b><br>채용 방식: 공고에 직접 지원<br>장점: 구직, 전직 등을 위한 다양한 서비스를 지원한다.<br>&emsp;&emsp;&ensp;채용 공고 검색, 필터링 기능이 상세하다.<br>단점: 전문성을 살릴 수 있는 분야를 대상으로 한 공고가 적다.<br>&emsp;&emsp;&ensp;- 개발로 검색했을 때 공고는 17건 정도였다. 반면 보건, 의료 분야는 900건이 넘는다.<br>&emsp;&emsp;&ensp;- 따라서 우리 서비스의 타겟층인 경력을 갖춘 중장년은 선택의 폭이 줄어든다.<br><br><b>2. 올워크</b><br>채용 방식: 공고에 직접 지원, 헤드헌팅<br>장점: 채용 공고, 교육, 컨설팅을 지원한다.<br>&emsp;&emsp;&ensp;시니어(40대 이상) 맞춤 공고만 제공한다.<br>&emsp;&emsp;&ensp;헤드헌팅 프로그램을 제공한다.<br>단점: 헤드헌팅의 경우, 헤드헌터가 의뢰인과 미팅을 통해 인재를 파악한 후 제공하는 형식으로 기업에서 원하는 인재를 직접 찾기는 어렵다.<br>&emsp;&emsp;&ensp;7단계의 헤드헌팅 프로세스를 가지며, 시스템이 자동화되어 있지 않아 기업에서 인재를 추천받기까지 시간이 소요된다.<br><br><b>3. 리멤버 헤드헌팅</b><br>채용 방식: 헤드헌팅<br>장점: 400만 이상의 인재를 보유하여 국내 최대 규모의 인재풀을 제공한다.<br>&emsp;&emsp;&ensp;전용 AI 서치 솔루션을 활용하여 추천한다.<br>단점: 리멤버 앱(명함, 이력서 업로드 앱)을 사용하는 모든 회원을 대상으로 이직 오퍼를 보낼 수 있어 등록된 인재풀 인원이 모두 이직을 희망한다고는 볼 수 없다.<br><br><b>4. 링크드인</b><br>채용 방식: 공고에 직접 지원, 인재풀<br>장점: 경력직 고급 인재풀이 형성되어 있다.<br>단점: 각 인재가 희망하는 급여 수준이 공개되어 있지 않다.<br>&emsp;&emsp;&ensp;한국의 전통적인 채용 플랫폼 형식이 아닌 SNS 형태의 웹사이트라 처음 서비스 이용에 장벽이 있다.<br>&emsp;&emsp;&ensp;기업 사용자의 경우 월 158,919원에 30개의 메시지를 보낼 수 있어 상당한 비용이 소요된다.<br>&emsp;&emsp;&ensp;통계 분석 플랫폼 Ranktracker의 'The 62 Best LinkedIn Statistics for 2023'에 따르면, 플랫폼 사용자의 2%만이 55세 이상이다.<br><br><b>[긱 플랫폼]</b><br><b>1. 크몽 엔터프라이즈</b><br>채용 방식: 헤드헌팅<br>장점: 찾는 전문가의 직군/직무, 채용 형태(외주/상주, 원격), 프로젝트 제목을 입력하여 프로젝트를 등록하면 전담 매니저가 프리랜서를 연결해준다.<br>단점: 매니저가 매칭해준 인재들만 조회할 수 있다.<br>&emsp;&emsp;&ensp;계약까지 평균 일주일 정도의 기간이 소요된다.<br><br><b>2. 원티드 긱스</b><br>채용 방식: 프로젝트 지원, 프리랜서 매칭<br>장점: 긱 워커들에게 인공지능을 이용해 적합한 일자리를 매칭한다.<br>&emsp;&emsp;&ensp;매칭 매니저가 기업과 긱 워커의 채용 과정을 일대일로 조율한다.<br>단점: 주 직업군이 개발과 디자인으로 한정되어 있다.<br><br><b>3. 탤런트뱅크</b><br>채용 방식: 공고에 직접 지원, 인재풀<br>장점: 프로젝트 형식으로 채용해 기업의 비용 부담이 적다.<br>&emsp;&emsp;&ensp;전문가는 기업 고객의 프로젝트 의뢰 분야에 따라 인공지능(AI) 매칭으로 맞춤형 프로젝트를 추천받을 수 있다.<br>&emsp;&emsp;&ensp;전문가의 자기소개에 기업 고객의 고민, 프로젝트 내용, 예상 산출물, 프로젝트 기대효과를 적을 수 있게 하여 정형화된 이력서 형식을 개선했다.<br>단점: 프로젝트의 상한 가격에 제한을 두지 않아 전문가들이 수행한 전체 프로젝트의 평균단가는 2022년 3분기 기준 1000만 원까지 상승하여 기업 사용자 입장에서는 가격적 부담이 될 수 있다.<br>&emsp;&emsp;&ensp;2022년 기준 50대, 60대 가입자 비중이 각각 52.5%→42.4%, 27.0%→18.7%로 감소했다.<br><br>‘다시’는 오랜 경력을 갖춘 시니어 전문가 인재풀을 바탕으로 기업에게 인재를 추천하고, 그 과정에서 인재의 정보를 투명하게 공개하는 것이 강점이다. 우리 서비스는 업무 한 줄 소개를 바탕으로 검색 과정을 대폭 간략화 하여 기업이 AI 매칭 알고리즘을 통해 필요에 맞는 전문가를 쉽고 빠르게 소개 받을 수 있도록 했다. 또한 중개수수료 및 인건비를 낮추어 저렴한 가격에 고급 인력에 접근할 수 있다는 이점을 두었다. 추천 받은 전문가의 이력서 및 전문가 소개가 마음에 든 경우 기업이 채용 제안을 보내는 형식으로 서비스를 구성하여, 기업이 구인 공고를 등록하면 전문가가 그에 지원하는 기존의 수동적인 구인구직 방식과 차별점을 두었다. |
| (8-3) 과제: 제안 내용 | 고령화되는 사회 속에서 은퇴 후에도 전문가로 활약할 수 있도록 ‘은퇴한 시니어 전문가를 위한 긱 워킹 채용 플랫폼, 다시’를 해결책으로 제시한다. ‘다시’는 경험과 전문성을 살릴 수 있는 핵심 직업군 7개(경영지원, 영업기획, 마케팅, IT, 엔지니어링, 생산제조, 의료)를 대상으로 서비스하며, 큰 버튼과 굵은 글씨 등 시니어 맞춤형 UI와 더불어 AI를 이용한 쉽고 빠른 인재풀 검색 기능을 제공한다.  |
| (8-4) 과제: 과제의 주요 기능 | **1. 텍스트 인식 AI를 활용한 이력서 작성**<br>시니어 전문가는 이미 잘 다듬어진 이력서를 보유한 경우가 많기 때문에, 귀찮게 모든 항목을 새로 입력할 필요가 없도록 기존에 갖고 있던 이력서 파일을 활용할 수 있게 했다. 시니어가 이력서를 pdf 형태로 업로드하면 CLOVA OCR 및 OpenAI를 활용해 핵심 정보만 추출한 후 자체 제공하는 이력서 양식을 채운다. 이후 희망 근무 분야, 기간, 급여, 업무 형태(상주/원격)등 희망하는 근무 환경에 대한 정보를 추가로 입력할 수 있다. <br><br>**2. 생성형 AI를 활용한 전문가 소개 초안 작성**<br>기업이 조회하는 인재풀에는 이력서와 전문가 소개가 함께 등록된다. 기업의 수요를 잘 파악하고 있는 시니어 전문가가 그에 맞춰 기업에 제공할 수 있는 서비스를 전문가 소개란에 능동적으로 서술하여 기업에 어필할 수 있도록 했다. 또한 소개와 함께 희망 근무 조건을 명확하게 명시하여 기업이 각 전문가의 역량과 그에 따른 비용을 빠르게 비교할 수 있도록 했다. 또한 입력한 이력서 정보를 바탕으로 생성형 AI를 활용하여 트렌디한 자기 어필 소개 문구를 작성해주는 기능도 도입 고려 중이다. 이러한 전문가 정보 구성을 통해 단순 정보 나열로 이루어진 기존의 수동적 이력서를 탈피하고자 했다. <br><br>**3. AI 인재 추천** <br>기업은 "멀티플레이어 전략 보드 게임 개발"과 같이 업무 한 줄 소개를 입력하여 상황에 맞는 인재를 추천 받을 수 있고, 직군/스킬/경력/급여 필터링을 통해 원하는 조건에 맞게 검색할 수 있다. 기업이 입력한 줄글 형태의 업무 한 줄 소개에서 핵심 키워드를 추출하여 적합도가 높은 순서대로 이력서를 노출한다. 기업은 검색 결과 목록에서 각 인재의 키워드 및 평점을 확인한 후 마음에 드는 인재가 있다면 전문가 상세 페이지 열람을 통해 이력서 및 전문가 소개를 확인할 수 있다. 검색 외에도 기업 사용자는 가장 조회수가 높은 순서, 가장 최근에 이력서를 등록한 순서 등으로 인재풀을 정렬한 결과를 확인할 수 있다.<br><br>**4. 채용 제안 및 수수료 정산**<br>마음에 드는 인재를 찾은 경우 기업은 채용 제안을 보낼 수 있다. 기업 사용자가 희망 근무 형태 및 기간, 급여, 업무 소개를 작성하여 제출하면 시니어 사용자가 채용 제안 알림을 받는다. 시니어 사용자는 근무 조건을 확인하고 채용 제안을 수락 또는 거절할 수 있다. 제안을 수락한 경우 제안 월급의 10%에 해당하는 중개 수수료를 기업 사용자가 결제한다. 결제를 마치면 기업 사용자는 시니어 사용자의 전화번호 및 이메일 주소 등 연락처를 열람할 수 있다. <br><br>**5. 리뷰 작성**<br>시니어와 기업의 계약 기간이 지난 경우 기업 사용자는 시니어 사용자에 대해 리뷰를 작성할 수 있다. 채용 제안 관리 페이지에서 ‘완료된 계약’으로 필터링하면 리뷰 작성 버튼이 노출되고, 기업 사용자는 각 계약 건에 대한 평점, 해시태그 및 후기 줄글을 작성할 수 있다. 제출된 리뷰는 시니어 전문가 상세 페이지 및 인재풀 페이지에 노출된다. 5점 만점으로 된 평점이 먼저 노출되고, 평점이 적혀 있는 버튼을 누른 경우 어떤 기업이 해당 사용자에 대해 무슨 코멘트를 남겼는지 상세 리뷰를 확인할 수 있는 리뷰 페이지로 전환된다. |
| (8-5) 과제: 구현 방법 | ![image](https://github.com/hanby-choi/hanby-choi/assets/76518934/14c26bb7-7d7a-421a-9c1b-24c4883d9ae6) **1. React & Django를 이용한 웹 서비스 구축**<br>시니어 및 기업 사용자의 서비스에 대한 접근성을 높일 수 있도록 반응형 웹 페이지를 개발했다. 프론트엔드는 React, TypeScript, SCSS를 이용했고 백엔드는 Django, MySQL, AWS를 통해 구현했다. 시니어가 무리 없이 서비스를 사용할 수 있도록 크고 굵직한 UI로 구성하였고, 어디서든 사용할 수 있도록 모바일 및 PC 웹 뷰를 모두 제공한다.<br><br> **2. 텍스트 인식 AI를 활용한 이력서 작성** <br>시니어 회원이 PDF 형식의 이력서 파일을 업로드하면, 학력과 경력사항 정보를 추출하여 필수 필드를 자동으로 작성할 수 있다. 이를 위해 Naver CLOVA OCR 기술을 활용하여 텍스트를 추출하고, 개인정보 마스킹 후 Open AI를 이용하여 JSON 형식으로 포맷팅하여 반환한다.<br><br>**3. 생성형 AI를 활용한 전문가 소개 초안 작성**<br>‘다시’는 인재풀에 등록되는 이력서와 함께 전문가 소개도 제공한다. 시니어 전문가는 마크다운 에디터를 이용해 기업의 요구사항에 맞추어 자신이 강점을 가진 역량에 대해 능동적으로 서술한다. 더 쉽고 빠르게 전문가 소개를 완성할 수 있도록 생성형 AI로 초안 작성을 도와주는 기능을 제공한다. 이력서 정보를 바탕으로 Open AI를 활용하여 트렌디한 소개 문구를 작성할 수 있다.<br><br>**4. AI 인재 추천**<br>기업이 입력한 줄글 형태의 업무 한 줄 소개에서 핵심 키워드를 추출하여 적합도가 높은 순서대로 이력서를 노출하는 기능이다. KoNLPy를 이용하여 핵심 키워드를 추출하고, scikit-learn을 이용하여 업무 소개 검색어와 NCS 직업역량 키워드 간의 유사도를 계산한다. 또한, 기업이 요구한 스킬, 경력, 급여에 따른 점수를 합산해서 검색 결과를 반환한다. |
| (8-6) 과제: 세부 기술 |**1. 텍스트 추출 AI**<br>텍스트 추출 AI는 기존 이력서 파일에서 학력 및 경력 정보를 추출하기 위해 OCR 기술과 JSON 형식으로 포맷팅하는 기술이 필요하다. OCR 기술은 한글 인식에서 높은 정확도를 보여준 네이버 클라우드 플랫폼의  CLOVA OCR을 선택했다. CLOVA OCR은 문서 처리에 용이한 가로 문자 인식을 제공하며, 인식 대상의 레이아웃을 분석하고 글자를 읽는 순서와 방향을 추정하여 문자를 인식한다. 프론트엔드와 백엔드 간 REST API 통신을 위해 OCR 추출 결과를 JSON 형식으로 가공하고자 했다. OCR 기술로 추출한 정보를 처리하기 위해 OpenAI의 gpt-3.5-turbo-instruct 모델을 사용했다. 이 모델은 작업 지향적이며 추가 프롬프트 없이도 지시를 이해하고 처리하여 응답할 수 있기 때문에 선택했다. 이러한 터보 모델을 통해 포맷팅 작업을 빠르고 정확하게 수행할 수 있도록 했다. 또한, 적절한 정보를 추출하도록 텍스트의 y축 오차 범위를 지정하여 동일한 문단으로 판정하도록 했다. 그리고 OpenAI를 활용하는 과정에서 개인정보 누수가 발생하지 않도록 데이터 포맷팅 전에 이름, 주소, 전화번호 및 메일 주소 등 개인정보를 마스킹하는 코드를 추가하여 검증 과정을 거쳤다.<br><br>**2. 인재 추천 AI**<br>인재 추천 시스템에서는 기업 사용자의 업무 한 줄 소개 검색어와 시니어 전문가의 이력서 간의 유사도를 측정하는 기술이 필요하다. ‘만들다’, ‘만들고’, ‘만드는’ 등 같은 단어가 다르게 활용되더라도 하나의 의미로 인식하도록 띄어쓰기 기준으로 단순 키워드를 추출하지 않고 명사 형태로만 키워드를 추출하고자 KoNLPy의 형태소 분석기 중 Hannanum 명사 추출기를 활용했다. 또한, 기업 사용자가 간단한 검색어를 입력해도 원하는 인재를 효과적으로 찾을 수 있도록 scikit-learn의 TF-IDF 벡터화를 이용하여 모든 이력서에서 공통적으로 나타나는 단어에 대해서는 패널티를 부여하고, 희귀하게 나타나는 단어에 대해 높은 점수를 부여했다. 직무와 직접적인 관련이 없는 ‘능력’, ‘경험’과 같은 일반적인 단어들을 stop word로 설정하여 유사도 계산에서 제외했다. 유사도 점수 계산 후에는 기업 사용자가 공고에 요구하는 스킬셋, 경력 범위, 급여 범위 조건을 설정할 수 있도록 하여 각각 반영비를 고려하여 최종 점수를 산출했다.|
| (8-7) 과제: 기대 효과 및 의의 |**1. 시니어 전문가의 사회 재진출 및 재취업 영역 확장**<br>기존 시니어 대상 채용 플랫폼은 저숙련 노동 직업군 위주로 일자리를 알선하여 직업군과 근무 형태가 제한적이라는 한계가 있었다. ‘다시’를 통해 시니어 전문가는 단기 프로젝트에 참여하여 경력을 유지할 수 있게 된다. 이를 통해 시니어들은 보유한 지식을 활용하여 다양한 직업군에서 활약할 수 있으며, 직업적 성취를 이루어 자기 효능감을 높일 수 있다.<br><br>**2. 기업을 위한 개방적이고 저렴한 전문가 영입 플랫폼 구축**<br>‘다시’의 업무 한 줄 소개 기반 AI 매칭은 기업이 필요로 하는 인재를 빠르고 효율적으로 발굴할 수 있도록 한다. 이를 통해 기존의 폐쇄적이고 고비용의 전문가 영입 방식을 보완하여 개방적이고 비용 효율적인 플랫폼을 제공한다.   기업은 합리적인 가격에 경험이 풍부한 시니어 전문가를 영입하여 프로젝트에 바로 투입할 수 있는 인재를 얻을 수 있다.<br><br>**3. 시니어와 기업 간 선순환 형성**<br>시니어는 은퇴 후에도 ‘다시’를 통해 자신의 기술과 지식을 바탕으로 단기 프로젝트에 참여함으로써 활약할 수 있다. 동시에 기업은 노련한 전문가를 쉽고 빠르게 섭외하여 프로젝트에 필요한 인재를 확보할 수 있다. 이를 통해 시니어와 기업 간의 선순환 관계가 형성되는 것을 목표로 하고 있다.<br><br>**4. 정부 사업 연계**<br>서비스가 확장되면 보건복지부 시니어인턴십 사업, 고용노동부 신중년 경력형 일자리 사업 등 정부사업에 참여하는 기업과 시니어 전문가를 매칭하는 업무를 수행할 수 있다.|
| (9) 데모 내용 |1. 로그인: 시니어 사용자가 [다시: 은퇴한 시니어 전문가를 위한 긱 워킹 채용 플랫폼](https://dasi-expert.com)에 정보를 입력하여 로그인한다.<br>2. 이력서 자동완성: 기존 이력서 파일을 업로드하여 학력과 경력사항 정보를 자동으로 작성한다.<br>3. 이력서 작성: 직군 및 직무, 총 경력, 보유 스킬 및 자격증 등 필수 정보를 입력하여 이력서를 작성한다.<br>4. 전문가 소개 작성 및 인재풀 등록: 전문가 소개 탭으로 이동해 키워드와 전문가 소개를 작성하고, 인재풀 등록 버튼을 클릭해 인재풀에 이력서를 등록한다.<br>5. AI 인재 추천: 인재풀 조회에서 업무 한 줄 소개를 검색하여 추천 결과를 확인한다. 근무 형태, 직군 및 직무, 보유 스킬 및 자격증, 총 경력, 근무 기간, 급여로 필터링할 수 있다.|
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-16
| (1) 과제명 | 주변 소리를 인식하여 상황별 알람을 받을 수 있는 서비스: 쫑긋 
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 16-깡총 |
| (3) 팀원 역할 분담 | 박현정 |
| (4) 팀 지도교수 | 이민수 |
| (5) 팀 멘토 | ... |
| (6) 과제 키워드(keywords) | ... |
| (7) 과제 내용 요약 | ... |
| (8-1) 과제: 문제의 정의 | ... |
| (8-2) 과제: 기존연구와의 비교 | ... |
| (8-3) 과제: 제안 내용 | ... |
| (8-4) 과제: 과제의 주요 기능 | ... |
| (8-5) 과제: 구현 방법 | ... |
| (8-6) 과제: 세부 기술 | ... |
| (8-7) 과제: 기대 효과 및 의의 | ... |
| (9) 데모 내용 | ... |
| (10) 기타 | ... |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-17
| (1) 과제명 | AI 객체 인식과 프롬프트 엔지니어링을 활용해 맞춤형 건강 조언을 제공하는 과민대장증후군 관리 어플리케이션, BellyWelly
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 17-출발드림팀 |
| (3) 팀원 역할 분담 | 송채원(2076216): 팀장, 딥러닝 YOLOv8, FastAPI, PyTorch, Python<br>안채연(2076232): 팀원, 프론트엔드 <Progressive Web App> TypeScript, React.JS<br>김예지(2176082): 팀원, 백엔드 Java, Springboot, MySQL, AWS Ubuntu, Docker |
| (4) 팀 지도교수 | 오세은 |
| (5) 팀 멘토 | 정좌연 / LG CNS / 책임(PM) |
| (6) 과제 키워드(keywords) | 과민대장증후군, 헬스케어, 습관 개선  |
| (7) 과제 내용 요약 | BellyWelly는 과민대장증후군으로 고통받는 사람들의 평소 습관 개선을 돕는 모바일 서비스입니다. AI 객체 인식을 통해 사용자의 식단을 분석하고 자동 기록하며, 사용자가 섭취한 음식과 영양소를 기반으로 포드맵을 분석합니다. 또한 배변 및 스트레스 기록을 기반으로 프롬프트 엔지니어링을 활용하여 사용자별 건강 상태를 요약하고 맞춤형 건강 관련 조언을 제공합니다. |
| (8-1) 과제: 문제의 정의 | 현대 사회에 불규칙적인 생활 패턴과 스트레스로 인해 장 건강에 큰 영향을 받는 사람들이 점차 증가하고 있다. 국내에서 연간 약 150만명의 과민대장증후군 환자가 발생했고, 이들은 일상 생활에 큰 불편을 겪고 있다. 대부분의 사람들은 자신의 장 건강 상태를 정확하게 알지 못하며, 자신에게 맞는 건강한 식습관과 생활 패턴을 구축하는 것에 어려움을 느끼고 있다. 하지만 이들의 문제를 해결할 수 있는 사용성 좋은 어플리케이션은 현재 부재하다. 따라서, 사용자 개개인의 식습관, 배변 상태, 스트레스 지수 등을 효과적으로 기록하고 분석하여, 개인별 맞춤형 건강 관리 방안을 제공할 수 있는 서비스의 필요성이 점점 커지고 있기에, 과민대장증후군 개선을 위한 헬스케어 서비스를 제안한다. |
| (8-2) 과제: 기존연구와의 비교 | 1. 관련 임상 연구<br>과민대장증후군 환자들에게 특정 음식이나 영양소가 어떠한 영향을 미치는지에 대한 연구로, FODMAP 제한식이 과민대장증후군의 증상을 완화하는지에 대한 연구<br>- 과민성장증후군 치료에서 저포드맵식이의 역할은? (박경식(Kyung Sik Park), 대한소화기학회지,<br>https://kiss-kstudy-com-ssl.access.ewha.ac.kr/Detail/Ar?key=3573105 )<br>→ 영양사의 식이 조언을 동반한 LFD 섭취를 통해 IBS(과민성장증후군) 환자에서 위장 관련 증상들을 상당히 개선시킬 수 있음과 이와 함께 다균종 생균제를 같이 투약함으로써 증상 개선에 도움이 되는 Bifidobacterium 종의 분포를 증가시킬 수 있음을 제시함<br><br>2. 서비스 및 시스템 조사결과 및 한계점<br>(1) 과장님케어 - 건강한 장건강 관리 서비스<br>[기능]<br>- 장관리를 전문으로 하는 앱으로 증상과 식단, 배변, 복약기록을 통해 일주일 단위로 레포트를 받아보고 전문 영양사에게 1:1 질문을 할 수 있는 앱<br>- 커뮤니티 기능을 토대로 장에 관한 고민이 있는 사람들이 모여 함께 질문도 올리고 답변도 받을 수 있음.<br>[한계점]<br>- 식단 입력 시에 한정된 종류의 음식 리스트 중에서 입력해야하므로 불편함<br>- 음식 리스트가 스크롤을 계속 내려야 하는 드랍다운 형식으로 되어있어 사용성 면에서도 불편함<br>- 앱 사용 중 로딩이 오래 걸리는 일이 매우 잦음<br>- 커뮤니티 기능에서 전문 영양사와 1:1 식단 상담이 가능하지만 단순한 질답 형식에 불과하여 사용장 대한 지속적인 관리가 이루어지지 않음<br><br>(2) 피비오 - 식이기록, 배변기록, 건강관리, 헬스케어<br>[기능]<br>- 스스로 장내 미생물 생태계인 마이크로바이옴을 모니터링 하면서 건강하게 관리할 수 있도록 돕는 마이크로바이옴 헬스케어 솔루션<br>- 식이 기록을 통한 마이크로바이옴 관리<br>- 배변로깅을 통한 장내 마이크로바이옴 모니터링 및 솔루션 제공<br>- 포드맵 검색<br>[한계점]<br>- 배변 상태 기록 시, 삭제는 가능하지만 수정이 불가능하고 세부 기록을 할 수 없음<br>- 음식 섭취전 먹을 재료에 대한 포드맵을 직접 검색해야하는 수고로움이 있음 |
| (8-3) 과제: 제안 내용 | 1. AI를 이용한 식단 기록<br>- 사용자가 먹은 음식 사진을 업로드<br>- AI 기반으로 음식 분석 후 자동 기록<br>- 사용자가 섭취한 음식과 영양소를 기반으로 포드맵 분석<br><br>2. 사용자 분석 레포트 제공<br>(1) 식단 분석<br>- 사용자가 기록한 식단을 토대로 주요 영양소 섭취량 및 권장량 비교<br>- 사용자별 장 건강에 영향을 미칠 수 있는 재료나 음식 섭취 빈도 분석<br>- 사용자에게 영양소 및 건강 관련 조언 제공<br><br>(2) 배변활동 분석<br>- 사용자가 배변 빈도, 상태, 색상 등의 정보 입력<br>- 배변 패턴 분석 및 추정 지표 제공<br>- 배변 패턴과 장 건강 간의 연관성 분석 후 GPT API를 활용하여 개선점 제공<br><br>(3) 스트레스 분석<br>- 사용자의 일일 스트레스 지수 입력<br>- 기간별 스트레스 지수 그래프<br>- 스트레스와 장 건강 간의 연관성 분석 후 GPT API를 활용하여 개선점 제공<br><br>3. GPT API를 활용한 AI 영양사<br>- 사용자가 기록했던 식단을 보완해줄 수 있는 식단 추천 기능<br>- 사용자가 입력한 두 가지 음식 중에서 장건강에 가장 괜찮은 음식을 골라주는 기능 |
| (8-4) 과제: 과제의 주요 기능 | 1. 식단 인식 및 포드맵 분석<br>- 사용자가 먹은 음식 사진을 업로드<br>- AI 기반으로 음식과 음식의 영양소 분석 후 기록<br>- 사용자가 섭취한 음식과 영양소를 기반으로 포드맵 분석<br><br>2. 배변 활동 기록<br>- 사용자의 배변 활동을 일기처럼 기록 (빈도, 형태, 색상, 긴박감, 소요시간)<br><br>3. 스트레스 측정<br>- 1일 1회 사용자의 스트레스 단계 입력<br><br>4. 주간 분석 레포트<br>(1) 식단 분석<br>- 일주일치 식단의 포드맵 및 영양소 분석<br>- Best5 /Worst 5 음식 정보 제공<br>(2) 배변활동 및 스트레스 분석<br>- 분석 그래프 제공<br>- 프롬프트 엔지니어링을 활용하여 주간 상태 요약<br>(3) 총평<br>- 프롬프트 엔지니어링을 활용하여 피드백 제공<br>(4) pdf로 다운로드 가능<br><br>5. GPT를 활용한 식단추천 및 음식선택<br>- 사용자 기록을 기반으로 부족한 부분을 보완해줄 수 있는 식단 추천<br>- 사용자가 입력하는 여러가지 음식 중 가장 장 건강에 도움이 되는 음식 선택<br> |
| (8-5) 과제: 구현 방법 | 1. 프론트엔드<br>- 이미지 업로드에서 @react-image-picker 라이브러리를 사용해 사용자가 자신의 앨범에서 사진을 선택할 수 있도록 함<br>- 분석 레포트 그래프에서 @react-chartjs-2 라이브러리를 사용한 선그래프, 막대그래프, 도넛그래프 등 다양한 그래프 구현<br>- 프롬프트 엔지니어링 및 사용자 입력처리<br><br>2. 백엔드<br>- AWS SDK for Java 2를 이용하여 S3 presigned url 발급<br>- Spring Cloud Open Feign Client를 이용하여 kakao API 호출하여 카카오 로그인 구현<br>- Spring Security, JWT 토큰을 이용한 권한 설정<br>- PDF 파일 생성 및 내보내기<br>- 프롬프트 엔지니어링 및 Open AI API를 이용하여 레포트 생성<br>- AWS EC2, Nginx를 이용하여 웹서버 구축<br>- AWS RDS, MySQL을 이용한  데이터베이스 구축<br>- Github Actions, Docker를 이용한 CI/CD 구축<br>- Certbot을 이용하여 SSL 인증서 발급 후 HTTPS 연결<br>- Springdoc OpenAPI를 이용한 API 명세서 생성<br><br>3. 딥러닝<br>- 음식 이미지 및 해당 음식의 재료와 영양소 정보를 포함하는 대규모 데이터셋 수집<br>- 데이터 수집 후, YOLOv8 학습을 위한 데이터 형식 이미지와 레이블링된 바운딩 박스 정보에 맞게 전처리<br>- YOLOv8를 사용하여 음식을 인식하는 모델 학습<br>- FastAPI를 사용하여 사용자가 이미지를 업로드할 수 있는 API 엔드포인트 생성<br>- 업로드된 이미지를 YOLOv8 모델에 전달하여 음식 인식 수행<br>- 재료 및 영양소 정보와 함께 분석 결과를 사용자에게 반환<br>- 프롬프트 엔지니어링, 데이터 가공 및 모델 튜닝 |
| (8-6) 과제: 세부 기술 | 1. 식단 기록<br>(1) 이미지 입력 및 업로드<br>- 사용자는 클라이언트를 통해 식단 관련 이미지를 업로드<br>- 클라이언트는 이미지 업로드를 위한 presigned URL을 서버에게 요청<br>- 서버는 S3로부터 presigned URL을 발급받아 클라이언트에게 전달<br>- 클라이언트는 presigned URL에 이미지를 업로드하여 AI모델에게 전송<br><br>(2) 이미지 처리 및 분석<br>- AI 모델은 전달받은 URL을 통해 이미지를 다운로드하고 파일 시스템에 저장<br>- 저장된 이미지는 YOLOv8 모델을 통해 객체 탐지가 수행되며 음식 항목들이 탐지<br>- 탐지된 음식에 대한 라벨 정보가 리스트 형태로 저장되어 JSON 형식으로 클라이언트에 반환<br><br>(3) 사용자 수정 및 최종 결과 저장<br>- 반환된 리스트가 사용자에게 제공되며 잘못된 라벨이 있는 경우 수정할 수 있음<br>- 수정된 최종 결과는 클라이언트에 의해 저장<br><br>(4) 영양 성분 및 포드맵 결과 제공<br>- 서버는 저장된 최종 음식 결과를 바탕으로 장건강과 관련된 영양성분 및 포드맵 정보를 분석하여 클라이언트에 반환하여 사용자에게 제공<br><br>2. 주차별 사용자 분석 레포트 제공<br>(1) 사용자 데이터 수집 및 정리<br>- 사용자는 식단, 배변 활동, 스트레스 수준 등의 정보를 주차별로 기록<br>- 식단 정보에서 중요 영양성분, 포드맵 정보, 배변 활동과 스트레스 수준은 기록된 빈도와 지수로 데이터를 구조화하여 정리<br><br>(2) 프롬프트 엔지니어링을 통한 분석 프롬프트 구성<br>- 분석할 내용(장건강과 관련한 영양소, 배변, 스트레스 수준)에 따른 구체적인 분석 목표 설계<br>- 사용자의 건강 관련 데이터를 DB에서 추출하여 설정된 분석 목표에 따라 구체적인 질문이나 분석 요청을 프롬프트 형태로 작성<br><br>(3) GPT API를 통한 분석 및 레포트 생성<br>- 앞서 작성된 프롬프트를 GPT API에 전달하고, GPT는 사용자 데이터를 분석하여 결과를 생성<br>- 생성된 레포트는 사용자에게 제공되며, 사용자는 이를 통해 자신의 건강 관련 목표 달성 상태를 확인하고 필요한 개선 조치를 취할 수 있음<br><br>3. AI 영양사와의 채팅 기능<br>(1) 사용자 데이터 조회<br>- 사용자가 이전에 기록한 식단 정보를 저장한 DB를 연동하고, 주차별 식단 정보를 조회<br><br>(2) 프롬프트 엔지니어링을 통한 프롬프트 구성<br>- DB에서 조회한 사용자의 식단 정보와 입력을 바탕으로 GPT API에 전달할 프롬프트를 구성<br>- 구성된 프롬프트를 GPT API에 전달하고 분석 결과를 요청<br>- GPT로부터 반환된 결과를 분석하여 사용자에게 적합한 식단과 장 건강에 좋은 음식 정보를 도출하여 사용자에게 제공 |
| (8-7) 과제: 기대 효과 및 의의 | 1. 개인화된 건강 관리<br>사용자는 AI 기반 식단 분석을 통해 개인 영양소 과부족을 파악하고, 개선 조언을 받아 더 균형있는 식습관을 형성할 수 있습니다.<br><br>2. 건강 데이터 모니터링<br>사용자는 배변 활동과 스트레스 수준을 기록하고 분석하여 자신의 건강 상태를 식별함으로써 장 건강을 더 잘 이해하고 증상의 변화를 주시할 수 있습니다.<br><br>3. 개선된 장 건강<br>사용자들은 개인화된 식단 조언을 통해 증상을 관리하고, 과민대장증후군 개선에 맞는 올바른 식사 습관을 통해 장 건강을 개선할 수 있습니다.<br><br>4. 편리한 데이터 저장 및 공유<br>사용자 정보와 리포트를 PDF로 다운로드할 수 있어, 사용자는 의료 전문가와 공유하거나 자신의 건강 이력을 효과적으로 관리할 수 있습니다.|
| (9) 데모 내용 |- 카카오 로그인<br>- 메인화면<br>- 식단 기록<br>- 배변 기록<br>- 스트레스 기록<br>- 분석 레포트<br>- 추천기능<br>- 마이페이지<br>HDMI 케이블을 이용하여 맥북을 강의실 모니터에 연결하고, iPhone 화면을 맥북에 미러링한 후, iPhone 상에서 어플리케이션을 실행하여 시연   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-18
| (1) 과제명 | Prompirit: Automatic Prompt Engineering Assistance to Improve AI-Generative Art Using User Emotion
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 18-뽀로로에디 |
| (3) 팀원 역할 분담 | 김한나(2071019) 팀장, Text Emotion Recognition, Emotion label append & prepend, LMER model 피팅 통계 분석, 논문 작성<br>방선유(2076181) 팀원, Style keyword append, 설문지 제작, ANOVA 및 Pearson 통계 분석, 논문 작성<br>이현 (2070064) 팀원, Text tokenization & Keyphrase extraction, Style keyword append, 평균 및 정규화 통계, 논문 작성 |
| (4) 팀 지도교수 | 오유란 교수님 |
| (5) 팀 멘토 | 김민주 / 서강대학교 인공지능학과 대학원 / 석사과정  |
| (6) 과제 키워드(keywords) | Prompt Engineering, Text-to-Image Generative AI, Emotional and art technology |
| (7) 과제 내용 요약 | 감정은 인간 경험에서 중요한 역할을 하며 시각 예술과 문학을 포함한 다양한 형태의 예술을 통해 전달될 수 있습니다. 최근 텍스트-이미지 생성 AI 모델은 간단한 텍스트 프롬프트에서 이미지를 생성하여 예술을 통해 감정을 표현하는 능력을 입증했습니다. 하지만 AI는 아직 감정을 정확하게 반영하는 이미지를 생성하지 못합니다. 이전에도 감성컴퓨팅 분야에서는 기술을 이용하여 감성과 시각예술의 관계를 탐구하려는 시도가 있어왔습니다. 이러한 선행연구에서 영감을 받아 저희는 사용자의 감정을 반영해 이미지 생성형 AI의 결과물을 개선하기 위한 자동화 프롬프트 엔지니어링 도구인 Prompirit를 제안합니다. Prompirit은 사용자의 발화에 스타일 키워드를 적용하여 사용자의 감정에 최적화된 프롬프트를 생성합니다. 통계 분석 및 사용자 연구를 통해 Prompirit은 생성된 이미지의 감정 표현과 심미성을 크게 향상시켜 일상 생활에서 감정 표현을 이미지로 전달하는 장벽을 낮추는지 확인하고자 합니다. |
| (8-1) 과제: 문제의 정의 | - 프롬프트 엔지니어링이 필요한 이유: 많은 사람들이 생성형 AI를 이용할 때 원하는 결과물이 나오지 않아 여러 차례 프롬프트 입력을 되풀이하는 경우가 많다. 이 과정에서 도움을 줄 수 있는 것이 바로 프롬프트 엔지니어링이다. 챗지피티, 달리, 스테이블 디퓨전 등 텍스트 프롬프트를 이용한 생성형 AI의 등장은 많은 파장을 불러일으켰지만 사람이 사용하는 텍스트에는 기계가 이해하지 못하는 부분이 다량 존재하며, 결과물이 예측을 벗어나는 경우 또한 많다. 그러나 프롬프트 엔지니어링을 거친 텍스트는 사용자의 요청을 명확하게 전달할 수 있고, 따라서 이미지 생성형 AI의 경우 프롬프트와 이미지 간의 일치도 향상에 기여한다.<br> - 이미지 생성형 인공지능의 결과물의 감정 표현력을 높여야하는 이유: 인간에게 감정은 매우 중요하다. 특히 감정의 표현은 자기 표현, 자기 인식, 창의성을 풍부하게 하며 건강과 웰빙에 필수적인 요소이다. 따라서 이는 여러 방면에서 인간에게 도움이 되는 중요한 행동이다. Turkle은 컴퓨터 또는 AI가 인간과 다른 점을 검토하면서 감정을 느끼고 공유하는 능력이 주요 포인트 중 하나라고 지적했다. 컴퓨터가 인간 감정을 감지할 수 있게 만드는 주요 분야 중 하나는 감정 컴퓨팅이다. NLP 분야에서는 Text Emotion Recognition을 통해 이러한 노력이 이루어지고 있다. generative AI의 등장에 따라 컴퓨터 비전 분야에서는 감정과 예술의 상호작용에 중점을 둔 Emotion-based art generation 연구가 이루어졌다. 그럼에도 불구하고, Gen AI가 만들어낸 이미지에 대해서 부정적인 반응이 있는데, 예술가의 의도와 그에 따른 제작자와 감상자 측 모두의 감정적 참여가 결여되어있다는 것이 그 이유였다. demmer의 연구결과는 컴퓨터 생성 이미지가 감정적이고 의도적인 인간 요소를 부족하다는 믿음이 있었지만, 참가자들이 컴퓨터 또는 인간 예술가의 작품에 상관없이 감정을 느끼고 예술 작품에 의도를 부여한다는 것을 시사한다. 이에 우리는 Gen AI가 이미지를 생성하는 과정에서 텍스트 프롬프트를 입력하는 사용자는 하나의 창작자로서 참여함에 주목하였다.|
| (8-2) 과제: 기존연구와의 비교 | 1. Design Guidelines for Prompt Engineering Text-to-Image generative models<br> - 장점: 주제와 스타일 수식어를 포함하도록 구조화된 프롬프트의 내용 일치도와 심미성을 고려하여 성공 및 실패 모드를 조사했다.<br> - 단점: 이미지의 감정 표현력은 고려하지 않았다. <br> 2. RePromt: Automatic Prompt Editing to Refine AI-Generative Art Towards Precise Expressions<br> - 장점: 지금까지의 연구는 주로 사용자의 내용적 의도를 전달하고 미적인 만족도를 높이는 데에만 초점이 맞춰져 있었습니다. 리프롬프트는 이미지 생성형 AI 정확한 감정 표현을 위해 텍스트 프롬프트를 조정하는 것을 중점으로 합니다. 프롬프트 편집 과정은 주어진 텍스트에서 먼저 각 단어의 품사(POS)를 라벨링하고, 명사, 동사 또는 형용사가 아닌 단어를 제거하는 것이며, 원본 프롬프트를 그대로 이용하는 것보다 이미지 생성을 개선하는 데 효과적임을 증명했습니다. 이들은 감정을 고려한 프롬프트 엔지니어링이 이미지 생성을 개선하는 데에 효과적이며, 특히 부정적인 감정에 대해서는 IEA (이미지-감정 조화) 측면에서 향상되었다는 것을 시사했습니다.<br> - 단점: 이 연구는 단어 기준으로 텍스트 맥락을 분석해 의미의 손실이 있었고, 현재의 접근 방법이 구문과 의미에 제한되어 있다고 지적하며, 향후에는 style과 같은 시각적 요소를 고려해야 한다고 주장했습니다.|
| (8-3) 과제: 제안 내용 |최근 발전한 text-to-image 생성형 인공지능 모델들은 간단한 텍스트 프롬프트를 이용해 고품질의 이미지를 만들어내는 능력을 보여주고 있다. 그러나 아직까지는 생성적 AI가 감정을 정확하게 반영한 이미지를 만들어내는 능력은 부족하다. 따라서 우리는 감정의 표현력과 미학성을 개선하기 위한 자동 프롬프트 엔지니어링 보조 도구인 'Prompirit'을 제안한다. 우리는 사용자가 입력하는 자유로운 형식의 텍스트 입력을 개선하기 위해 사용자의 감정과 스타일 키워드를 포함하는 다양한 접근법을 탐구했다. 통계적 분석과 100명의 응답자를 대상으로 한 사용자 평가에서 Prompirit는 이미지-감정의 일치도와 생성된 이미지의 미학성을 현저히 향상시키는 동시에 원본 텍스트 입력의 내용을 정확하게 전달하는 것으로 나타났다. 이러한 결과를 바탕으로, 프롬피릿이 감정적 이미지를 효과적으로 생성할 수 있음을 시사한다. <br> <br> Recently, text-to-image generative Artificial Intelligence (AI) models have demonstrated their ability to generate high-quality art with text prompts. However, generative AI is still incapable of creating images that precisely reflect emotions. We propose Prompirit, an automatic prompt engineering assistance for improving AI-generated art in terms of expressiveness of emotion and aesthetics. We explored various approaches to refine users' free-form text inputs by incorporating user emotion and style keywords. Statistical analysis and user evaluation with 100 respondents showed that Prompirit significantly improved the alignments of image-emotion and the aesthetics of the generated image while precisely conveying the content of the original text input. Based on the results, we provide implications for creating affective images. |
| (8-4) 과제: 과제의 주요 기능 |1. Text Emotion Recognition <br> - 일상생활의 대화에 가까운 프롬프트에서 사용자의 감정을 인식한다.<br> <br> 2. Text tokenization & Keyphrase extraction <br> - 일상생활의 대화에 가까운 데이터도 프롬프트에 적합한 형태로 편집한다.<br><br>  3. Emotion Labels<br> - Text Emotion Recognition 모델로 인식한 감정 라벨을 강조한다.<br> - 이를 위해 고안한 여러 방법 중 감정 라벨을 prepend하고, 감정 라벨의 동의어 중 중요도가 높은 3개를 append하여 강조하는 방식을 채택한다.<br><br>  4. Style modifiers<br> - 추출한 감정과 관련된 스타일 키워드를 자동으로 추가한다. <br> <br> 5. 최종 프롬피릿의 루브릭<br> - 다양한 유즈케이스를 커버할 수 있기 때문에 사용자의 발화 그 자체 또한 프롬프트로 활용될 수 있으며, trial-and-error를 방지할 수 있으므로 이미지 생성 AI 기술의 사용 장벽을 낮추었다.<br> - 이미지의 감정 표현력과 심미성을 증진시키면서도 텍스트의 문맥 손실을 최소화하였다. |
| (8-5) 과제: 구현 방법 | 1. Text Emotion Recognition model<br> ◦ Empathetic Dialogues & Goemotions 데이터셋을 Text Emotion Recognition Model로 사용할 RoBERTa 에 학습시킨다.<br> <br> 2. Text tolenization & Keyphrase extraction (Remove stopwords & Append one key-phrase) → KeyBERT<br> ◦ stopwords를 제거하고, KeyBERT를 이용해 중요어구를 추출해 한번 더 추가한다.<br> <br> 3. Prepend emotion label & Append 3 emotion synonyms → AnglE, FAISS<br> ◦ Text Emotion Recognition 모델로 인식한 사용자 감정 label를 프롬프트 앞에 추가한다.<br> ◦ FAISS와 AnglE를 이용해 사용자 감정의 유의어 중 프롬프트와 유사도가 높은 감정 3개를 선정하고 프롬프트 뒤에 추가한다.<br> ◦ 감정 label는 앞에, 유의어는 뒤에 붙임으로써 image-emotion alignment는 높이고 image-text alignment의 loss는 최소화한다.<br> <br> 4. Append style modifiers → LLaMA-2, LangChain, RAG<br> ◦ Midjourney에서 사용되는 Style keywords and modifiers를 크롤링 해 구축한 style modifiers 리스트를 LangChain과 RAG을 사용해 LLAMA-2에 학습시키고, 리스트 중 프롬프트의 내용과 사용자 감정에 적합한 것들을 선택하게 한다.<br> ◦ 내용에 급격한 스타일 변화가 일어나는 수정자보다는, color, dimension, perspective, lighting 와 같이 이미지의 시각적 요소에 변화를 주는 수정자들을 선택해 ITA 손실은 줄이면서 Aesthetic은 높였다.<br><br> 5. 최종 프롬피릿의 루브릭: 원본 텍스트 → 감정 라벨 + 토큰화 된 텍스트 + 감정 동의어 3개 + 스타일 키워드  |
| (8-6) 과제: 세부 기술 | • CLIP: https://github.com/openai/CLIP → ITA, IEA 계산<br> • ChromaDB: https://github.com/chroma-core/chroma → LangChain RAG vector store<br> • pyTorch<br> • BERT: https://huggingface.co/docs/transformers/model_doc/bert → Text Emotion Classification (Dataset: Emphathetic Dialogues, GoEmotions)<br> • KeyBERT : https://github.com/MaartenGr/KeyBERT → key phrase extraction<br> • FAISS: https://github.com/facebookresearch/faiss → 텍스트 유사도 기반 서치<br> • LangChain: https://github.com/langchain-ai/langchain → style modifier 선정 (Dataset: Artemis)<br> • llama-2: https://huggingface.co/docs/transformers/model_doc/llama2 → style modifier 선정<br> • Stable Difussion : https://huggingface.co/stabilityai/stable-diffusion-2-1 → 이미지 생성|
| (8-7) 과제: 기대 효과 및 의의 |기대 효과<br> • 미술 치료 및 이미지를 통한 심리 치료 등 감정 표출과 이해가 중요한 분야에서 사용이 가능하다.<br> • 어린 아이 또는 자폐 스펙트럼과 같이 감정을 표현하는 데 서툰 사람들을 대상으로 감정 이해도 향상 보조에 활용 가능하다.<br> • 마케팅이나 미디어 콘텐츠 제작 시, 특정 감정을 자극하는 이미지를 생성하여 대상 audience의 관심을 끌고, 메시지의 전달력을 강화할 수 있다.<br><br>의의 <br> • 생성된 이미지의 감정 표현력과 심미성을 향상시키면서 텍스트의 맥락 손실을 최소화했다.<br> • 감정 라벨을 추가하여 image-emotion alignment에 가장 효과적인 프롬프트 편집 방법에 대한 가설을 설계하고 실험했다.<br> • 입력 텍스트에서 추출된 감정 맥락에서 해당 감정을 극대화 시키는 이미지 스타일 수식어를 고안했다.<br> ◦ 사용자(특히 비전문가)를 위한 end-to-end 프롬프트 최적화 방법을 제안한다. |
| (9) 데모 내용 |  1. Prompirit 논문 발표<br>
2. Prompirit을 이용해 엔지니어링 된 프롬프트로 이미지를 생성하는 과정 시연 |
| (10) 기타 | [References]<br> [1] Yunlong Wang, Shuyuan Shen, and Brian Y. Lim. 2023. RePrompt: Automatic Prompt Editing to Refine AI-Generative Art Towards Precise Expressions. In Proceedings of the 2023 CHI Conference on Human Factors in Computing Systems (CHI ’23), April 23–28, 2023, Hamburg, Germany. ACM, New York, NY, USA, 29 pages. https://doi.org/10.1145/3544548.3581402<br> [2] Jonas Oppenlaender. 2022. Prompt Engineering for Text-Based Generative Art. arXiv 1, 1. Retrieved from http://arxiv.org/abs/2204.13988<br> [3] Ankita Gandhi, Kinjal Adhvaryu, Soujanya Poria, Erik Cambria, Amir Hussain, Multimodal sentiment analysis: A systematic review of history, datasets, multimodal fusion methods, applications, challenges and future directions, Information Fusion, Volume 91, 2023, Pages 424-444, ISSN 1566-2535, https://doi.org/10.1016/j.inffus.2022.09.025.<br> [4] Amir Zadeh, Minghai Chen, Soujanya Poria, Erik Cambria, and Louis-Philippe Morency. 2017. Tensor Fusion Network for Multimodal Sentiment Analysis. In Proceedings of the 2017 Conference on Empirical Methods in Natural Language Processing, pages 1103–1114, Copenhagen, Denmark. Association for Computational Linguistics.<br> [5] Andrea Scarantino. 2017. How to Do Things with Emotional Expressions: The Theory of Affective Pragmatics. Psychological Inquiry 28, 2–3: 165–185. https://doi.org/10.1080/1047840X.2017.1328951 |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-19
| (1) 과제명 | 캣치타임: 효율적인 시간 관리를 돕는 타이머 기반 모바일 육성 게임
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 19-TMM |
| (3) 팀원 역할 분담 | 이가연(2176241) : 게임 시나리오 작성, 아이디어 개발, 기본 UI 구성 및 디자인, 프로그램 개발<br>한서연(2071052) : 그래픽 리소스 제작, 데이터베이스 관리, 프로그램 개발<br>이자영(1971037) : 그래픽 리소스 제작, 프로그램 개발, 프로젝트 자료 정리 |
| (4) 팀 지도교수 | 최병주 |
| (5) 팀 멘토 | 채윤호 / 나이트앤비숍 / 대표이사 |
| (6) 과제 키워드(keywords) | 타이머, 시간 관리, 캐릭터 육성 게임 |
| (7) 과제 내용 요약 | 일에 집중하지 못해 시간을 어영부영 소비하는 2-30대를 위해 게임성으로 동기를 부여하여 시간 관리를 돕는 모바일 2D 캐릭터 육성 게임 어플리케이션입니다. 게임 내의 타이머 기능을 작동시키면 휴대폰 제한 모드가 켜져 업무 시간에 일, 또는 공부에 온전히 집중할 수 있고, 일과 휴식 시간을 구분함으로써 각각의 시간을 효율적으로 사용할 수 있도록 시간 관리를 돕습니다. 동시에 계획 이행에 대한 보상으로 자신만의 귀여운 동물 마을을 꾸밀 수 있어 시간 관리를 일종의 오락으로 만듭니다. |
| (8-1) 과제: 문제의 정의 | 많은 20, 30대가 업무 및 공부를 비롯하여 해야 할 일에 의욕을 느끼거나 집중하지 못한다. 또한 일과 휴식 간의 구분을 확실히 하지 못하고 업무 시간과 휴식 시간이 혼재되게 내버려 두어 효율적인 시간 관리에 실패하는 경우가 비일비재하다. 이로 인해 결국 소요 시간 대비 생산 효율성이 저하되는 문제가 증가하고 있다. |
| (8-2) 과제: 기존연구와의 비교 | Habitica: 투두리스트를 체크해 경험치를 쌓아 캐릭터를 육성하고, 펫이나 탈 것을 모을 수 있는 게임. 데일리 루틴이나 뽀모도로 챌린지 등을 할 수 있다. 그러나 한국어 지원이 되지 않고 사용자가 일을 하지 않았음에도 임의로 리스트를 체크할 수 있다는 약점이 있다.<br>열품타: 타이머를 켜둔 동안 휴대폰으로 딴짓을 하려고 하면 타이머를 중지해 시간에 집계되지 않게 만든 시간 관리 어플. 다른 사용자들과 스터디그룹을 만들 수 있고, 백색소음이나 영단어, 뽀모도로 기능 등을 제공한다. 그러나 스스로의 의지가 없다면 동기부여가 되지 않는다는 약점이 있다.<br>Focus To-Do: 뽀모도로 타이머와 스케줄 관리 기능을 제공하는 앱. 제한모드(핸드폰 뒤집기, 앱 종료 금지)로 강제성을 부여하고 백색소음 기능으로 집중력 향상에 도움을 준다. 업무 달성에 따른 보상을 모아 나무를 키울 수 있는 미니 게임을 통해 성취감을 얻을 수 있다. 그러나 나무가 성장하는 것 외에 다른 스토리성이 없어 흥미를 느끼지 못할 수 있다. |
| (8-3) 과제: 제안 내용 | 간단한 조작으로 시간을 효율적으로 관리할 수 있고, 성공적인 시간 관리에 대한 보상으로 캐릭터를 꾸미는 등 개인의 취향을 담아 커스텀할 수 있는 서비스를 제공함으로써, 이를 이용한 효율적인 시간 관리를 통해 작업 능률, 속도 등을 향상시켜 생산 효율성을 높일 수 있는 동기를 부여하고자 한다.<br><br><br>1. 타이머 + 휴대폰 제한모드 기능으로 사용자가 설정한 시간 동안 강제적으로 휴대폰을 하지 못하도록 한다.<br>2. 타이머로 설정한 시간이 지나면 제한모드가 풀리고, 시간 관리에 대한 보상으로 게임 재화를 지급한다.<br>3. 지급된 재화로 아이템을 구매하여 캐릭터를 꾸미고 성장시킨다.<br>4. 이때 재화는 오로지 타이머 기능을 사용했을 때만 지급함으로써, 업무보다 게임 자체에 시간을 더 많이 쓰는 주객전도 상황을 막는다.<br><br><br>이러한 기능을 바탕으로 기존의 비슷한 어플리케이션과 같이 사용자의 시간 관리를 도우면서도, 사용자가 업무/공부를 지속할 동기를 부여하여 효율적인 시간 관리가 계속되도록 한다. |
| (8-4) 과제: 과제의 주요 기능 | - 타이머 기능<br>- 보상 지급, 업적 기능, 상점 기능, 친구 기능, 리포트 기능<br>- 휴대폰 제한모드<br>- 보상 지급, 업적 기능, 상점 기능, 그래픽 <br>- 기본 기능: 설정, 선물함, 아이템 보관함<br><br>서버: Photon - 유니티와 연동이 잘 되어 있음<br>디바이스: 안드로이드<br>게임엔진: Unity<br>데베: MySQL |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-20
| (1) 과제명 | 식재료 관리를 통한 1인 가구의 식비 절감 지원 웹앱 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 20-쿠킹마마 |
| (3) 팀원 역할 분담 | 최예은(1971053) 팀장, AI 파트 담당<br>송지민(2076214) 팀원, 디자인, 프론트엔드 담당<br>차소연(2076404) 팀원, 백엔드 담당 |
| (4) 팀 지도교수 | 심재형 교수님 |
| (5) 팀 멘토 | 박한 / Deeply / CTO |
| (6) 과제 키워드(keywords) | 요리, 식비 절감, 식재료 |
| (7) 과제 내용 요약 | 쿡세이브는 비싼 외식비, 배달비가 부담 되지만 아직 요리에는 서툴고, 냉장고 속 식재료는 금방 상해 폐기하는 경우가 많은 초보 자취생들에게 ‘AI를 통한 간편한 식재료 등록’, ‘레시피 추천’, ‘식비 절감 통계’, ‘AI 챗봇 쿠쿠’ 를 제공하여 요리 해먹기를 바탕으로 식비 절감을 돕는 하이브리드 앱 서비스입니다. |
| (8-1) 과제: 문제의 정의 | 문제1. 1인 가구의 경우 대량으로 구매한 식재료를 기한 내에 소비하지 못해 식재료가 상해서 낭비하게 되는 경우가 많습니다. 또한, 20대 1인 가구의 경우 1인 식생활이 익숙치 않아 레시피나 재료 보관방법 등을 자주 검색해보곤합니다. 따라서 보유하고 있는 식재료를 쉽게 파악할 수 있고, 1인 가구의 식생활을 지원하는 통합적인 서비스가 필요합니다. <br>문제2. 물가 상승으로 1인 가구의 식비 부담은 점점 커지는 추세입니다. 이러한 상황에서 사용자가 효과적으로 식비를 조절할 수 있도록 식비 관리를 집중적으로 지원하는 서비스가 필요합니다.<br>문제3. 유용한 서비스라 해도 서비스를 사용할 때 거쳐야 하는 과정이 번거로우면 지속적으로 이용하기 어렵습니다. 의식주 중 하나인 식생활과 관련된 서비스는 사용자에게 이용의 편리함을 제공하여야 합니다. 따라서 1인 가구의 식생활 및 식비 절감을 지원하는 높은 사용성의 모바일 앱 서비스가 필요합니다. |
| (8-2) 과제: 기존연구와의 비교 | 1. ‘만개의 레시피’ 웹 서비스: <br>장점 : 여러 카테고리로 구분 다양한 레시피를 제공합니다. 또한, 요리에 사용되는 물품을 구매할 수 있습니다.<br>단점 : 레시피의 영상을 조회하려면 링크를 이용해 다른 서비스를 참조해야 되어 정보를 얻는 과정이 매끄럽지 못합니다.<br><br>2. ‘유리트 주간 식단’ 앱 서비스: <br>장점: 레시피 제공이나 식비에 대한 가계부 기능을 제공해주는 서비스입니다.<br>단점: 모든 기능들이 식단 관리에 초점이 맞춰져있고 식비 절감이라는 목표로 이어지지 않습니다.  또한 식재료 및 식단 모두 사용자가 직접 입력하는 형태입니다.<br><br>3. ‘레시피 냉장고’ 앱 서비스:<br>장점: 다른 사용자들과 레시피를 공유할 수 있는 커뮤니티 기능을 제공합니다. <br>단점: 식재료를 제공받은 카테고리 내에서 직접 입력 등록해야 합니다. 식재료별 가격 선택이 불가합니다. 레시피 추천이 보유한 식재료를 바탕으로 이루어지지 않습니다. 레시피마다 보유한 재료와 필요한 재료를 구분해서 보여주는 것 외의 요리 내역 저장 기능은 없습니다.<br><br>4. ‘거꾸로 레시피’ 앱 서비스: <br>장점: 식재료의 수량과 가격을 입력 받지 않으므로 식재료 등록에 소요되는 시간이 짧습니다. 식재료별 소비 기한을 자동으로 설정하고 알림을 제공합니다. 레시피 목록을 제공합니다. 레시피 북마크가 가능합니다.<br>단점: 식재료별 수량, 가격 선택이 불가합니다. 식재료의 가격을 등록하지 않으므로 비용 관련 내용을 확인할 수 없습니다.  사용자가 가진 식재료를 바탕으로 한 레시피 추천 기능이 없습니다.<br><br>5. ‘Pantry - 물건 유통기한관리’ 앱 서비스: <br>장점: 개인 냉장고 폴더를 만들어 물건의 바코드를 스캔하여 물건 및 재료 등록을 합니다. 등록한 재료를 바탕으로 한 아이템 검색 기능이 있습니다. 재료 리스트를 유통기한 순으로 정렬하여 조회할 수 있습니다. 유통기한 1일, 3일, 7일 전 알림 기능을 제공합니다. <br>단점: 바코드 스캔으로 물건을 등록할 경우 상품 이름만 자동으로 입력되고 이미지, 유통기한, 수량 등의 정보는 직접 입력해야 합니다. 재료의 가격을 선택할 수 없습니다. 유통기한 관리 기능 외의 다른 기능은 없습니다.<br><br>결론 : 위의 5가지 웹 및 앱 서비스를 분석한 결과, 식비 절감을 목표로 하여 통계를 제공하는 서비스가 부재함을 확인했습니다. 아래 다섯 가지 서비스 모두 식재료 등록 과정에서 식재료의 가격을 입력 받지 않으므로 식비 관련 내용은 확인이 불가하여 1인 가구의 식비 부담 문제에 대한 해결책이 될 수 없다고 판단했습니다. 또한 기존 서비스들은 가진 재료를 바탕으로 한 레시피 추천이 이루어지지 않아 식재료의 빠르고 적절한 소비를 도울 수 없으며, 제공되는 레시피 이외에는 자유로운 재료 선택이 불가합니다. 또, 대체적으로 레시피 선택 완료 후 식재료의 수량이 자동 차감되는 기능이 없어 단순히 레시피를 조회하는데에 그치는 경우가 대부분입니다. |
| (8-3) 과제: 제안 내용 | 문제1. 번거로운 식재료 등록 과정<br>⇒ Object Detection과 OCR 기술을 활용하여 카메라 렌즈로 식재료를 촬영하거나 주문내역 캡처본 및 영수증 촬영으로 식재료의 자동 등록이 가능하도록 했습니다. 이는 식재료 등록에 소요되는 시간을 줄이고 사용자가 스스로 텍스트를 입력하는 번거로움을 줄여 서비스의 사용성을 증대시킵니다. 이 방법의 경우 기술의 정확도에 따라 등록이 제대로 이루어지지 않을 수 있다는 단점이 있으나, 이를 보완하기 위해 사용자가 식재료의 정보를 부분적으로 수정할 수 있도록 개발을 진행했습니다.<br><br>문제2. 제한적인 레시피 추천<br>⇒ 기존 서비스의 경우, 데이터베이스에 등록되어있는 레시피 이외에는 추천이 불가능한 점을 ‘AI 챗봇 쿠쿠’를 도입하여 해결했습니다. AI가 제공하는 답변을 통해 선택지의 확장이 가능합니다. 또, 레시피 뿐만 아니라 식재료의 소비기한이나 보관방법 등 다양한 식재료 관련 사용자의 궁금증을 해결할 수 있도록 지원합니다. 뿐만 아니라 사용자가 제공되는 레시피 이외에도 원하는 재료를 직접 선택하여 레시피를 생성하는 기능 또한 제공하여 서비스 사용에 제한이 없도록 개발했습니다.<br><br>문제3. 비가시적인 식비 절감 효과<br>⇒ 기존 서비스는 서비스의 사용을 바탕으로 얼마 만큼의 식비를 절감했는지 그 내역을 제공하지 않습니다. 쿡세이브는 ‘예산 설정’, ‘월별 통계 제공’, ‘요리 내역 저장’을 통해 사용자들이 절감한 식비를 한눈에 파악할 수 있도록 하여 식비 절감 및 서비스 사용의 동기부여를 제공합니다. 뿐만 아니라, 레시피 선택 시에 자동으로 사용자가 선택한 식재료의 수량 만큼의 가격이 계산되고 저장되므로 사용자는 번거로운 계산 과정을 거칠 필요가 없습니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. Object detection 및 OCR 기술을 통한 간편한 식재료 등록 <br>2. 등록한 식재료를 바탕으로 레시피를 추천<br>3. 레시피 선택 시 사용되는 식재료의 수량 자동 차감 및 비용 자동 계산<br>4. 식비 절감 내역 및 요리 히스토리를 보여주는 월별 통계 제공<br>5. 1인 가구의 식생활을 돕기 위한 정보를 제공하는 AI 챗봇<br>6. 서비스 사용 리마인드를 위한 푸시 알림 제공 |
| (8-5) 과제: 구현 방법 | 4-1. 디자인 <br>Figma를 활용하여 와이어프레임을 기반으로 모바일 뷰를 기본으로한 UI/UX 디자인을 완성했습니다. <br><br> 4-2. 프론트엔드<br> React.js와 Typescript를 이용하여 클라이언트단을 개발했습니다. 이때, 스타일링 라이브러리로는 styled-components를 활용하여 완성된 디자인을 바탕으로 퍼블리싱을 진행했습니다. 서버와의 http 통신은 axios 라이브러리를 통해 연결하여 실제 데이터를 화면에 연동했습니다. 추가로, Recoil을 활용하여 전역 상 태 관리를 하여 서비스의 완성도 및 효율성을 확보했습니다. 완성된 웹은 안드로이드 웹 뷰와 프로그레시브 웹앱을 통해 하이브 리드앱으로 변환했습니다. <br><br>4-3.백엔드 <br>Spring Boot 프레임워크를 이용하여 API를 구현한 후 AWS를 이용해 서버에 배포합니다. 로드밸런서로 웹 사이트에 https로 보안 접속이 가능하게 만듭니다. OCR API를 이용하는 기능은 프론트로부터 전달 받은 데이터와 함께 OCR 서버에 요청을 보낸 후 받은 응답을 프론트로 전달하도록 구현합니다. AI 모델은 API 와는 다른 별개의 서버를 구축해 배포합니다.<br><br> 4-4. AI <br> Pytorch를 사용하여 전체적인 AI 서버(flask 서버)를 개발합니다. 식재료 사진 인식에서 사용할 오브젝트 디텍션 파트에선 Yolo 버전8을 사용하기로 결정하였으며 학습 및 테스트를 tencent cloud의 tesla T4 GPU를 활용하여 진행합니다. 제작한 Flask API는 Gunicorn, uWSGI, Nginx를 연결하여 배포합니다. 영수증 인식에서 사용할 OCR 기술은 Naver Clova OCR API를 사용합니다. <br><br> 4-5 ChatBot <br> 챗봇 기능에는 Open AI의 GPT 3.5 Turbo 모델을 이용했습니다. 백엔드를 거치지 않고 프론트에서 바로 API 연결을 진행했으며 Recoil-persist 라이브러리를 이용하여 localStorage에 채팅 내역이 저장되도록 했습니다. |
| (8-6) 과제: 세부 기술 | 메인 기능인 Object Detection을 통한 식재료 등록에 사용된 세부 기술 및 프로세스는 다음과 같습니다.<br>1. 프론트에서 사용자가 사진을 입력합니다. (갤러리에서 사진 첨부 또는 촬영) <br>2. 입력한 사진은 http post 요청으로 AI의 yolo모델에 전달됩니다. <br>3. AI 파트는 yolo 모델의 인식 결과를 JSON의 형태로 프론트에 반환합니다. <br>4. 사용자는 반환된 인식 결과를 확인한 후 등록 완료를 눌러 http Post 요청을 통해 백엔드로 등록 내용을 전달합니다. <br>5. 백엔드는 받은 요청을 바탕으로 DB에 식재료를 저장합니다.|
| (8-7) 과제: 기대 효과 및 의의 | 1. 1인 가구는 쿡세이브를 통해 냉장고 속 식재료를 원활하게 관리할 수 있습니다.<br>2. 쿡 세이브는 사용자들이 가진 재료를 바탕으로 요리를 하도록 유도하기 때문에 식비 절감을 이끌어 냅니다. <br> 3. 사용자들은 자신의 식비 절감 통계 내역을 확인하여 예산 내의 합리적인 소비를 이어갈 수 있습니다. <br> 4. 배달과 외식이 아닌 직접 요리해먹는 습관은 식비 절감 뿐만 아니라 건강한 식습관 개선으로 이어질 수도 있다는 점에서도 의의를 갖습니다. |
| (9) 데모 내용 |1. 회원 가입한 정보로 서비스에 로그인합니다. <br>2. 재료의 정보를 직접 입력하여 등록합니다.<br>3. 사물 인식 기술을 이용해 재료를 인식한 후 그 결과를 이용해 재료를 등록합니다.<br>4. 재료의 수량, 아이콘 정보를 수정합니다.<br>5. 레시피 목록에서 요리할 레시피를 선택합니다.<br>6. 레시피 목록에서 특정 레시피를 북마크하고 북마크 레시피를 모아봅니다.<br>7. 요리에 사용할 재료를 선택합니다.<br>8. 사용한 재료와 레시피 정보를 요리 내역에서 확인합니다.<br>9. 요리 내역에 대한 통계를 확인합니다.<br>10. 한달 예산을 수정합니다.<br>11. 챗봇에 질문하고 응답을 받습니다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-21
| (1) 과제명 | 일기장 속 친구 :감정 이해와 조언의 동반자 PSYLOG
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 21-AtoB |
| (3) 팀원 역할 분담 | 오윤재(2171030): 리더, 프론트엔드, 서버 배포<br>윤주영(2171034): 백엔드, AI, 서버 배포<br>신다영(1976202): 백엔드, AI, 서버 배포 |
| (4) 팀 지도교수 | 윤명국 |
| (5) 팀 멘토 | 박성규/ Pango-Gy/ Software Engineer |
| (6) 과제 키워드(keywords) | 일기, 감정분석, 공감 |
| (7) 과제 내용 요약 | Psylog는 OpenAI의 fine tuning 기술을 활용해 사용자의 일기를 상담사 관점에서 깊이 이해하고 이에 대한 조언 및 공감을 제공합니다.<br><br> 또한, SKTBrain의 kobert를 사용하여 단순히 글을 읽는 것을 넘어, 사용자의 감정을 세심하게 분석하고, 하루 동안의 감정 분포를 시각적으로 나타내는 그래프를 통해 자신의 심리 상태를 한눈에 파악할 수 있도록 도와줍니다. 이를 통해 사용자는 자신의 감정 변화를 이해하고, 긍정적인 정신 건강을 유지하는 데 필요한 지원을 받을 수 있습니다. |
| (8-1) 과제: 문제의 정의 | 많은 사람들은 사회적 압력, 편견, 자신이 처한 환경 때문에 자신의 감정을 억누르거나 숨기게 됩니다. 감정을 솔직히 털어놓지 못하는 것은 스트레스를 유발하고 이는 정신 건강 문제로 이어지게 됩니다. <br><br>이러한 문제점을 해결하고자 자신의 속마음을 솔직히 털어놓고 공감 및 조언을 받고 싶은 현대인들을 타겟 사용자로 하여 PSYLog 사용자들이 타인에게 쉽게 털어놓을 수 없는 이야기를 해당 서비스를 통해 털어놓고 이에 대한 공감 및 조언을 제공하고자 합니다. |
| (8-2) 과제: 기존연구와의 비교 | 1) 일반 다이어리 서비스 : 기존의 다이어리 서비스들은 단순히 사용자가 작성한 일기를 저장하고 추후에 이를 다시 볼 수 있는 기능을 제공합니다. 이런 기존 서비스들과 달리 PSYLog는 사용자의 일기장 속 친구가 되어 사용자가 작성한 일기를 저장할 뿐만 아니라 이를 분석하여 사용자의 하루에 공감해주며 도움이 될 수 있는 조언을 제공합니다.<br> <br>2) 심리 상담 AI 챗봇 : 감정 문제 해결을 위한 대화형 챗봇 서비스들은 사용자들과의 상호작용을 통해 공감 등의 반응을 즉각적으로 제공해주는 서비스입니다. 이러한 단순 대화형 챗봇과는 달리 PSYLog는 사용자의 일기를 통해 개개인의 전체적인 상황을 파악하여 감정 상태를 분석하기 때문에 더욱 심층적인 조언을 제공할 수 있습니다. 또한, 일기 작성을 통해 사용자들은 자세한 감정 표현을 할 수 있고, 이를 통해 더욱 정확하고 유의미한 분석을 제공할 수 있습니다.  |
| (8-3) 과제: 제안 내용 | 사용자가 자신의 감정이 어떠한 상태인지 파악하기 위해 사용자의 일기를 prompt로 사용하고, 학습된 모델을 통해 공감과 조언을 output으로 생성합니다. 이렇게 생성된 output은 해당 일기의 mysql 부분의 ai-answer부분으로 저장이 되고, 이 답변은 작성한 일기를 클릭하면 하단에 보여줍니다. <br><br>4) 감정 그래프 제공 기능 : FastAPI를 통해 구현된 Kobert를 이용하여 해당 글에 대하여 감정 분석 결과를 진행함. 각 6개의 감정의 퍼센트를 mysql에 저장하고, 그 결과를 해당 일기 보는 화면에서 그래프화하여 보여줍니다.  |
| (8-4) 과제: 과제의 주요 기능 | 1) 일기 작성 및 수정 : 기본 일기 다이어리 기능과 동일 <br> 2) 일기 모아보기 : 기본 일기 다이어리 기능과 동일 <br> 3) 일기에 대한 공감 및 조언 제공 : OpenAI사의 gpt-3.5 fine tuning 기술을 이용해 사용자의 일기를 prompt로 받고, 공감 및 조언을 output으로 받아 사용자에게 그 결과를 제공합니다.  <br>4) 감정 그래프 제공 화면 : Kobert 자연어 처리 모델을 이용하여 사용자의 일기를 분석하고 해당 결과를 토대로 감정분석 그래프 (6가지 감정의 분포도)를 도출합니다.  |
| (8-5) 과제: 구현 방법 | 1) Front-End : Html, CSS, JavaScript를 이용하여 작성했습니다. 사용자가 작성한 일기를 화면에 보여줘야 하는데, 이러한 동적으로 변하는 화면을 구성하기 위해 thymeleaf를 사용하여, 동적으로 바뀌는 부분에 대한 처리를 했습니다. <br><br> 2) Back-End : Spring boot를 사용하여 구현했습니다. Spring boot의 JPA를 사용하여 Mysql과 연동해놓았습니다. 또한 여기에서 AI 와 프로젝트의 연결을 진행했고, AWS와 Docker을 이용하여 CI/CD구축을 했습니다.<br><br> 3) AI : OpenAI사의 gpt-3.5 fine tuning : 심리상담사가 갖춰야 할 덕목, user가 쓸 수 있는 일기의 예시, 그 일기에 대한 공감 및 조언 글로 이루어진 dataset.jsonl을 직접 작성했고, 그걸 이용해 fine tuning을 시켜 공감 및 조언을 제공하게끔 학습시켰습니다.  <br> SKTBrain의 Kobert : AIhub에서 제공하는 한국인이 작성한 글 dataset들을 받아 학습시켰습니다. 이때 Spring boot를 back-end로 사용중이라 FastApi를 이용하여 api를 작성했습니다.  |
| (8-6) 과제: 세부 기술 | 1. 일기 작성 및 수정 기능 : 사용자는 자신의 일상, 생각, 감정 등을 자유롭게 기록할 수 있습니다. 이렇게 작성한 글들을 mysql에 저장하게 됩니다. HTML, CSS, JavaScript를 이용해 사용자 인터페이스를 구현하고, thymeleaf를 사용하여 사용자마다 서버 사이드에서 생성된 데이터를 동적으로 화면에 반영합니다. <br><br> 2. 일기 모아보기 기능 : 사용자는 자신이 작성한 일기를 모아볼 수 있으며, 캘린더 형식으로 날짜별로 일기를 확인할 수 있습니다. 이 기능 또한 HTML, CSS, JavaScript로 구성되어 있으며, 사용자의 편의성을 위해 직관적인 디자인을 적용했습니다.  <br><br>   3. 일기에 대한 공감 및 조언 제공 기능 : OpenAI의 GPT-3.5를 fine tuning하여 사용자의 일기 내용을 분석하고, 공감과 조언을 제공합니다. 사용자의 일기를 prompt로 사용하고, 학습된 모델을 통해 공감과 조언을 output으로 생성합니다. 이 output을 mysql에 저장하여 작성한 글을 볼 때, 하단에서 확인할 수 있습니다.<br><br>    4. 감정 그래프 제공 기능 : FastAPI를 통해 구현된 Kobert를 이용하여 해당 글에 대하여 감정 분석 결과를 진행함. 각 6개의 감정의 퍼센트를 mysql에 저장하고, 그 결과를 해당 일기 보는 화면에서 그래프화하여 보여줍니다. |
| (8-7) 과제: 기대 효과 및 의의 |  1. 개인 맞춤형 정신 건강 지원: 사용자의 일기를 분석하여 제공하는 개인화된 공감과 조언은 사용자가 자신의 감정과 생각을 더 깊이 이해하도록 돕습니다. 이는 사용자에게 맞춤형 정신 건강 지원을 제공하는 효과적인 방법이 될 수 있습니다.<br><br>2. 정신 건강 문제 예방 및 해결: 사회적 압력이나 편견으로 인해 감정을 억누르는 것은 스트레스와 정신 건강 문제를 유발할 수 있습니다. PSYLog를 통해 이러한 감정을 안전하게 표현하고 이해함으로써, 정신 건강 문제를 예방하고 해결하는 데 도움이 될 수 있습니다.<br><br>3. 감정 인식의 향상: 사용자의 일기를 분석하여 감정 그래프를 제공함으로써, 사용자는 자신의 감정 변화를 시각적으로 파악할 수 있습니다. 이는 사용자가 자신의 감정을 더 잘 인식하고 관리하는 데 도움을 줄 수 있습니다.  |
| (9) 데모 내용 | 미리 생성해둔 계정으로 로그인을 해서 들어가면, 홈 화면에 캘린더와 최근 일기가 보입니다. 캘린더에는 그날 대표 감정이 표시될거고, 최근 일기는 최근에 작성된 일기 5개를 보여줍니다. 위에 있는 일기작성 버튼을 누르면 일기를 작성할 수 있습니다. 글을 등록과 동시에 공감 및 조언 글이 생성됩니다. 이렇게 등록된 글을 확인하기 위해 들어가보면, 작성한 글과, 그에 대한 공감 및 조언 글을 확인 할 수 있습니다. 그래프는 KOBERT를 이용하여 구현하였고, 해당 글에 대한 감정 분포 결과를 보여줍니다. |
| (10) 기타 | . |

 
[Return TOP](#list-of-teamsprojects)
 
# Team-22
| (1) 과제명 | Fairy Tairy : 동화같은 그림을 자동으로 생성해주는 AI 일기 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 22-쓰리박 |
| (3) 팀원 역할 분담 | 박은주(2028014) : 리더, AI, 프론트엔드<br>박민경(2117016): 프론트엔, 백엔드, 데이터베이스 관리, 서버 배포<br>박윤서(2171086): 프론트엔드, 백엔드 |
| (4) 팀 지도교수 | 민동보 |
| (5) 팀 멘토 | 강수남 / 모두의주차장 / 대표 |
| (6) 과제 키워드(keywords) | 자기 표현 글쓰기, 감정과 상황의 공감각화, 사회적 연결감 형성 |
| (7) 과제 내용 요약 | 바쁘게 살아가는 현대사회 속에서 자신의 하루를 되짚어 볼 여유가 없는 현대인들은 스트레스 관리에 취약합니다. <br>따라서 그들은 일기를 통해 자신의 하루를 기록함으로써 자신의 감정이나 생각을 정리하며 스트레스를 해소하곤 합니다.<br>저희는 그들이 보다 흥미롭게 일상 기록을 할 수 있도록  일기를 쓰면 코멘트와 함께 동화 같은 그림 일기를 자동으로 그려주는 서비스를 제공하고자 합니다.  |
| (8-1) 과제: 문제의 정의 | 적당한 스트레스는 일상생활에 도움이 되기도 하지만, 과도한 스트레스는 일상생활에 지장을 주며, 정신 건강을 해치는 요인이 된다.통계청에 따르면 2022년 11월 기준 우리나라 국민의 약 45퍼센트가 일상생활 전반에 걸쳐 스트레스를 느낀다 인지한다 답했다. 한편 코로나 이후 MZ세대의 새로운 건강 관리 트렌드로 헬시 플레저 트렌드가 자리잡고 있다. 이는 규칙적인 일상생활 속 루틴을 통해 신체 건강과, 그의 연장선 상으로 멘탈관리까지 하고자 하는 건강 관리 방법이다. 이런 이유로 20대의 경우 멘탈 관리를 위해 전문가의 도움을 받고 싶다 응답한 비율은 전체의 70퍼센트에 해당될 정도로 스트레스 관리와 멘탈 건강을 챙기는 것에 적극적이지만, 실제 관련 서비스를 받은 인원은 약 6퍼센트에 불과하다. 그 이유로 여전한 사회적 편견이 큰 역할을 하고 있으며, 추가적으로 일반 진료보다 초진 비용과 상담 비용이 높아 경제력이 약한 20대에게 부담이 된다는 점 역시 크게 작용하고 있다. 이런 점에서 질환이 되기 전 스트레스를 관리할 수 있도록 하는 예방적 관점의 중요성이 크다 |
| (8-2) 과제: 기존연구와의 비교 | [관련 서비스 조사]<br>1. 오늘 하루를 그려줘<br>pros: 사용자가 하루의 기분에 대한 키워드를 선택해 하루의 감정을 한눈에 볼 수 있게 한다.<br>cons: 생성 그림은 내용과 관계 없이 키워드만으로 결정되며 단순 일기 작성과 그림 생성 이외의 다른 기능이 없다.<br>2. Reflectly<br>pros: 질문을 통해 사용자의 하루 기분 파악. 사진 업로드 가능. 하루 activity, feeling에 대한 키워드를 수집. 하루의 기분에 대한 up/down 추이를 그래프로 보여줌.<br>cons: 직관적이지 않은 UI, 개인화 서비스 및 커뮤니티 기능이 존재하지 않아 서비스 사용 동기 상실<br>3. 무드 메모<br>pros: 사진 업로드 가능. 한 눈에 사용자의 mood를 주 단위로 확인할 수 있음<br>cons: 짧은 메모를 통해 일기를 생성하므로 내용이 한정적. 사용자가 기록하지 않은 부분에 대해서 임의로 채워 넣는 할루시네이션 발생함.<br>4. Headspace<br>pros: monthly/weekly checin 시스템을 통해 사용자의 스트레스와 분노 정도를 분석, tracking한다. 아침, 점심, 저녁, 수면 시간에 맞는 간단한 명상, 음악 컨텐츠를 추천하여 스트레스 관리를 돕는데 중점을 두고 있음. 명상 테마를 다양하게 구성하여 course를 따라갈 수 있도록 함.<br>cons: daily 서비스 없음. 개인화 서비스 없음.<br><br>[키파인딩과 인사이트]<br>글쓰기: 사용자가 직접 쓰는 일기를 통한 자기 표현적 글쓰기 유도. 스트레스 완화를 위한 일차적인 방법으로 자기 표현적 글쓰기를 유도하는 방식이 실제로 많이 사용되며, 효과적인 방식임을 알 수 있음.<br>개인화: 사용자에 따라 알맞는 서비스를 제공할 필요가 있음. course제공 보다는 개인의 경험(일기)에 집중하여 스트레스 완화 수단을 제공하는 방식이 필요해보임<br>시각화: 한달 혹은 한 주의 mood를 시각적으로 바로 확인할 수 있어야 함. 일기의 경우 비정형화된 형식이므로, 글 보다는 그림이나 다른 방식으로 한 눈에 간편하게 기록을 확인할 수 있도록 해야함.<br>커뮤니티: 소셜 서비스를 통하여 개인의 경험을 자유롭게 공유할 수 있도록 하는 서비스가 없음 |
| (8-3) 과제: 제안 내용 | 위와 같은 문제를 해결하기 위해 일기 작성을 통한 사용자의 자기 표현적 글쓰기를 유도하여 스트레스를 스스로 완화 할 수 있도록 유도하는 서비스를 제공한다. 일기 내용을 통해 감정 키워드를 얻고 응원 문구를 생성한다. 얻은 키워드를 바탕으로 사용자의 감정에 맞는 음악 추천 재생. 또한 사회적 연결감 형성을 위해 커뮤니티 기능을 통해 일상 공유를 가능케 한다. |
| (8-4) 과제: 과제의 주요 기능 | 동화같은 그림 생성 : Diffusion Model을 활용하여 사용자가 작성한 일기를 기반으로 그림 일기를 생성해줍니다.<br><br>코멘트 생성 : KoGPT2모델을 활용하여 사용자가 작성한 일기 내용에 대한 코멘트를 달아줍니다. <br><br>감정 기반 음악 추천 : KoBERT모델을 통하여 다중 감정 분류를 진행한 결과를 <br>기반으로 사용자 감정과 유사한 음악을 추천해줍니다. <br><br>일기 공유 : 우리는 종종 우리의 경험을 다른 사람들과 공유하고 싶어한다. 이에 사용자로 하여금 선택적으로 일기를 공유하게 함으로써 서로의 감정과 경험을 공유하며 더 깊은 이해와 연결을 형성하고자 한다. |
| (8-5) 과제: 구현 방법 | [**사용자 감정 기반 음악 추천**]<br>1. 가사에 대한 감정 분석을 진행.<br>2. KoBERT모델에서 추출된 노래 별 감정을 이용하여 사용자의 감정과 가장 유사한 노래를 추천<br>3. 일기 작성 후 사용자 감정 값이 추출이 되면, 노래 영상 별 감정 값과 결합한 뒤 새로운 코사인 유사도를 계산<br>4. 사용자 감정 값과 유사도가 가장 큰 값으로 정렬<br>5. 가장 큰 값의 인덱스와 가장 유사한 노래 4개로 다시 추출하고, 해당 인덱스의 노래 리스트를 결과로 반환 <br>6. 총 5개의 음악 추천 ⇒ 사용자 감정과 가장 유사한 음악 1곡 + 그 음악과 유사한 음악4곡을 추천<br><br>[**프롬프트 엔지니어링**]<br>0. 이미지 생성을 잘 수행해주는 커스텀 프롬프트를 제작하여 해당 프롬프트를 ChatGPT에게 넘겨줌 <br>1. 사용자 일기를 (0번에서 학습된)ChatGPT에게 넘겨줌 →  ChatGPT가 사용자 일기를 기반으로 하는 프롬프트 3개를 생성해줌 (아래와 같이)<br>2. 1번에서 생성된 프롬프트 뒤에, 별개의 프롬프트(트리거 워드)를 붙여서 최종 프롬프트 완성(필요시 , negative prompt 설정) <br>[예시 프롬프트]<br>: (Oil Painting), (Impressionism), oil painting with brushstrokes, bichu,Park stroll:1.4, joyful atmosphere:1.3, laughter-filled time, playful dogs:1.3, vibrant park scene, cheerful interactions, happy pet owners, heartwarming moments, vibrant community vibes <br>3. (파인튜닝한) Diffusion에 프롬프트를 넘겨 이미지 생성<br><br>[**이미지 화풍 변환**]<br>1. CustomDataset 생성 : oil pastel, oil canvas느낌의 데이터셋<br>- BLIP 모델을 활용하여 img2txt 진행 >> (img,txt)쌍의 데이터셋으로 커스텀<br>2. 커스텀 데이터셋을 가지고 FineTuning을 진행한다.<br>3. 이때, LoRA기법을 활용하여 Diffusion 모델에 대해서 화풍 학습시킨다.|
| (8-6) 과제: 세부 기술 | [**사용자 일기 다중 감정 분석**]<br>사용 모델 : KoBERT<br>Dataset : https://aihub.or.kr/aihubdata/data/view.do?currMenu=&topMenu=&aihubDataSe=data&dataSetSn=86<br>많은 BERT 모델 중에서도 KoBERT를 사용한 이유는 "한국어"에 대해 많은 사전 학습이 이루어져 있고, 감정을 분석할 때, 긍정과 부정만으로 분류하는 것이 아닌 다중 분류가 가능한 것이 강점 존재한다. 따라서, 이러한 이유로 KoBERT 모델을 최종 모델로 선택을 하였고, 모델 구조 Customizing 및 FineTuning을 진행하였다.<br>![image](https://github.com/Three-Park/Crayola-Dreams/assets/79118751/20fa1c9b-106c-4ef6-bde7-15164dcdd014) <br><br>[**일기 기반 자동 코멘트 생성**]<br>사용 모델 : KoGPT2<br>Dataset : https://github.com/songys/Chatbot_data <br>KoGPT2 모델은 문장을 "생성"해내는 모델이다. 따라서 일기 내용에 대한 코멘트를 달도록 구현하기 위해 입력 받은 내용에 대해 위로하거나 공감하거나 부드러운 표현으로 반응하고 문장을 생성해내도록 FineTuning을 진행하였다.<br>![image](https://github.com/Three-Park/Crayola-Dreams/assets/79118751/c98495e2-2f9b-4f54-8d83-af7d3f07b0e8)<br><br> [**이미지 화풍 학습**]<br> 사용 모델 : StableDiffusion-v1-5<br>Dataset : https://www.kaggle.com/datasets/herbulaneum/oil-painting-images <br> -해당 데이터셋을 가지고 Img2Text을 수행하여 직접 Custom을 진행하였다. <br> 스테이블 디퓨전 모델은 기본적인 모델을 가지고 있음. (기본 모델은 인터넷에 퍼져 있는 이미지로 학습) 그래서 어떤 스타일인지 알 수가 없다. 타일의 그림을 그릴 것인지는 그 스타일에 맞는 학습모델이 있어야 한다. 이런 학습모델을 CHECKPOINT라고 하고 SAFETENSORS와 CKPT 파일로 제공한다. 해당 서비스에서는 유화와 같은 그림체에 좀 더 편향되게끔 하기 위해서 LoRA를 통해 학습시켰다. <br>- LoRA: 특정 피사체를 좀 더 편향되게 생성할 수 있게 해줌<br>- checkpoint: 이미지 장르, 그림체 같이 넓은 범위에 대한 설정을 위해 사용<br>```prompt : (masterpiece, best quality, ultra detailed), Oil Painting, Impressionism, oil painting with brush strokes, bichu,Park stroll, joyful atmosphere, laughter-filled time, playful dogs, vibrant park scene, cheerful interactions, happy pet owners, heartwarming moments, vibrant community vibes```<br>![image](https://github.com/Three-Park/Fairy-Taiary/assets/79118751/9a774225-5bbc-4622-8a74-6daa7a4e7e0c) |
| (8-7) 과제: 기대 효과 및 의의 |사용자는 일기 작성을 통해 자기 표현적 글쓰기가 가능해진다. 이를 통해 자신의 경험과 생각을 정리하여 자기 인식을 높이고, 인지 재구조화를 가능하게 하여 스트레스를 해소할 수 있게 한다. 또한 일기를 기반으로 생성된 그림은 일상 생활에서 추상적으로 느끼는 감정을 시각적으로 파악할 수 있도록 하여 사용자가 스스로의 감정을 이해할 수 있도록 돕고, 자신의 상황과 감정에 대한 패턴을 발견할 수 있도록 돕는다. 이는 사용자의 스트레스 해소를 통해 예방적 관점에서 정신건강 관리 및 개선에 도움을 줄 수 있을 것이다. |
| (9) 데모 내용 | 1. 일기 내용 작성 시 글의 내용에 적절한 감정과 추천 음악이 결과로 출력된다.<br>2. 그림의 경우 프롬포트를 이용하여 그림 생성 결과까지는 확인하였으나 프론트엔드와 연결은 진행중에 있다.<br>3. 달력 페이지 구현에 성공하였으며, 달력의 해당 날짜에 등록된 일기들이 표시되는 모습까지 구현하였다. |
| (10) 기타 |![image](https://github.com/Three-Park/Fairy-Taiary/assets/79118751/7cda6b7c-841c-476b-9f0e-e2bdca658099)<br>프론트로는 리액트네이티브, 백엔드로는 장고와 넥스트js를 사용하였고, DB로는 mysql과 s3를 사용하였다.<br>**ReactNative** : 컴포넌트 기반의 UI 라이브러리로써, vuejs보다는 높은 자율성을 가지며, 풍성한 생태계를 가지고 있다는 점에서 선택<br>**Django** : MTV 아키텍처를 기반으로 하여 코드의 재사용성이 높고, 손쉽게 인증을 구현할 수 있어 선택<br>**nextjs** : 서버사이드 렌더링을 지원하기 위해서, 빌드 시간을 단축시키고, 빌드된 파일을 캐싱하여 빠른 로딩을 지원하기 위해서 사용<br>**s3** : 이미지 생성 서버와 연결하여 이미지 데이터 저장을 위해 사용<br>**DB** : DB로는 Mysql을 사용하였는데, Mysql은 관계형 데이터베이스로, 데이터를 구조화하여 효율적으로 저장하고 검색하기 위해 선택 <br>**AI** : GPU가 필요한 AI모델의 경우 GCP VM 을 사용하였다. 백엔드에서 일기 내용을 전달하며, 이미지 생성 모델은 이미지를 생성하고 url을 응답하도록 하였다. 또한, 음악 추천모델과 감정분석 모델은 추천과 분류 결과를 응답으로 반환하게끔 구현하였다.|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-23
| (1) 과제명 | Stroke-based Collaborative Drawing between AI and Human
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 23-새우타코 |
| (3) 팀원 역할 분담 | 윤지원(2071032): 팀원, Image completion, UI 개발 (Human and AI interaction)<br>정세윤(2076371): 팀원, Image completion, Stroke Ordering<br>남지민(2176123): 리더, Image completion, Image classification |
| (4) 팀 지도교수 | 김영준 교수님 |
| (5) 팀 멘토 | 조민애 / Microsoft / CSA |
| (6) 과제 키워드(keywords) | 협업, drawing, human-like |
| (7) 과제 내용 요약 | Stroke-based Collaborative Drawing between AI and Human은 사람이 그림을 그리면 image completion을 학습한 AI가 다음 획을 예측한 다음 뒤를 이어 미완성된 그림의 일부를 완성합니다. <br>실제 사람이 그리는 것과 비슷한 방식으로 그림을 그리도록 학습된 AI와 사람이 번갈아가며 그림을 그리며 사람과 AI가 협업하여 그림을 완성하게 하는 것을 목표로 합니다. |
| (8-1) 과제: 문제의 정의 | 현재 AI를 통해 물체를 백지상태에서 그리는 것과, 완성되지 않은 그림을 이어 그리는 연구는 활발히 진행되고 있습니다. 하지만 AI 혼자서 그린 그림에는 얼마나의 가치가 있을까요? 또한 미완성된 상태의 그림을 완성할 때 어떻게 해야 사람의 의도대로 그릴 수 있을까요? 저희는 AI와 사람이 협업하게 함으로써 사람의 의도와 창의성이 반영된, 보다 나은 그림을 완성할 수 있도록 하는 연구를 진행하고자 합니다.  |
| (8-2) 과제: 기존연구와의 비교 | 이 문제에 대한 선행 연구는 존재하지 않습니다. 하지만 기존에 존재하지 않았던 방향으로 AI와 인간과 협업이 가능하다는 것을 보이고자 합니다. 이를 구현하기 위해서 두가지 연구를 참고했는데, 이 연구를 위해 필요한 핵심 기술으로는 image completion과 stroke generation이 있습니다.<br> 1. Image Completion : SketchHealer: A Graph-to-Sequence Network for Recreating Partial Human Sketches <br> 해당 연구는 주어진 그림의 일부분을 가려서 masking 된 부분의 그림을 채워서 그리는 모델을 학습시켰습니다. 하지만 그림을 가리는 비율이 높아질 수록 output으로 나오는 그림의 완성도가 떨어지는 문제점이 있습니다. 특히 이 비율이 50% 이상이 되면 evaluation의 의미가 없어질 정도로 그림을 알아보기 어려워집니다. 또한 인간이 그리던 그림을 완성시키는 것이 아닌 랜덤한 masking을 통해 학습했기 때문에 사람이 그림을 그리는 방식과는 동떨어진 채로, 그림을 완성시키는 것에만 기능이 집중되어 있습니다.<br> 저희의 연구는 Sketch Healer의 단점들을 보완할 것 입니다. 50%이상 masking(그림을 가린다는 의미)을 할 경우에도 높은 성능으로 그림을 완성할 것이며, 사람이 그림을 그리는 방식으로 인공지능과 인간이 협업하게 할 것입니다. 이 때, 사람이 그림을 그리는 방식이란, 사람처럼 그림을 그린다는 의미로, 무작위로 그리는 것이 아닌, 일정한 규칙에 따라 그림을 그리는 것을 의미합니다. 저희는 사람이 마지막으로 펜을 뗀 곳과 가장 가까운 곳으로 부터 그림을 그리며, human-like drawing을 구현하고자 합니다. <br> 2.  Image to Stroke converter : Content Masked Loss: Human-Like Brush Stroke Planning in a Reinforcement Learning Painting Agent <br> Content Masked Loss는 사진이나 그림을 획 기반 그림으로 재구성하는 AI 모델으로, 강화학습을 통해 사람이 그림을 그리는 방식처럼 획의 순서를 정하도록 학습되었습니다. 하지만 직접 그림을 그리거나, 그려진 그림의 일부분을 완성하는 것이 아니라 기존에 완성된 이미지를 획 기반으로 재구성하는 모델입니다. 저희는 Content Masked Loss의 단점인 그림을 완성하지 못한다는 점을 개선할 것입니다. 구체적으로,  인간과 인공지능이 함께 사람처럼 그림을 그림으로써, Content Masked Loss의 장점은 보존하고 단점은 개선할 것입니다. |
| (8-3) 과제: 제안 내용 | 기존의 ai-drawing과 관련된 모든 연구들은 사람과의 상호작용을 염두에 두지 않고 있습니다. 나아가, 이미지를 완성시킬 수 있는 연구들은, 사람처럼 그리지 못한다는 단점이 존재합니다. 획을 기반으로 그림을 완성하는 연구들은, 그림을 재구성할 뿐, 그림을 완성시키지는 못합니다. 또한, 이미지가 50%이상 가려질 경우, 이미지가 성공적으로 완성되지 못하는 문제점이 있었습니다. (여기서 성공적이지 못하다는 의미는 이미지 분류 모델을 통해 제대로 분류가 되지 않는 것을 의미합니다.) <br> 위 문제를 해결하기 위해  Stroke-based Collaborative Drawing between Robot(AI) and Human이라는 연구 주제를 제안하는 바입니다. <br> 저희는, Image completion 모델을 이용하여 해당 모델이 중간 중간 사람의 입력(사람이 그림의 일부를 그려주는 것)을 받는 협업 과정을 통해 보다 높은 수준의 그림을 완성할 수 있도록 개선하고자 합니다. 높은 수준의 그림이란, 초반 masking의 정도와 상관없이(처음에 사람이 전체 그림의 몇 %를 그렸는지와 상관없이) 이미지를 완성할 수 있는 것을 의미합니다. 또한 생성된 획 중 일부분을 선택하는 과정에서 Stroke Ordering 알고리즘(사람이 마지막으로 그린 점과 가장 가까운 획을 선택하는 알고리즘)을 이용하여, 인공지능 모델이 그리는 그림이 human-like할 수 있도록 하고자 합니다.<br> 성공적인 연구를 판단하기 위하여 두가지 evaluation point(평가 방법)을 제안합니다.<br>첫째, masking의 정도(사람이 입력으로 전체 그림의 몇%를 그렸는지)와 관계없이 높은 수준의 그림이 완성되는지 확인할 것입니다. masking의 정도를 10%, 20% 부터 90%까지 분포시키며, 그림의 완성도를 판단할 것입니다. 이 때 그림의 완성도는 이미지 분류 모델에 넣어 제대로 판단하는지 정확도를 확인할 것 입니다. <br>둘째, 최종적으로 완성된 그림이 원래 사람의 의도와 얼마나 일치하는지 확인할 것입니다. 이 과정에서 이미지 분류 모델을 활용하여 인공지능이 그림이 제대로 인식하는지 확인할 것입니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 사람이 그린 획을 잘 인식 가능하고 전처리 하기 위한 UI<br> 2. UI에서 모델로 데이터를 넘겨주기 위한 연결 기능<br> 3. 그림의 일부분을 사람처럼 그리며 이미지를 완성하는 모델(Image Completion Model)<br> 4. 완성된 이미지의 획 중 획 중요도를 예측하여 선택하는 기능(Stroke Ordering Algorithm) |
| (8-5) 과제: 구현 방법 | 전체적인 시스템 흐름은 다음과 같습니다. <br> 우선, 사람이 임의의 한 획 및 몇 개의 획을 UI에 그립니다. (이 때, 획의 길이나 획이 그림에서 차지하는 비중은 프로젝트의 완성과 무관하여 아무렇게나 그리면 됩니다.) 사람의 획을 인식한 UI가 모델에게 데이터를 넘겨줍니다. 이 때, 모델이 넘겨받은 데이터를 통해 어떤 그림인지 사용자의 의도를 파악하고, 파악한 의도를 바탕으로 그림이 덜 그려진 부분 중 일부를 완성합니다. 이 과정에서 이미지 완성 기술이 적용됩니다. 그 결과를 다시 UI에게 전해주고, 화면에 나타난 일부 완성본을 사람이 전달받아, 또 일부분의 그림을 사람이 완성합니다. 이런 과정의 반복을 통해 사람과 인공지능이 협업합니다. ![system workflow](https://github.com/JiWon0502/demo_1st/assets/10348029/d5d90ed8-125b-4215-a646-06fdc89b944d) <br> 상호작용할 수 있는 매개체로 자체 UI를 개발함으로써, 획 단위로 입출력을 가능하게 하여 AI와 인간의 협동이 용이하게 만듭니다. UI를 구현하기 위해서는 python의 기본 패키지인 tkinter를 사용할 것입니다. tkinter란, 버튼 등의 그래픽 기능을 제공해주는 그래픽 유저 인터페이스 모듈입니다. tkinter 모듈을 이용하여 기초적인 창 및 버튼을 구현할 것입니다. 나아가, 저희가 사용할 데이터셋(Google Quick, Draw)과 같은 형식을 유지하여주기 위해 RDP알고리즘을 사용하여 사람이 그린 획을 전처리할 것입니다. RDP 알고리즘이란, 선형 단순화 알고리즘으로, 특징점을 제외한 일부분을 제거하여 형태를 단순화 하는 알고리즘입니다. <br> 이미지를 완성할 수 있는 AI모델을 구현하기 위해 Sketch Healer보다 성능이 개선된 Lmser pix2seq를 사용할 것입니다. Lmser pix2seq 모델은 encoder-decoder 모델을 기반으로 합니다. 여기서 encoder란, 입력된 정보의 중요한 부분만을 압축하는 역할을 하고, decoder는 encoder에서 넘겨받은 input을 바탕으로 중요한 정보를 재구성하는 것을 의미합니다. 즉, 중요한 정보만으로 구성되게 압축하고 이를 재구성함으로, image completion의 성능을 높입니다. 해당 모델을 기초로 삼아 이미지를 완성하는 기능을 구현할 것입니다. 또한, 저희의 프로젝트에 맞게 모델을 수정해야하는데 특히, 사람의 개입이 들어갈 수 있도록 모델을 바꿀 것이며, 결과 형식도 그림이 아닌 획의 위치를 나타내는 형식으로 바꿔 구현할 것입니다. (획의 위치를 나타낸 다는 것은 (x, y)형식으로 나타내는 것을 의미합니다.) |
| (8-6) 과제: 세부 기술 | <br> 1. UI에 필요한 기술 <br> - UI에 필요한 요구사항은 UI를 구성할 화면 구성요소가 필요합니다. 나아가, 요구사항에서 설명한 것과 같이, RDP 알고리즘을 사용해 획을 전처리 해야하며, 전처리 된 획을 .npz파일로 저장할 수 있어야합니다. 이런 요구사항을 만족시키기 위해 아래의 기술들이 필요합니다.<br> - UI 인터페이스의 화면 구성을 위해서는 tkinter 모듈이 필요합니다. tkinter 모듈이란, 버튼 등의 그래픽 기능을 제공해주는 그래픽 유저 인터페이스 모듈입니다. tkinter 모듈에서 사용할 기능은  canvas 만들기 (기본 화면 생성), 그린 그림을 인식하는 기능, 그림의 좌표 확인 기능, 그림을 저장하는 기능, 그림을 불러오는 기능이 필요합니다. <br> - UI 인터페이스를 통해 사람이 그린 획을 Quick, Draw! 데이터셋과 같은 형식으로 전처리해야합니다. 그 이유는, AI 모델에 학습된 데이터셋이 구글의 Quick, Draw! 이기 때문입니다. (dataset에 대한 그림 및 정의는 요구사항 정의에 나타나있습니다.)  전처리 과정에서 필요한 기술은 RDP알고리즘입니다. (RDP알고리즘은 요구사항 정의에 설명되어있습니다.) <br> - 전처리된 획을 저장하기 위해서, .npz파일로 저장하는 기술이 필요합니다. (npz파일 형식이 무엇인지는 요구사항 정의에 설명되어있습니다.) 이를 구현하기 위해서는 numpy 기술이 필요합니다.<br> <br> 2. AI 모델에 필요한 기술 <br> - 입력으로 들어온 이미지가 어떤 이미지인지 분류하는 기술이 필요합니다. 여기서 사용된 이미지 분류 기술은 이미지를 학습시킬 때, 목표하는 이미지의 분포에 따라 loss(오차) 값을 계산하도록 하여, 입력된 vector들이 각 클래스 별로(eg. banana, airplane, apple) 모일 수 있도록 모델이 구현되었습니다. <br> - 사용자 의도를 알아낸 모델이, 의도에 맞게 획을 기반으로 한 그림의 전체를 완성하는 기술이 필요합니다. 이 때, 구체적으로 사용된 기술은 image completion(이미지 완성)기술입니다. 모델을 구성하는 과정에서 Lmser Block을 encoder로 사용하고 RNN-decoder를 사용했습니다. Encoder란, 입력 데이터를 받아 일정한 규칙 혹은 알고리즘에 따라 압축된 형태로 표현합니다. 이 과정에서 데이터의 필수적인 정보를 보존하며, 보통 처리하기 용이하거나 압축된 형태로 만드는 모델을 encoder라합니다. 그 중에서 Lmser encoder란, 인코딩 과정에서 데이터의 재구성의 최소 평균 제곱 오차(Minimum Mean Square Error, 실제 값과 예측된 값 사이의 오차의 제곱 평균, MMSE = min E[ (X̂ - X)^2] )를 최소화하는 것을 목표로하는 encoder를 의미합니다. 반대로, decoder란, encoder가 변환한 데이터를 원래의 형태나 다른 유용한 형태로 복원하는 역할을 하는 모델입니다. RNN Decoder는 RNN을 사용하여 데이터를 복원하는 모델입니다. 여기서 RNN이란, 순환 신경망의 약자로, 과거의 정보를 순차적으로 기억하면서 시퀀스 데이터(text, 시퀀스 데이터)를 처리하는 데 특화된 신경망 구조입니다. <br> - 사용자가 마지막으로 그린 부분과 가장 거리가 가까운 순서대로 획을 정렬하는 기술이 필요합니다. 우선 거리를 측정하기 위해서는 유클리드 거리를 이용합니다. 유클리드 거리를 측정하는 방법은 다음과 같습니다. A(x1, y1)과 B(x2, y2)가 존재할 때, AB사이의 거리는  sqrt((x2 - x1)^2 + (y2 - y1)^2)의 식을 이용하여 도출합니다. A, B에 해당하는 점은, npz파일 형식으로 저장이 되었기 때문에, 코드로 구현 가능합니다. (각 stroke 별로 (x, y, penstate)를 저장했기 때문입니다.) 측정된 거리를 바탕으로 가장 가까운 순서대로 sort 알고리즘을 적용합니다. <br> - 정렬된 획을 기준으로 가장 가까운 획 하나를 선택하는 기술이 필요합니다. 앞에서 유클리드 거리를 측정하고, 이를 가까운 순서대로 정리하였기 때문에, 거리가 가장 가까운 획을 선택하는 기술은 minimum 함수를 이용해 용이하게 수행할 수 있습니다. (minimum 함수란, 거리를 인자로 하여 거리의 최소 값을 골라, 해당하는 값을 가진 점을 반환하는 함수 입니다.) <br> - 선택된 획을 .npz 파일 형식으로 저장하는 기술이 필요합니다. (npz파일 형식이 무엇인지는 요구사항 정의에 설명되어있습니다.) 이 때, 저장을 위해서는 numpy 기술이 필요합니다. |
| (8-7) 과제: 기대 효과 및 의의 | 기존에 존재하지 않던 독창적인 방법으로 인간과 인공지능의 collaboration을 미술 부분에 접목합니다. 또한 기존에 없었던 사람과 인공지능의 상호작용을 염두해 둔 최초의 ai-drawing연구가 될 것입니다. 나아가, 일정 수준 이상 이미지가 가려질 경우 성공적으로 그림을 완성하지 못한다는 인공지능의 한계를 인간의 개입을 통해 해결하고, 완성되는 그림의 완성도를 증진시키는 것이 주 목적입니다. 추가로 인공지능이 그림을 그림에 있어, 좀 더 인간과 유사한 방식으로 그림을 그릴 수 있도록 하려 합니다. |
| (9) 데모 내용 | 1) 연구자가 n개의 획으로 그림을 그리고 버튼을 누른다.<br>2) RDP알고리즘(선형단순화알고리즘)으로 전처리된 그림을 화면에 출력한다.<br>3) 버튼을 누르면 Image Completion 모델이 n개의 획을 추가한다. <br>4) 1~3을 반복해서 그림을 완성하는 과정을 데모하고, 완성 시 종료 버튼을 누른다.<br>5) 완성된 그림과 완성까지 이르는 과정을 보여주고 완전히 종료한다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-24
| (1) 과제명 | Grounding Dino를 활용한 객체 탐지 기반 CCTV 속 흉기 난동 상황 모니터링 SDK
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 24-망고젤리 |
| (3) 팀원 역할 분담 | 류성경(2076122): 리더, 데모용 어플리케이션 프론트엔드 개발, 클라우드 컴퓨팅 환경 구성<br>박나희(1994046): 팀원, Grounding DINO 파인튜닝, Fast API 맵핑, SDK 위치추적 기능 구현 <br>김리나(2176046): 팀원, 데모용 어플리케이션 백엔드 개발, SDK 알림 기능 구현 |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 이다은 / 카카오브레인 / Software Engineer |
| (6) 과제 키워드(keywords) | 흉기 감지, 보편성, 실시간 |
| (7) 과제 내용 요약 | CCTV 관리자가 볼 수 있는 Web 환경에서 값비싼 고성능 카메라 영상이 아닌, 보편적으로 사용하고 있는 CCTV의 저화질 영상에 대해 Grounding Dino를 이용한 실시간 객체 탐지 기술을 기반으로 환경을 모니터링하고 흉기 난동 발생 여부를 판단한다. 그 결과 사용자 위치 주변에서 흉기 난동이 발생했다면 사용자 기기의 APP에 알림을 보내주는 위치 탐색 기능과 알림 전송 기능을 포함한 SDK를 개발한다.<br><br>(현재 해당 과제에서 흉기는 칼, 망치로 정의해놓았으며, 추후 범위를 넓힐 예정이다.)  |
| (8-1) 과제: 문제의 정의 | 1. 사람이 발견 후 신고<br>일상 생활에서 흉기 난동 사건 발생 시, 사람이 직접 발견하고 신고하지 않는 이상 빠르게 대처하기 힘들며, 사람이 발견하고 신고하였을 때에는 이미 상황이 크게 진척되어 피해자가 여럿 발생한 경우가 많다. <br><br> 2. 경찰 인력 배치<br>경찰 인력 배치를 통해 현장을 경비하는 방법은 시민에게 위화감을 조성하고, 많은 시간과 비용이 발생한다.<br><br> 3. 고가의 PTZ 카메라<br> 고성능 카메라(e.g.PTZ 카메라) 설치를 통해 흉기를 감지하거나 AI 모델을 올리기 위해 기타 고성능 카메라로 CCTV 기기를 교체하기도 하는데, 카메라 자체도 고가일 뿐 아니라 별도의 하드웨어 장치도 필요하여 보편적으로 쓰이기는 어려운 실정이다. |
| (8-2) 과제: 기존연구와의 비교 | 1. PTZ CCTV 카메라와 같은 고화질 카메라에 한해서만 제공되는 솔루션<br>기존 시장에는 피사체를 자동 추적하는 PTZ 카메라(Pan Tilt Zoom 카메라, 원격으로 회전, 줌 조정이 가능한 카메라)를 활용해 흉기 소지를 확인해 위험 상황을 알려 주는 솔루션이 존재한다.<br><br>강점 : PTZ 카메라는 배회하는 사람의 신원을 확인할 수 있을 정도로 줌을 확대해 추적하기 때문에 정확히 손에 들고 있는 소지품이 흉기인지 여부를 확인할 수 있을 정도로 고화질의 데이터를 제공한다.<br>단점 :일반적으로 실내에서 보편적으로 사용하는 CCTV인 돔카메라에 비해 약 15배의 가격으로 매우 고가이며, 성능 좋은 추가적인 하드웨어 장치가 추가적으로 필요하기 때문에 PTZ 카메라에 대해 제공되는 솔루션은 보편적으로 적용할 할 수 없다고 판단했다.<br>(참고 기사 : https://www.boannews.com/media/view.asp?idx=122013)<br><br>2. AI 솔루션을 사용하기 위해 CCTV를 교체하고 있는 상황<br>하단 영상은 수원시에서 폐쇄 회로 CCTV를 지능형으로 전환해 인공지능(AI) 기반으로 흉기 난동을 판단하고 있다는 내용이다. 이 경우를 포함해 많은 객체 탐지 기반 솔루션들이 CCTV를 더 나은 기기로 교체하고, 그 위에 개발한 모델을 올리는 것을 문제 해결 방법으로 채택하고 있다.<br><br>강점 : 이 경우 CCTV 자체를 더 좋은 모델로 바꾸는 것이기에 고화질의 데이터로 조금 더 정확한 탐지가 가능하다는 장점이 있다.<br>단점 : 하지만 기존에 존재하는 CCTV를 고가의 CCTV 장비로 바꾸는 것은 상당한 비용이 추가되기에 보편적으로 적용될 수 있는 솔루션이라고 보기 어렵다고 판단했다.<br>(참고 기사 :https://www.youtube.com/watch?v=ZxMkZJGaRFE) |
| (8-3) 과제: 제안 내용 | PTZ 카메라 같은 특수한 장치가 있지 않더라도 저화질 일반 CCTV 영상에서 Object Detection 기술을 통해 흉기 난동 사건 의심 정황을 탐지할 수 있는 솔루션을 제안한다. 이 과정에서 아직 프로덕션 레벨에서는 쓰인 적이 없는 최신의 Object Detection 모델인 Grounding Dino를 도입해 볼 예정이며, 저화질 영상 데이터에서 이상 상황을 빠르고 정확하게 탐지하는 것을 우선적인 목표로 개발을 진행할 예정이다. 다만, 품질이 좋지 않은 데이터로 인해 부정확한 결과가 도출된다면 자칫 공권력의 낭비와 안전 불감증으로 이어질 수 있음을 인지하고 있다. 이 지점에 유의하여 먼저 공공 데이터를 타겟으로 해당 기술을 적용한 이후, 점차 실시간 CCTV로 적용 범위를 확대할 예정이다.<br>1. SDK 사용<br>SDK(Software Development Kit - 개발자를 위한 플랫폼별 구축 도구 세트) 형태로 개발을 할 예정이므로, 이를 사용하여 기존 CCTV 시스템에 간편하게 적용 가능하며, 불필요한 하드웨어 투자 없이 흉기 난동 및 안전 상황을 모니터링할 수 있다.<br>2. 사용자 위치 정보 기반 푸시 알림<br>사용자의 위치 정보를 활용하여 가까운 곳에서 흉기 난동 상황 발생시 사용자에게 푸시 알림을 보내고 신속하게 대응할 수 있다.<br><br><br>SDK 타겟층 <br>: 실시간 CCTV 데이터를 갖고 있고, 흉기난동 예방에 관심을 갖는 기관 (ex. 경찰, 지하철공사 등)<br><br>a. CCTV 관리자 및 기관 입장<br>흉기 난동 사건 발생을 더 빨리 지각할 수 있으며, 빠른 대처가 가능하다.<br>b. 일반 시민 입장<br>푸시 알림을 통해 실시간으로 빠르게 주변 흉기난동 발생 여부를 알고 이에 대처하여 안전 확보가 가능하다 |
| (8-4) 과제: 과제의 주요 기능 | 저화질 영상에 대해 실시간 흉기 난동 상황 탐지 및 알림 제공 <br><br>1. 흉기 난동 상황 탐지를 위한 모델 파인튜닝 및 REST API 개발 <br>2. 사용자의 위치 정보를 받아, 해당 위치 주변에서 흉기 난동 상황이 탐지 되었을 때 푸쉬알람을 보내는 API 개발<br>3. 해당 API를 이용하기 위한 SDK 인터페이스 개발<br>4. 우리의 SDK를 이용한 웹 데모 서비스 개발 |
| (8-5) 과제: 구현 방법 | 1. 모델 서버 - 흉기난동 탐지 : Grounding Dino<br>- 기존에 자주 쓰이는 Yolo 모델이 아닌 Grounding Dino를 활용하여 객체 탐지를 진행한다.<br>- Zero-shot Detection을 통해 기존에 학습된 데이터셋 없이도 객체 탐지를 할 수 있고, 맥락을 통한 판단이 가능하다는 특징이 있는 Grounding Dino를 파인튜닝 및 파라미터 조정하여 실시간 CCTV 영상에 대해 객체 탐지를 진행한다.<br>- 흉기 모음 데이터셋과 흉기난동과 유사한 영상을 Grounding Dino에 학습시키고, 이를 Fast API로 래핑하고 Spring API와 연결하여 프로덕션 레벨에서 사용하려 한다.<br>- 이렇게 만들어진 FAST API는 API 서버에 흉기난동이 발생했는지 안했는지 여부를 전송하여 흉기난동 발생을 알리는 시발점의 역할을 한다.<br><br>2. API 서버 : Spring Boot<br>- Spring Boot를 사용하여 Back-end 서버를 구축한다.<br>- 구축된 Back-end 서버가 모델 서버로부터 흉기난동 발생 여부에 대한 response를 받으면 이를 Web client(3번)에게 보내고, web client에서 푸시 알림 요청을 받으면 모바일 client로 푸시 알림 트리거를 보내 해당 푸시 알림을 본 사용자가 빠르게 상황에 대피할 수 있도록 한다.<br><br>3. (Peace Watcher SDK를 적용한) Web 어플리케이션 (CCTV 관리자용) : Next.js, Typescript<br>- Next.js를 이용하여 CCTV 관리자용 Web 프로그램을 개발한다.<br>- REST API를 이용하여 API 서버와 통신하여 흉기난동 여부 정보를 받고, 실시간 CCTV 영상 객체 탐지 Output를 받아 영상을 스트리밍하기 위해 모델 서버와 통신한다.<br>- 소켓 프로그래밍을 통해 Web client는 소켓을 계속 열어두고 실시간으로 모델 API에서 들어오는 영상 Output을 화면에 스트리밍한다.<br><br>4. (Peace Watcher SDK를 적용한) 모바일 어플리케이션 (사용자용) : React.js를 이용한 Progressive Web App, Typescript<br>- 해당 서비스는 공익적인 B2B 서비스로 고안했기에, 모바일 어플리케이션은 해당 솔루션을 구매한 기관의 모바일 어플리케이션이라고 할 수 있다. (ex. 경찰에서 운영하는 안정 Dream 어플리케이션 등)<br>- 빠른 구현을 위해 웹앱(Progressive Web App)으로 어플리케이션을 개발한다.<br><br>5. 기타 인프라<br>- AWS EC2 : Spring API 서버를 AWS EC2를 통해 배포한다.<br>- Heroku CLI : Grounding Dino 모델의 FAST API 어플리케이션을 배포한다.<br>- Google Colab : Grounding Dino 파라미터 조정 및 튜닝에 이용한다.<br>- FCM (Firebase Cloud Messaging) : 모바일 어플리케이션의 푸시 알림을 구현한다.<br>- Vercel : Web 어플리케이션 및 모바일 어플리케이션을 배포한다.|
| (8-6) 과제: 세부 기술 | 1. 흉기 감지 (object detection)<br><br>사용 기술 : <br>- Grounding Dino, Python<br><br>기술 적용 가능성 검증 :<br>Grounding Dino는 Zero-Shot Object Detection을 수행하기 위한 기술이며, 학습 데이터에 해당 클래스에 대한 레이블이 없는 상태에서 새로운 클래스에 대해 모델이 작동하는 능력을 의미한다. 일반적으로 Object Detection은 학습된 모델을 사용하여 annotated된 데이터에 대한 탐지를 수행하지만, Grounding Dino와 같은 Zero-Shot Object Detection 모델은 새로운 클래스에 대한 annotated 데이터가 없어도 객체 탐지가 가능하다. 이 모델을 흉기를 감지하는 데에 사용하고 있으며, 파인튜닝을 통해 모델의 정확도를 높일 수 있다. 또한 파라미터 조정을 통해 흉기를 보다 효과적으로 탐지할 수 있다.<br><br>2. 데모 웹 / 앱<br><br>사용 기술 :<br>- 프론트엔드 : Typescript, React.js, Next.js<br>- 백엔드 : Java, Spring boot<br>- 인프라 : AWS EC2, Heroku CLI, Google Colab, FCM, Vercel<br><br>기술 적용 가능성 검증 :<br>- 웹 프론트엔드 : Typescript와 React.js를 사용하여 CCTV 관리자가 사용할 데모 웹 페이지를 개발한다. 이를 통해 흉기가 감지되었을 경우 팝업 창을 띄우며, 앱 사용자들에게 푸시 알림을 보낼지 수동으로 선택한다.<br>- 앱 프론트엔드 : Typescript와 Next.js를 사용하여 일반 사용자가 사용할 Progressive Web App을 개발한다. 이를 통해 현재 위치를 기반으로 CCTV 장소의 2km 이내에 있을 경우 푸시 알림을 전송한다.<br>- 백엔드 : Java와 Spring Boot를 사용하여 백엔드 서버를 개발한다. 이를 통해 흉기가 감지되어 웹 프론트엔드로부터 알림을 받을 경우, 앱 프론트엔드와 통신하여 어플리케이션 사용자에게 알림을 주는 기능을 개발한다.<br>- AWS EC2 : Spring API 서버를 AWS EC2를 통해 배포한다.<br>- Heroku CLI : Grounding Dino 모델의 FAST API 어플리케이션을 배포한다.<br>- Google Colab : Grounding Dino 파라미터 조정 및 튜닝에 이용한다.<br>- FCM (Firebase Cloud Messaging) : 모바일 어플리케이션의 푸시 알림을 구현한다.<br>- Vercel : Web 어플리케이션 및 모바일 어플리케이션을 배포한다.|
| (8-7) 과제: 기대 효과 및 의의 | 흉기 난동 상황에 대한 빠른 대응을 통해 사고 및 피해를 최소화 할 수 있으며 범죄 및 재난 상황 모니터링에 드는 비용을 절감할 수 있다.<br><br>- 유연성: SDK 형태로 제공되기 때문에 고객은 기존 CCTV 시스템에 손쉽게 통합할 수 있으며, 불필요한 하드웨어 투자 없이 흉기 난동 및 안전 상황을 모니터링할 수 있으므로 적은 비용으로 흉기 난동 모니터링의 높은 효율을 기대할 수 있다.<br>- 사용자 위치 정보 기반 푸시 알림: 사용자의 위치 정보를 활용하여 가까운 곳에서 흉기가 감지되었을 때 사용자에게 즉각적으로 알림을 제공하여 신속하게 대응할 수 있도록 하여 흉기 난동으로 인한 2차 피해를 감소하는 효과를 기대할 수 있다.|
| (9) 데모 내용 |  Peace Watcher SDK를 적용한 APP 어플리케이션 데모<br><br>1. 처음 어플에 접속한 사용자는 위치 정보 제공에 동의하고 위험 감지 알림을 허용한다.<br>2. 현재 위치로부터 반경 몇 km까지 위험 알림을 받을지 선택한다.<br>3. 어플의 메인 화면에는 현재 위치 및 반경 몇 km까지 위험 알림을 받을 수 있는지 나와있다.<br><br>Peace Watcher SDK를 적용한 CCTV 관리자 웹 데모<br><br>1. CCTV 관리자는 처음에 CCTV들을 우리의 서비스와 통합하는 과정을 거친다. CCTV 영상들을 어드민 사이트에 등록하여 CCTV의 위치, id, 실시간 영상을 연결한다. 이때, 정보처리 방침을 통해 해당 영상데이터는 전부 암호화되지만 위험 알림이 떴을 때에는 Peace Watcher SDK가 적용된 어플로 연동된다는 내용을 담는다. 단, 이 부분은 현실적으로 데모할 수 없으므로 우리의 데모는 이미 CCTV 관리자가 실시간 CCTV 영상을 우리 서비스에 연동했다는 전제에서 시작한다.<br>2. CCTV 영상이 송출되고, 위험한 상황으로 감지되었을 때 "(Peace Watcher를 적용한) 어플로 알림을 전송하시겠습니까?" Alert이 뜬다.<br>- 이때 아무것도 선택하지 않으면 10초 뒤에 자동으로 창이 닫히고, 해당 CCTV 반경 2km 내의 앱 사용자들에게 알람이 간다.<br>- 이때 알람 보내기를 클릭하면 해당 CCTV 반경 2km 내의 앱 사용자들에게 알람이 간다.<br>- 모델의 오류로 알람이 갈 만한 상황이 아닌데 Alert이 떴다면 취소 버튼을 클릭하면 알람이 가지 않는다.<br>3. 흉기난동 탐지 alert여부와 관계 없이 알림 보내기 버튼을 통해 해당 위치 반경의 사람들에게 알림을 전송하는 기능을 보여준다. (흉기난동 상황을 탐지하지 못했을 때 수동으로 알람을 보내기 위한 데모) |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-25
| (1) 과제명 | DotheReco: 스케줄 추천 및 일정 관리 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 25-S |
| (3) 팀원 역할 분담 | 이예은(2076316): 리더, 백엔드 서버 프로그래밍, 알고리즘<br>김지후(2176104):팀원, 백엔드 서버 프로그래밍, DB, AWS 인터페이스<br>전재은(2076362):팀원, UI/UX 디자인 및 프로그래밍 |
| (4) 팀 지도교수 | 윤명국 |
| (5) 팀 멘토 | 도성주 / Google Germany / Software engineer |
| (6) 과제 키워드(keywords) | 일정 처리 순서 추천, 시간대 추천, 일정 관리 |
| (7) 과제 내용 요약 | 현대 사회의 대학생들은 과제, 아르바이트 등 다양한 유형의 스케줄을 동시에 소화하고 있다. 바쁜 일정을 소화함과 동시에 스스로 일정을 관리하고 조율하기엔 큰 어려움이 있다. 따라서 본 프로젝트는 일정 관리가 어려운 대학생들을 위해 일정을 관리해 주고 최적의 스케줄을 추천해주는 것을 목표로 하고 있다. 스케줄의 마감기한, 중요도, 소요시간, 동선을 고려하여 짜여진 최적의 스케줄을 바탕으로 사용자들은 체계적으로 배치된 일정 속에서 효율적인 하루를 보낼 수 있다. |
| (8-1) 과제: 문제의 정의 | 현대 사회의 대학생들은 다양한 유형의 스케줄을 소화하고 있다. 이에 스스로 일정을 관리하고 조율해야 한다는 어려움이 있다. 본 프로젝트를 통해 해결하고자 하는 세부적인 문제점들은 다음과 같다. <br>첫째, 남는 시간들 중에 언제, 어떤 일정을 처리할지 할 일들의 처리 순서를 정하는 것이 어렵다. 둘째, 해야 할 일들 사이에 장소의 이동이 필요한 경우 동선을 짜는 것이 어렵다. 셋째, 새로운 일정을 추가할 때, 내 스케줄 중 비는 시간대가 언제인지 찾는 것이 어렵다.<br>이러한 문제를 해결하기 위해 시중에는 여러 일정관리 서비스가 존재한다. 그러나, 기존의 일정관리 서비스를 사용하는 대학생들을 대상으로 설문조사를 시행했을 때, 위의 세 가지 문제점들을 기존의 일정관리 서비스가 해결해주지 못하는 것으로 드러났다. <br>그렇기 때문에 위의 세 가지 문제점을 해결할 수 있는 일정관리 서비스를 기획했다. |
| (8-2) 과제: 기존연구와의 비교 | 기존 서비스는 (8-1)에서 제시한 첫번째 문제를 해결하기 위한 기능을 만들지 않았다. 이에 시간이 정해지지 않은 일정의 경우 사용자가 언제 처리할지 직접 정해서 입력하고 확인하는 것만 가능하다.<br>또한 기존 서비스는 (8-1)에서 제시한 두번째 문제를 해결하기 위한 기능을 만들지 않았다. 기존 일정 관리 서비스에는 동선을 추천해주는 기능은 없고 단지 장소 입력만 가능하다. <br>기존 서비스는 (8-1)에서 제시한 세번째 문제를 해결하기 위한 기능을 만들지 않았다. 일정이 없는 시간대를 따로 정리해서 알려주는 기능이 없기 때문에 사용자가 직접 일정을 확인해서 남는 시간대를 찾아내야하는 번거로움이 있다. |
| (8-3) 과제: 제안 내용 | (8-1)에서 제시한 첫 번째와 두 번째 문제를 해결하기 위해 일정 추천 기능을 해결책으로 고안했다. 사용자가 시간이 정해진 스케줄(반복스케줄 및 일반스케줄)을 입력하면 그 스케줄은 시간과 장소가 정해지지 않은 스케줄들(유동스케줄)의 처리 순서를 정하는 데에 기준이 된다. 반복스케줄 및 일반스케줄의 장소와 유동스케줄의 마감기한에 따라 남는 시간에 유동스케줄의 처리 순서가 정해진다.<br>한편, (8-1)에서 제시한 세 번째 문제를 해결하기 위해 시간대 추천 기능을 해결책으로 고안했다. 사용자가 새로운 일정을 소화하고 싶은 날짜를 선택하면 해당 날짜들에 스케줄이 없는 시간대를 리스트로 보여주어 마음에 드는 시간대를 선택할 수 있게 한다. |
| (8-4) 과제: 과제의 주요 기능 | 첫 번째 주요 기능으로는 일정 추천 기능이 있다. 사용자가 날짜나 장소를 정확하게 정하지 않은 스케줄(유동스케줄)을 입력하면 기존에 입력되어있던 사용자의 스케줄들을 바탕으로 해당 유동스케줄을 남는 시간대에 배치해준다. 이를 통해 장보기 등 마트라는 장소 키워드는 있지만, 정확한 상호명은 정하지 않은 스케줄 또한, 어떤 마트에 가서 장을 볼지도 추천받을 수 있다.<br>두 번째 주요 기능으로는 시간대 추천 기능이 있다. 이 기능은 일정과 일정 사이에 빈 시간대를 파악하여 알려준다. 사용자가 시간을 조율해야 하는 일정(ex: 팀회의 시간, 교수님과의 면담 등)이 있으면 이 기능을 사용하여 자신의 일정 중 빈 시간대를 파악할 수 있고 시간대 목록 중에서 자신이 원하는 시간대를 선택하여 그 시간에 들어갈 일정을 만들 수 있다. <br>본 프로젝트에서 제공하는 세 번째 주요 기능은 일정 관리 기능이다. 사용자는 매주 반복되는 스케줄인 반복스케줄, 시간이 정해진 스케줄인 일반스케줄, 시간과 장소가 정해지지 않은 스케줄인 유동스케줄, 그리고 기억하고 싶은 일정인 리마인더를 통해 일정을 구분하여 관리할 수 있다. 또한, 캘린더와 타임라인을 통해 일정들을 한눈에 알아볼 수 있도록 해준다. |
| (8-5) 과제: 구현 방법 | -시간대 추천 기능<br> 사용자가 일반스케줄 및 유동스케줄 추가 한 것을 db에 저장한다.<br> 사용자가 유동스케줄의 예상소요시간과 날짜를 입력하면 해당 날짜에 해당 예상소요시간만큼 남는 시간대를 기존에 입력된 일정 데이터를 기반으로(24시간-등록된 스케줄의 시간) 계산해서 빈 시간대를 프론트로 전달해 화면에서 리스트 형태로 보여준다.<br> - 추천 알고리즘<br> Rule based System으로 일정 추천 알고리즘을 고안했다.<br> 주요 용어<br> 유동스케줄 : 마감기한은 정해져있지만, 언제 처리할지 정확한 날짜나 시간은 모르는 스케줄<br> 타임블럭 : 오늘의 전체 타임라인 중 스케줄이 없는 시간대<br><br> 사용자는 유동스케줄 입력 시 예상소요시간, 마감기한, 중요도를 필수적으로 입력하고, 스케줄의 장소는 입력하지 않거나, 정확한 장소를 입력하거나, 키워드로 검색한 장소를 입력할 수 있다.<br><br> 기간이 가장 짧은 타임블럭부터 유동스케줄을 배치해준다. 타임블럭의 기간과 유동스케줄에 입력된 예상소요시간을 비교해 타임블럭보다 예상소요시간이 짧은 유동스케줄만이 타임블럭에 배치될 수 있는 유동스케줄 후보군이 된다.<br><br> 타임블럭의 경우 앞 뒤 스케줄에 입력된 장소에 따라 case가 구분된다.<br> 첫 번째 case는 타임블럭의 앞 뒤 스케줄에 입력된 장소가 동일한 경우다.<br> 두 번째 case는 타임블럭의 앞 뒤 스케줄에 입력된 장소가 상이한 경우다.<br><br> 모든 case에서는 마감기한이 오늘로 입력된 유동스케줄이 배치되고 난 후 마감기한이 오늘이 아닌 유동스케줄이 배치된다. 또한, 같은 마감기한을 가진 유동스케줄은 중요도가 높은 순으로 우선 배치된다.<br><br> 첫 번째 case의 경우 장소가 입력되지 않거나, 타임블럭의 앞 뒤 스케줄의 장소와 같은 장소가 입력된 유동스케줄을 우선적으로 배치한다. 두 가지 종류의 유동스케줄을 배치한 후에도 타임블럭이 남아있다면 키워드로 검색해서 장소를 입력한 유동스케줄과 타임블럭의 앞 뒤 스케줄의 장소와 다른 장소가 입력된 유동스케줄을 배치한다. 이때, 예상소요시간 대비 이동시간을 계산해 너무 이동시간이 긴 경우 동선 효율이 좋지 않다고 생각해 해당 타임블럭에 배치하지 않는다.<br><br> 두 번째 case는 우선적으로 배치되는 유동스케줄의 종류만 첫 번째 case와 다를 뿐 다른 처리 방식은 동일하다. 키워드로 검색해서 장소를 입력한 유동스케줄과 타임블럭의 앞 뒤 스케줄의 장소와 다른 장소가 입력된 유동스케줄이 우선적으로 배치된다. 두 가지 종류의 유동스케줄을 배치한 이후에도 타임블럭이 남아있다면 사용자가 장소를 입력하지 않은 유동스케줄이나 타임블럭의 앞 뒤 스케줄의 장소와 같은 장소가 입력된 유동스케줄을 배치한다. <br><br> 사용자가 일정을 추가할 때, 장소를 입력하는데, 이때, 카카오맵 api를 이용해서 입력한 장소를 db에 저장한다. 저장된 데이터를 바탕으로 추천 시 현재 스케줄을 배치하고자 하는 타임블럭의 앞 뒤 스케줄의 장소의 위도와 경도를 구한 후 카카오맵 api에 전달해 입력되어있는 유동스케줄들과 각각 앞 뒤 스케줄까지의 이동시간을 계산한다. 이때, 계산된 이동시간이 가장 짧은 유동스케줄을 선택해 타임블럭에 배치한다. 추가로 '카페', '올리브영' 등 키워드로만 장소를 입력할 시에는 카카오 맵 api에 키워드 자체로 데이터를 넘겨 검색하고, 검색 시 나온 결과의 장소들과 앞 뒤 장소들의 위도,경도를 바탕으로 이동시간을 계산해 구체적인 카페 및 올리브영 지점을 결정하고, 이를 일정 데이터베이스에 업데이트한다.|
| (8-6) 과제: 세부 기술 | [Frontend]<br> 역할: 사용자 인터페이스(UI)를 구현하고 사용자와의 상호작용을 담당한다.<br> 기술 스택 : HTML, CSS, JavaScript, React<br> [Backend]<br> 역할: 클라이언트로부터 요청을 받아 처리하고 데이터베이스와 상호작용한다.<br> 기술 스택 : Spring boot<br> [서버 환경]<br> 역할: 애플리케이션의 배포와 실행을 담당한다.<br> 기술 스택 : AWS EC2<br> [데이터베이스 모듈]<br> 역할: 데이터의 저장, 관리, 검색을 담당하여 애플리케이션의 데이터를 관리한다.<br> 기술스택 : MySQL<br> [보안 및 인증 모듈]<br> 역할 : 사용자 인증 및 보안 기능을 처리한다.<br> 기술 스택  : Spring Security<br> [외부 API (네이버 API, 카카오맵 API, TMAP 지도 API)]<br> 역할 : 외부 지도 서비스를 연동하여 지도 기능을 제공한다.<br> 기술 스택 : 각 지도 서비스에서 제공하는 API 및 연동 라이브러리<br><br> - 로그인 후 DB에서 사용자 정보 조회 후 로그인과 세션 유지<br> - 일반스케줄, 유동스케줄, 리마인더 추가시 DB와 화면에 반영<br> - 사용자의 정보를 바탕으로 기존에 입력된 일정 DB에서 가져와 화면에 반영<br> - 추천받은 스케줄 DB와 화면에 반영 |
| (8-7) 과제: 기대 효과 및 의의 | 최종목표 : 많은 활동을 소화하나 일정 관리가 어려운 대학생들을 위해 소요시간과 동선을 기반으로 일정을 추천하여, 보다 더 효율적으로 하루를 보낼 수 있도록 한다. 기존의 일정관리 앱 서비스 사용자들이 느꼈던 불편한 점의 90% 이상을 해결하도록 한다. |
| (9) 데모 내용 | 1) 로그인 <br>2) 더보기화면 - 취침 시간 설정 <br>3) 메인 캘린더 화면 - 일정 확인 <br>4) 시간대 추천 기능 <br>5) 일반스케줄 추가 <br>6) 유동스케줄 추가 - 장소 입력 <br>7) 메인 캘린더 화면 및 타임라인, 유동스케줄 리스트에서 추가된 일정 확인 <br>8) 일정 추천 기능 <br>9) 타임라인을 통해 추천받은 일정 확인. 메인 캘린더 화면에서 추천받은 스케줄 확인 <br>10) 지도 기능을 통한 동선 확인 <br>11) 타임라인에서 유동스케줄 완료 여부 체크시 리스트에서 확인 |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-26
| (1) 과제명 | DISLODGED :  TTS 기술을 활용한 익명 감성 위로 커뮤니티
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 26-ETT |
| (3) 팀원 역할 분담 | 최유미(2171048) : 리더, 백엔드, AI<br>남승현(2176121) :  팀원, 프론트엔드, AI<br>송민경(2176190) : 팀원, 프론트엔드, AI |
| (4) 팀 지도교수 | 민동보 |
| (5) 팀 멘토 | 이동열/카카오뱅크/AI기술팀 개발자 |
| (6) 과제 키워드(keywords) | TTS, 위로, 가상보이스 |
| (7) 과제 내용 요약 | 다양한 고민과 스트레스를 안고 살아가는 현대인들을 위해, 유저들은 GoogleTTS를 활용해 여러 보이스 요소(기본 보이스, 피치, 스피드 등)들을 직접 조절 및 조합하여 생성한 '나만의 가상보이스'로 위로를 전할 수 있습니다.  이에 따라, 위로가 필요한 유저에게 타 유저들이 남긴 위로 댓글들을 보이스로 변환 후 하나로 모아 음악처럼 들려줌으로써, 많은 사람들로부터 위로를 받고 있다는 느낌을 받게 해주는 감성 웹 서비스입니다. |
| (8-1) 과제: 문제의 정의 | 현대인들은 다양한 고민과 스트레스를 안고 살아가지만, 현실에서 이런 고민과 스트레스를 표출하는 것에 부담을 느끼기 때문에 온라인 커뮤니티에 의존하는 경우가 많습니다. 하지만 온라인 커뮤니티의 경우 텍스트로만 소통하기 때문에, 대면 소통에 비해 감정 전달이 어렵고 고립감을 느끼기 쉽다는 한계점이 존재합니다. 따라서, 현대인들은 새로운 방식의 위로와 응원이 필요합니다. |
| (8-2) 과제: 기존연구와의 비교 | Selvy Speech는 TTS기술을 활용하여 텍스트를 음성으로 변환합니다. 사용자가 피치, 스피드 조절을 하며 다양한 보이스를 생성할 수 있는 장점을 가집니다. 그러나 이 서비스는 주로 음성의 속도와 피치를 조절하는 데에 중점을 두며, 단순히 TTS 기능만을 제공한다는 단점이 존재합니다.<br>Blooming 앱은 익명 고민 상담 게시판을 운영한다는 점에서 자유롭게 본인의 고민을 털어놓을 수 있지만, 음성을 활용하지 않고 텍스트를 통해서만 고민 상담을 할 수 있는 게시판을 운영한다는 한계점이 있습니다. |
| (8-3) 과제: 제안 내용 | 먼저 누구나 자유롭게 고민을 나누고 위로의 댓글을 남길 수 있도록 익명으로 소통할 수 있는 네트워크 서비스 구축하고자 했습니다. 또한, 기존 텍스트 위로의 문제점을 개선하기 위해, TTS기능을 이용하여 타 유저들이 남긴 댓글 텍스트 뿐만 아니라 새로운 보이스 형태의 위로로 들을 수 있게 했습니다. 추가로, 위로를 음악처럼 들을 수 있고, 많은 사람들에게 위로받고 있다는 느낌을 극대화하기 위해 여러 보이스로 변환된 댓글을 모아서 들을 수 있는 솔루션을 제안하고자 합니다. |
| (8-4) 과제: 과제의 주요 기능 | 익명의 게시글 작성/댓글 기능<br>자신만의 가상 보이스 생성 기능(보이스 요소 조절)<br>텍스트 댓글과 댓글 작성자의 보이스를 결합하여 보이스 댓글로 변환하는 기능<br>보이스로 변환된 댓글들을 한번에 모아듣는 기능 |
| (8-5) 과제: 구현 방법 | 사용자가 자신만의 보이스를 직접 들어보며 만들어볼 수 있게 하고, 만들어진 보이스의 정보는 MySQL DB에 저장이 됩니다. 이렇게 저장된 보이스 정보들을 가져와 댓글 작성자마다 다른 보이스의 위로들을 들어볼 수 있습니다.<br>또한 게시글 작성자는 마이페이지에서 변환된 보이스 위로들을 끊김없이 한번에 들을 수 있습니다. 각 댓글들의 보이스를 들어보고, <좋아요> 표시를 한다면 해당 데이터들을 바탕으로 통계, 분석하여 사용자에게 최적의 보이스를 추천할 수도 있습니다. |
| (8-6) 과제: 세부 기술 | 프론트엔드는 React를 사용하며, 배포는 Vercel을 이용합니다.<br>백엔드는 Django를 사용하며, 배포는 AWS와 GitHub Actions를 이용해 CI/CD를 구축하였습니다. 데이터베이스는 AWS의 S3와 MySQL을 사용하였습니다. |
| (8-7) 과제: 기대 효과 및 의의 | 본 서비스는 여러 댓글 작성자들이 작성한 보이스 위로 댓글을 들음으로써 가독성 저하 등 기존 텍스트 위로의 문제점을 개선할 뿐 아니라 ‘다수’의 사람들로부터 위로를 듣고 있다는 감정을 느낄 수 있습니다. <br> 더불어 보이스위로 댓글들을 한 번에 모아 들려주는 기능을 제공함으로써, 위로를 언제 어디서든 편하게 음악처럼 들을 수 있도록 합니다. <br>따라서 이 서비스는 사람들이 더 쉽게 고민을 공유하도록 접근성을 높이며, 위로의 감정을 더 효과적으로 나누는 것에 의의를 두고 있습니다. |
| (9) 데모 내용 | 웹 사이트 내 모든 기능은 로그인 후 사용이 이용 가능합니다. 로그인 후 나만의 보이스 페이지에 들어가 기본 보이스 타입 4가지와 스피드, 피치를 조합하고 생성된 보이스를 들어보며 마음에 든다면 나의 가상보이스로 저장할 수 있습니다. 이후 게시글에 댓글을 작성하게 되면 해당 가상보이스로 변환하여 제공하고 이를 들어볼 수 있습니다. 다른 유저들이 남긴 댓글 또한 댓글 작성자가 저장한 가상보이스로 변환된 음성을 들어볼 수 있습니다. 마지막으로, 마이페이지에 들어가면 내가 쓴 게시글을 앨범처럼 모아 볼 수 있고 해당 게시글의 모든 댓글을 모아 들을 수 있습니다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-27
| (1) 과제명 | MosaicNow
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 27-E모지 |
| (3) 팀원 역할 분담 | 정유라(2176349) : 백엔드 개발, AI<br>유혜진(2071089) : 백엔드 개발, AI<br>이가은(2076283) : 프론트엔드 개발, AI |
| (4) 팀 지도교수 | 윤명국 |
| (5) 팀 멘토 | 김민주/삼성전자/개발자 |
| (6) 과제 키워드(keywords) | 실시간/모자이크/스트리밍 |
| (7) 과제 내용 요약 | MosaicNow는 얼굴인식 기술을 기반으로 사용자가 등록한 얼굴 이외의 타인의 얼굴을 모두 모자이크하는 서비스를 제공해 실시간 라이브 방송에 얼굴이 노출될까 걱정하는 사람들에게 도움을 줄 뿐만 아니라 MosaicNow를 사용하는 스트리머에게도 촬영 장소에 구애받지 않는 자유로운 방송 컨텐츠를 제공할 수 있습니다. 저희는 이를 통해 다양한 환경에서 개인의 프라이버시를 보호하고 초상권 침해 피해를 감소시키고자 합니다. |
| (8-1) 과제: 문제의 정의 | 유튜브, 틱톡 등의 라이브 방송이 대중화 되면서 일상 속에서 라이브 방송으로 인한 초상권 침해 피해는 급격히 늘어나고 있는 추세입니다. 저희는 이처럼 원하지 않는 사람들의 초상권 보호를 위해 MosaicNow를 구상하였습니다. |
| (8-2) 과제: 기존연구와의 비교 | 관련 서비스인 VLLO는 동영상 자동 얼굴 모자이크 기능을 제공하지만 실시간 적용은 안된다는 단점이 있습니다. 이와 달리 MosaicNow는 실시간 적용이 가능하다는 장점이 있습니다. |
| (8-3) 과제: 제안 내용 | 공공장소 라이브 방송에서 타인의 초상권 보호를 위한 실시간 안면인식 커스텀 모자이크 스트리밍 서비스 |
| (8-4) 과제: 과제의 주요 기능 | FaceNet과 YOLO5를 이용하여 사용자의 얼굴 임베딩을 만들고 이를 비교하여 사용자 제외 타인의 얼굴을 모자이크 할 수 있는 커스텀 모자이크 기능과 사용자 외 다른 사람들의 얼굴 임베딩을 추가하여 여러명의 얼굴을 인식 가능하게 하는 얼굴 등록 기능, 등록된 유튜브 스트림 키를 이용해 개인 스트리밍 서버로 실시간 송출할 수 있는 스트리밍 기능을 제공합니다. |
| (8-5) 과제: 구현 방법 | 1. 얼굴 등록 기능<br>1.1 등록 버튼을 누르면 얼굴 등록 화면으로 이동하고 웹캠의 프레임을 AI 서버로 전송한다.<br>1.2 전송된 50개의 프레임의 평균 임베딩을 계산하여 임베딩 파일을 생성한다.<br>1.3 얼굴 등록이 완료되면  메인 화면으로 이동한다.<br><br>2. 실시간 커스텀 모자이크<br>2.1 사용자의 프레임을 받아 얼굴을 탐지한다.<br>2.2 탐지된 얼굴들과 저장된 임베딩의 거리를 계산하여 등록된 사용자인지 판단한다.<br>2.3 등록된 사용자가 아닌 경우 얼굴을 모자이크 처리한다. 모든 얼굴에 같은 처리 방식을 반복한다.<br>2.4 처리된 프레임을 클라이언트에게 전달하여 사용자의 화면에 보여준다.<br><br>3. 유튜브 스트리밍<br>3.1 시작 버튼을 누르면 등록된 처리된 프레임을 사용자의 유튜브 스트리밍 서버로 전송하여 유튜브 라이브 방송을 시작한다. |
| (8-6) 과제: 세부 기술 | 동작환경 : 크롬 웹 브라우저<br>Frontend: React, JavaScript, CSS<br>사용자 인터페이스를 구현하고 사용자와의 상호작용을 담당한다.<br><br>Backend: web server, AI server, Database<br>Web server: Apache, Node.js<br>포트포워딩을 통해 외부 접속이 가능하게 하고 Apache에서 Node.js 서버로의 프록시 설정을 통해 Apache를 통한 요청을 Node.js 서버로 전달한다. 클라이언트의 로그인, 회원가입, 사용자 정보 저장 및 처리 등의 요청과 서버, 데이터베이스의 상호작용을 담당한다.<br>AI server: YOLOv5, FaceNet<br>포트포워딩을 통해 클라이언트에서 AI 서버로 사용자의 웹캠 프레임을 보내고 AI서버에서 프레임을 처리한다. YOLOv5로 사용자의 프레임에서 얼굴을 탐지하고, FaceNet을 이용하여 탐지된 얼굴들과 저장된 임베딩을 비교하여 미리 등록된 사용자인지 판단하고 등록된 사용자가 아닌 경우 얼굴을 모자이크 처리한다. 처리된 프레임을 클라이언트에게 전달하고 클라이언트는 전달받은 프레임을 실시간으로 사용자에게 보여준다. 사용자가 스트리밍을 시작하면 처리된 프레임을 FFmpeg를 사용해 사용자의 유튜브 스트리밍 서버로 전송한다. <br>Database: mySQL<br>시스템의 데이터를 저장하며, 사용자 정보 테이블, 사용자 얼굴 임베딩 테이블 등을 포함한다. |
| (8-7) 과제: 기대 효과 및 의의 | MosaicNow는 등록되지 않은 얼굴에 대해 모자이크 처리를 적용하여 개인의 프라이버시를 보호할 수 있습니다. 또한 실시간 라이브 방송에 얼굴이 노출될까 걱정하는 사람들에게 도움을 줄 뿐만 아니라 MosaicNow를 사용하는 스트리머에게도 촬영 장소에 구애 받지 않는 자유로운 방송 컨텐츠를 제공할 수 있습니다. 이를 통해 본 팀은 다양한 환경에서 개인의 프라이버시를 보호하고 초상권 침해 피해를 감소시키고자 합니다. |
| (9) 데모 내용 | Web 환경에서 emoji27.duckdns.org로 접속해 데모를 진행한다.<br>[데모 내용] 1. 로그인/회원가입 기능을 보여준다. <br>2. 사용자의 정보 변경 기능을 보여준다. <br>3. 사용자의 얼굴을 등록하는 과정을 보여준다. <br>4. 미리보기 기능을 통해 등록 된 얼굴을 제외한 얼굴들이 실시간으로 모자이크 되는 화면을 보여준다.  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-28
| (1) 과제명 | 속마음을 담은 일기 교환을 통해 현대인의 소외감 해소를 돕는 교환일기 웹 서비스 <비밀친구>
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 28-달리리 |
| (3) 팀원 역할 분담 | 황채린(2176429): 리더, 백엔드 프로그래밍<br>조아령(2076389): 팀원, 프론트엔드 프로그래밍<br>곽민지(2176022): 팀원, 백엔드 프로그래밍 |
| (4) 팀 지도교수 | 박상수 |
| (5) 팀 멘토 | 서오석/SK에너지/CTO |
| (6) 과제 키워드(keywords) | 일기,교환,매칭 |
| (7) 과제 내용 요약 |  <비밀친구>는 지인, 혹은 익명의 친구와 지속적인 교환 일기를 쓸 수 있도록 해주는 웹 서비스이다.<br> 비밀 친구는 크게 두가지 목표를 가진다.<br>  첫 번째는 '교환'과 관련된 목표로, 교환 일기 웹 서비스 ‘비밀친구’를 개발 및 배포하여 사용자들끼리 속마음을 담은 일기를 교환함으로써 서로를 공감하고, 현대 사회에서 느끼는 소외감을 해소하도록 유도하는 것이다.<br>  두 번째는 '일기'와 관련된 목표로, 사용자가 작성한 일기에 대한 감정분석 결과를 보여줌으로써 사용자가 '오늘의 기분'이 어땠는지 스스로의 감정을 되돌아보고 살필 수 있는 기회를 제공하는 것이다. |
| (8-1) 과제: 문제의 정의 |  비밀친구는 경쟁이 과열된 현대 사회에서 개인이 느끼는 '소외감' 및 '단절감' 이라는 키워드에 집중해 문제를 정의한다. 현재 한국인들의 우울감은 더욱이 심화되는 추세로 100만명이 넘어섰다는 기사를 발견했으며, 특히 젊은 층의 우울증 환자 수가 입시, 취업, 코로나 등을 겪으며 계속해서 증가하고 있는 상황이라고 한다. "어려울 때 자신의 말을 듣고 도와주는 사람이 1명만 있어도 자살 예방에 도움이 된다"는 전문가의 의견에 따라, 물질적인 가치를 배제하고 자신의 이야기를 다른 사람에게 공유하며 지속적이고 건강한 소통이 가능한 공간의 필요성을 느끼게 되었다.|
| (8-2) 과제: 기존연구와의 비교 |  비밀친구와 유사한 서비스로는 기존 일기장 서비스와 인스타그램, 총 두 가지를 선정해 비교했다. <br>먼저 기존 일기장 서비스와 비교했을 때 <비밀친구>는 친구와 일기를 교환할 수 있다는 차별점이 존재한다. 친구와 함께 일기를 작성한다는 재미 요소는 글쓰기에 서투른 사람들도 쉽게 일기를 작성할 수 있게 도와줄 것으로 예상한다. 또한 기존 일기장 서비스에서는 사용자들이 매일 일기를 작성해야한다는 부담감을 받기 쉬운 반면, 비밀친구는 함께 일기를 작성하는 파트너로부터 답장(일기)을 받아야만 일기를 작성하는 차례가 돌아오므로, 사용자가 매일 일기를 작성해야 한다는 부담이 한층 줄어든다. 반면, 'Doolda', '아모르'와 같이 타인과 함께 일기를 작성할 수 있다는 강한 유사점을 가진 서비스들이 존재했는데, 이러한 서비스의 경우 친구 혹은 연인 관계를 타겟으로 하고 있는 것을 발견할 수 있었다. 그러나 비밀친구는 사용자의 관심사를 고려한 랜덤매칭 기능을 제공하여 사용자가 지인이 아닌 익명의 대상과도 교환 일기를 작성할 수 있도록 구현한다. <br>두번째로, 대표적인 SNS 인스타그램과 비교했을 때 비밀친구는 타인과 소통할 수 있다는 공통점을 갖는다. 하지만 인스타그램은 텍스트보다는 이미지 위주의 소통이 이루어지며 여러 사람에게 사용자의 일상이 보여지는 반면, 비밀친구는 한 명의 파트너와만 일기를 교환한다는 점에서 개개인 간의 긴밀한 소통에 중점을 두고 있다는 차이점이 존재한다.  |
| (8-3) 과제: 제안 내용 | 어릴 적 친구들과 주고받았던 교환일기 경험을 바탕으로 한 교환일기 웹 서비스를 해결책으로 제안한다. 초대코드를 통해 친구들과 교환일기를 작성할 수 있으며 기존에 존재하는 교환일기 서비스와는 다르게 익명의 상대와도 교환일기를 작성할 수 있는 랜덤 매칭 기능을 제공한다. 랜덤 매칭의 경우 사용자의 관심사를 고려하여 비슷한 관심사를 가진 사용자끼리 매칭할 예정이다. 익명의 상대에 대한 신뢰성 문제를 사전에 해결하기 위해 혐오발언과 성적발언 필터링 기능을 추가하고 일정 회수 이상 신고가 누적되면 계정을 자동으로 정지시키는 기능을 제공한다. 교환일기의 아날로그 감성을 어플리케이션을 통해서도 느낄 수 있게 상대방의 일기는 일정 시간 이후에 공개하여 실제로 일기를 주고받는 듯한 기분을 유도할 계획이다. |
| (8-4) 과제: 과제의 주요 기능 | <b>1. 일기장 관련 기능</b><br>&nbsp;&nbsp;&nbsp;&nbsp;- 지인매칭 혹은 랜덤매칭을 통해 일기장을 생성하는 기능을 제공한다. 이때 랜덤매칭의 경우 사용자의 관심사와 매칭 요청 날짜를 고려해 설계한 알고리즘을 통해 매칭이 이루어진다. 매칭이 완료되면 두 명의 사용자가 연결되어 하나의 일기장을 가지게 된다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 현재 교환일기를 작성하는 파트너와 일기 교환을 중단할 수 있도록 일기장 비활성화 기능을 제공한다. 비활성화된 일기장은 이전에 작성했던 일기에 대한 열람만이 가능하며 더이상의 일기 작성은 불가하다.<br>&nbsp;&nbsp;&nbsp;&nbsp;- 일정 시간이 지났음에도 파트너에게 답장을 받지 못하는 경우 일기장 회수 요청을 통해 일기장을 반환 받을 수 있다. 사용자가 일기를 반환받은 경우, 사용자에게 일기를 작성할 차례가 넘어온다.<br><b>2. 일기 관련 기능</b><br>&nbsp;&nbsp;&nbsp;&nbsp;- 일기 CRUD<br>&nbsp;&nbsp;&nbsp;&nbsp;- 작성된 일기를 상대방에게 전달하는 기능을 제공한다. <br><b>3. 작성한 일기에 대한 감정분석 기능</b><br>&nbsp;&nbsp;&nbsp;&nbsp;- SKT kobert 모델을 파인 튜닝하여 일기 내용을 행복, 불안, 분노, 당황, 슬픔, 혐오 6개의 감정으로 분류하도록 한다. 일기 전달 시 작성한 일기를 바탕으로 감정을 분석하고 결과로 레포트를 제공한다. |
| (8-5) 과제: 구현 방법 |스프링 부트와 리액트를 이용해 교환일기 서비스 “비밀친구”를 웹 애플리케이션 형태로 개발한 후, aws 와 docker 를 통해 실제 배포 및 운영할 계획이다. 교환 일기 웹 서비스 계정 로그인, 지인 매칭과 랜덤 매칭을 통한 일기장 생성, 일기 작성/수정, 상대방과 일기장 주고 받기, 일기장 읽기, 일기장 비활성화, 유저 신고, 혐오 발언 필터링 등의 메인 기능이 포함된다. 또한, 작성된 일기를 기반으로 한 감정 분석 결과를 보여주는 기능을 제공하는데, 이는 skt 코버트 모델을 활용해 구현한 다중 감정 분류 모델을 fast api 를 통해 서빙한 후 서비스에 적용한다.|
| (8-6) 과제: 세부 기술 |1. 구축 환경<br>- 버전 관리: Github<br>- frontend: React, Axios<br>- backend:Spring Boot, Gradle<br>- CI/CD: Github Actions<br>- container: Docker<br>2. 감정 분석을 위한 ai 모델으로 skt koBERT 사용<br>- 감정 6 개 행복, 당황, 슬픔, 분노, 불안, 혐오를 구분할 수 있도록 파인튜닝 진행<br>- 파인 튜닝 후 실제 일기와 비슷한 값을 넣어 테스트한 결과 원하는 분류대로 결과를 도출하는 것을 확인<br>3. 스프링 부트와 AWS EC2를 이용한 API 서버와 CloudFront+S3를 이용한 리액트 웹 서버 구축 <br>4. MariaDB RDBMS 와 AWS RDS 를 이용한 데이터베이스 구축<br> |
| (8-7) 과제: 기대 효과 및 의의 | 어플리케이션의 타겟층은 2~30대로, 친구들과 일상뿐만 아니라 속 깊은 얘기까지 공유할 수 있도록 하여 단조로운 사회 속에서 공감과 유대를 느낄 수 있는 공간을 제공하는 것을 하나의 목표로 한다. 또한, 익명 기능을 통한 일기 작성으로 경쟁사회에서 단절감을 느꼈던 개인들에게 이어짐을 느낄 수 있는 공간을 제공하고 물질적인 가치보다는 사용자들의 이야기에 더욱 집중할 수 있는 환경을 만드는 것을 목표로 한다. 익명의 상대와 교환 일기를 작성하면서 자신과 비슷한 사람을 만나고 따뜻함과 위로를 나눌 수 있을 것으로 예상한다. 더불어 어릴 때 교환일기를 작성한 적 있는 사람들에게는 그 시절의 추억을 재현시켜 주고 어릴 적 교환일기를 작성해 본 적이 없는 이들에게는 레트로 감성을 충족시켜 주는 서비스가 될 것이라 기대한다. 또한, 잊어버리기 쉽고 누군가에게는 번거롭게 느껴질 수 있는 일기 작성을 누군가와 함께하는 경험을 부여함으로써 기록에 대한 동기를 유발할 수 있을 것이다.|
| (9) 데모 내용 |1. 지인 매칭을 통해 일기장을 생성하는 과정을 보여준다.<br>&nbsp;&nbsp;&nbsp;&nbsp;1-1. 사용자는 지인 매칭을 통해 일기장을 생성한 후 함께 교환일기를 작성할 상대에게 초대코드 공유<br>&nbsp;&nbsp;&nbsp;&nbsp;1-2. 상대방은 지인 매칭을 통해 일기장을 생성한 후 초대코드 입력<br>&nbsp;&nbsp;&nbsp;&nbsp;1-3. 일기장 생성 완료<br><br>2. 일기 작성 후 교환 일기 파트너에게 전달하는 과정을 보여준다.<br>&nbsp;&nbsp;&nbsp;&nbsp;2-1. 사용자는 <1> 과정에서 만들어진 일기장을 캐비닛 화면에서 확인 가능<br>&nbsp;&nbsp;&nbsp;&nbsp;2-2. 새로운 일기 내용을 작성 후 저장한다.<br>&nbsp;&nbsp;&nbsp;&nbsp;2-3. 사용자가 파트너에게 교환일기를 전달<br>&nbsp;&nbsp;&nbsp;&nbsp;2-4. 전달 완료된 일기장은 사용자의 캐비닛 화면에서 사라지고, 파트너의 캐비닛 화면에서 보여지는 것을 확인<br><br>3. 작성한 일기에 대한 감정 분석 결과를 보여준다.<br>&nbsp;&nbsp;&nbsp;&nbsp;3-1. 사용자는 일기를 전달 한 뒤 작성한 일기 내용에 대한 감정 분석 레포트를 확인할 수 있다.   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-29
| (1) 과제명 | AI를 활용한 영어 스피킹 시험 준비 앱
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 29-츄라이 |
| (3) 팀원 역할 분담 | 지현서(2176368): 리더, AI 프롬프트 엔지니어링<br>조은혜(2176365): 팀원, 백엔드 서버 프로그래밍, DB<br>유민경(2076256): 팀원, UI/UX 프로그래밍 |
| (4) 팀 지도교수 | 이민수 교수님 |
| (5) 팀 멘토 | 서연주 / 프리랜서 / 프리랜서 |
| (6) 과제 키워드(keywords) | AI, 영어스피킹시험, 영문뉴스 |
| (7) 과제 내용 요약 | 짧은 시간에도 틈틈이 학습을 할 수 있는 AI를 활용한 영어 스피킹 시험 대비 애플리케이션을 만듭니다. 시험 주최 기관에서 제공하는 모의고사로 시험 유형을 익히고, 영문 기사를 활용하여 만든 새로운 문제를 풀어보며 다양한 주제로 출제되는 시험에 익숙해지도록 돕습니다. AI가 사용자의 답변에 대한 자세한 피드백을 제공해 적은 비용을 투자해 효율적인 학습이 가능하도록 합니다. |
| (8-1) 과제: 문제의 정의 | 본 프로젝트는 영어 스피킹 시험 준비에 있어 기존 학습 방식의 높은 시간적, 경제적 부담과 기출 문제 중심의 학습, 비효율적인 피드백으로 인한 한계를 극복하고자 합니다. 이를 위해, 학습자가 접근하기 쉽고 효율적으로 영어 스피킹 실력을 향상할 수 있는 맞춤형 학습 플랫폼을 제공함으로써, 영어 스피킹 시험 준비의 어려움을 해소하려고 합니다. |
| (8-2) 과제: 기존연구와의 비교 | 테스트글라이더(TestGlider)<br>장점: 토플, 아이엘츠 등 영어 시험을 대비할 수 있는 풍부한 학습자료와 강의를 제공하며, 100만 건 이상의 답안 데이터를 학습한 AI 기반의 사용자 답안 채점 서비스가 있다.<br>단점: AI 첨삭 서비스에 일반적인 모범답안은 포함되어있지만, 세부적인 오류에 대한 구체적인 피드백을 제공하지 않는다. |
| (8-3) 과제: 제안 내용 | 모의고사 문제를 가볍게 자주 풀 수 있도록 해 꾸준한 학습을 유도한다. 좋은 자료를 기반으로 새로운 문제를 제공해 다양한 주제의 시험에 대비할 수 있도록 한다. 사용자의 답변에 대해 문장 단위의 피드백을 제공한다. 단순한 모범답안 제공이 아닌 문장 구조 개선, 문법 오류, 모범답안의 틀에 맞춰 자신의 답변을 정리하는 법 등을 피드백으로 제공한다. 실제 교육자 대신 AI를 활용해 학습 비용을 절감한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 모의고사 풀이: 시험 주최 기관에서 제공하는 모의고사 문제와 모범답안을 한 문제씩 미니 시험 형식으로 가공해 제공한다.<br>2. 뉴스 기반 대화: 영어뉴스를 주제로 시험 형식의 질문을 생성해 제공하고, 사용자가 실제 시험에서 모범답안에 가까운 답변을 할 수 있도록 유도한다.<br>3. AI 튜터의 자동 피드백: GPT API를 이용해 모의고사 풀이, 뉴스 기반 대화에서 받은 사용자의 답변에 대한 피드백을 제공한다. |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 |   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-30
| (1) 과제명 | CATCHUP: 컴퓨터공학과 학생에게 맞춤형 선수 학습사항 자료를 제공해주는 LLM 챗봇 웹서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 30-일구어냄 |
| (3) 팀원 역할 분담 | 유영민(1976244): 리더, 데브옵스, 시스템디자인, 백엔드<br>강민아(1976002): 팀원, 프론트엔드, api 개발<br>임은지(1985086): 팀원, 데이터구조, 프롬프트 엔지니어링, vector DB, 백엔드 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 이경은 / 클라우드네트웍스 / 과장 |
| (6) 과제 키워드(keywords) | LLM 챗봇, 맞춤형 학습자료, RAG |
| (7) 과제 내용 요약 | CATCHUP은 선수과목을 제때 듣지 못해서 전공 과목 진도를 따라잡는 데에 어려움을 겪는 컴공생들을 대상으로, 개인에게 꼭 필요한 개념만 선별하여 학습자료를 제공하는 LLM 챗봇 웹서비스이다. <br>기존 방식과 비교했을때, 첫째, 학습의 형식에 차별을 두었다. 선수학습사항을 과목 단위의 통강의가 아닌 개념 단위의 학습자료 형식으로 개편했다.  <br>둘째, 학습할 내용을 추렸다. 프롬프트 엔지니어링을 통해 사용자에게 필수적인 개념들만 선별했다.<br> 마지막으로, 학습 방향성을 개선했다. 일방적 강의에서 벗어나, langchain 등을 통해 맥락을 인지한 맞춤형 상호작용을 보장했다.  |
| (8-1) 과제: 문제의 정의 | 선수 학습 사항을 충족하지 못한 컴퓨터공학과 학생들은 전공 강의를 수강하는 데에 많은 어려움을 겪는다. 설문조사 진행 결과, 수강신청 실패 및 휴학 등의 이유로 전공 기초 과목을 권장학기에 듣지 못한 학생들의 83%가 부족한 부분을 혼자 공부하다가 포기한 경험이 있다고 응답했다. 교내 교육혁신 센터 전문가 또한 "특히 문과 출신 학생들이 해당 어려움을 겪는 경우가 자주 목격되나, 이를 완화할 별도의 시스템이 전무하다"고 지적했다. 또한, 통계에 의하면 학생들이 채택하는 대표적인 임시방편책은 선수과목을 전공서적 및 외부 인터넷 강의(KMOOC)로 학습하는 방식이다. 이때, <b>형식, 내용, 방향성</b> 총 3가지 측면에서 세부문제가 발생한다. <br><br><b>1. 과목 단위, 통강의 형식</b><br>전공과목에서 요구하는 선수학습사항은 강의계획서에 과목 단위로 기재된다. 이를 충족하기 위해서는 일반적으로 1시간 내외 분량의 강의를 30강의 가량 수강해야 하는 부담이 있다. <br><br><b>2. 불필요한 내용</b><br>선수과목은 희망전공과목에서 다루지 않는 다양한 개념까지도 모두 포괄한다. 그러나 학생들은 어떤 개념이 자신이 들을 전공과목과 관련이 있는지 분별할 능력이 없기에, 당장 필수적이지 않은 개념들까지 공부하는 수밖에 없다. <br><br><b>3. 일방향성</b><br>공부하다가 모르는 것이 생겨도 질문할 창구가 존재하지 않는다. 학습 도중 난관에 봉착하면 학습 흐름이 쉽게 끊긴다. |
| (8-2) 과제: 기존연구와의 비교 | 교육 분야에서의 상용화된 AI 활용 서비스 각각 다음과 같은 이점을 가졌으나, 이들 모두 타겟층이 대학생이 아니거나, 컴퓨터 공학 도메인을 벗어났다는 치명적인 한계를 공통적으로 지녔다. <br><br><b> case 1. 학습 단위를 개념으로 파편화하다 - 교원 아이캔두 수학 (AiCANDO) </b><br>AI를 활용하여 사용자가 취약한 부분을 개념 단위로 세분화하여 파악한다. 다만, 다루는 범위가 초등수학에 국한되어 있다. <br><br><b> case 2. 사용자에게 필요한 내용만 제시하다 - EBSi 인공지능 DANCHOO</b><br>고등학생 수험생 이용자의 EBSi 이용기록을 기반으로 맞춤형 문제를 추천한다. 즉, 이미 잘 알아서 풀 필요가 없는 문제를 제외하고, 자주 틀리는 문제만 선별하여 제시한다. 그러나 문제를 풀면서 생기는 의문을 서비스 내에서 해결해주지 못한다는 점이 한계로 꼽힌다. <br><br><b> case 3. 질의응답을 보장하다 - 키위AI (KEEwit)</b> <br>GPT 기반 글쓰기 교육 챗봇으로, 사용자가 작성한 글에 대해 챗봇과 대화할 수 있다. <br><br>  |
| (8-3) 과제: 제안 내용 | 1. 개념 단위, 학습자료 형식 : 개념별 선수학습사항을 과목이 아닌 파편화된 개념 단위로 쪼개어 각 개념별 학습자료를 제공했다. 이때 한 개의 개념은 40분 이내에 학습할 수 있을 정도로 LLM의 답변 시스템을 설계했다. <br>2. 필수적인 학습내 선별 : 강의 도중 학생들이 어떤 부분을 건너뛰어도 되는지 모르는 불편함을 해소하기 위해, 현재 수강희망과목과 무관한 개념들을 대신 배제했다. 프롬프트 엔지니어링을 활용하여  LLM이 해당 과목과 관련된 필수적인 개념들만 선별하도록 했다.<br>3. 실시간 양방향 소통 : 기존 학습채널의 일방향성과 대조적으로, 챗봇 대상 Q&A를 통한 즉각적인 상호작용을 보장했다.   |
| (8-4) 과제: 과제의 주요 기능 | 1. 개념별 학습자료 제공 모듈 : 첫째, 학습자료 제공 시 Hallucination을 제어하기 위해 RAG(Retrieval Augmented Generation)를 활용했다. 컴퓨터공학 전공 강의 자료를 chunk embedding시켜서 vector DB를 형성한 후 사용자가 질문을 하면, 우선 그 질문을 벡터화 시킨 뒤 vector space에게 전달해서 유사도 검사를 통해 질문과 가장 관련 있는 문맥을 추출하고, 언어모델이 그것 참조하여 사용자의 질문에 적절히 답변하도록 설계했다. <br>2. 필수 선수학습사항 선별 모듈 : 둘째, LLM이 해당 과목과 관련된 필수적인 개념들만 선별하도록 프롬프트 엔지니어링을 활용했다. zero-shot prompt 등의 기술을 적용했다. <br>3. QnA 모듈 : 셋째, langchain 을 활용하여 챗봇이 기존의 대화의 내용을 기억하여 사용자의 수준과 약점사항들을 참고하여 맞춤형 학습자료를 생성하게끔 했다. 챗봇이 기존 대화를 vectorDB에 저장하면, 각 개념별 학습자료를 생성할때 미리 해당 DB를 참조하여 혹 사용자가 어려워하는 부분이라면 조금 더 상세히 설명하도록 설계했다.  |
| (8-5) 과제: 구현 방법 | <b>1. 개념별 학습자료 제공 모듈</b><br>RAG(retrieval augmented generation) 기술을 활용할 것이다. LLM이 컴퓨터공학 도메인 전용 Vector DB를 참조하여 공신력 있는 학습자료를 생성하도록 설계하는 방식이다.  <br><br><b>2. 필수 선수학습사항 선별 모듈</b><br>Prompt Engineering과 더불어 VectorDB 활용을 한다. Vector DB 코사인 유사도 검사를 통해, 희망 전공 과목 내에서 선수과목 개념들과 연관이 있는 부분만 선택적으로 참조해 개념별로 리스트 업해 개념 챗방을 생성한다.<br><br><b>3. Q&A 모듈</b><br> Langchain과 Prompt Engineering을 사용하여 LLM이 사용자와의 이전 대화 맥락 및 해당 챗방의 학습 자료를 바탕으로 의미 있는 답변을 하도록 설계한다.|
| (8-6) 과제: 세부 기술 |1. 개념별 학습 자료 제공</b><br>사용자가 시작하기 버튼을 클릭하면 프론트에서 백엔드의 post_new_concept_supplement() 를 호출한다. 백엔드는 사용자를 확인하고(DB), langchain_learningmaterial()을 호출한다. langchain_learningmaterial()는 vectorDB에서 학습자료의 신뢰성을 높이기 위한 관련 주제의 외부자료(RAG), 프롬프트, GPT 를 이용해 학습자료를 생성해 반환한다. 학습자료는 프론트를 거쳐 사용자에게 제공된다.<br><br><b>2. 필수 선수학습사항 개념 선별</b><br>사용자가 학습 희망 과목을 입력하면, 프론트에서 백엔드의 post_new_chat() 를 호출하며 시작된다. 이때 입력받은 학습 희망 과목을 인자로 전달하며, 사용자 구분은 메시지 헤더에 토큰을 담아 전달한다. 호출받은 백엔드에서는 사용자 확인 후(DB) 학습 희망 과목 classroom 객체를 만들고(DB) langchain_conceptlist()를 호출한다. 이때 인자로는 학습 희망 과목을 전달하고, 프롬프트를 추가해서 gpt를 거쳐 개념의 목록을 반환한다. 프론트에서는 사용자가 학습할 개념의 목록을 개념 챗방 생성을 통해 사용자에게 보여준다.<br><br><b>3. Q&A</b><br>사용자가 질문을 하면 프론트에서 벡엔드의 post_new_concept_qna()를 호출한다. 이때 질문내용을 인자로 전달하며, 사용자 구분은 메시지 헤더에 토큰을 담아 전달한다. 호출받은 백엔드에서는 DB에서 사용자가 존재하는지 확인하고, 사용자 정보를 받아온다. 질문의 정확한 맥락 파악을 위해 사용자의 해당 챗방에서의 기존의 대화를 DB에서 받아와 lanchain_qna()를 호출한다. 질문은 기존대화와 프롬프트와 함께(chained request) gpt 에 전달되고, 답변 또한 형식과 언어를 정리한 뒤 백엔드에 반환한다. 질문과 답변을 DB에 저장하고, 답변은 프론트단을 거쳐 사용자에게 제공된다 |
| (8-7) 과제: 기대 효과 및 의의 | 1. 형식 간소화로 인한 학습부담 완화</b><br>기존 과목 전체가 아니라 개념 단위로 학습 틀을 간소화하여, 공부 시작 전 학생들의 심리적 허들을 완화함으로써 진입장벽을 해소하는 효과를 기대할 수 있다. <br><br><b>2. 불필요한 개념 소거를 통한 학습량 축소</b><br>전공과목과 무관한 선수과목 개념들은 학습범위에서 생략함으로써, 절대적인 학습량을 대폭 줄이는 이점을 누릴 수 있다. 이로써 이용자들은 시간과 자원을 크게 절약할 수 있다. <br><br><b>3. 실시간 답변을 통한 학습의 연속성 유지</b><br>난관에 봉착해도 실시간으로 도와주는 챗봇을 통해 학습의 흐름을 원활히 지속해내갈 수 있다. <br><br>종합적으로, 학생들은 CATCHUP을 통해 전공과목 이수를 위한 사전 준비를 부담없이 효율적으로 해낼 수 있을 것이다. CATCHUP은 강의실에서 누구 하나 뒤처지지 않도록, 모두가 배움의 즐거움을 누리는 데 기여할 것이다. |
| (9) 데모 내용 | 1. 학습사항 선별 기능</b><br>사용자가 희망 수강 전공과목에 대해 챗을 입력하면, 챗봇이 그와 관련된 필수 선수학습사항을 제시하여 각 개념 챗방을 생성한다.<br><br><b>2. 학습 자료 생성 기능</b><br>개념 챗방 입장 시 학습 자료를 제공한다.<br><br><b>. Q&A 기능</b><br>학습자료에 대한 질문을 하면 해당 학습 자료를 바탕으로 챗봇이 답변해준다.   |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)

# Team-31
| (1) 과제명 | DreamGuard: 더 좋은 잠을 위한 수면장애 위험도 진단 및 수면 트래킹 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 31-BCS |
| (3) 팀원 역할 분담 | 박연주(2076153): 팀장, AI모델 architecture 및 개발 및 총 책임<br>김원정(2176083): 팀원, 데이터 저처리, DB 백엔드 개발 총 책임<br>류진(2071023): 팀원, 모델 training, 앱 프론트엔드 개발 총 책임 |
| (4) 팀 지도교수 | 심재형 교수님 |
| (5) 팀 멘토 | 견종서/일마그나/이사 |
| (6) 과제 키워드(keywords) | 수면 무호흡증, 심전도, 수면호흡음 |
| (7) 과제 내용 요약 | <br> DreamGuard는 수면다원검사를 받기 어려운 사람들과, 수면장애 판정을 받은 후 지속적인 관리를 원하는 사람들을 대상으로 하는 심전도 및 수면 호흡음 파일을 활용한 수면장애 위험도 진단 및 수면 습관 트래킹 서비스임.  |
| (8-1) 과제: 문제의 정의 | 수면장애 인구가 급속도로 증가하고 있는데 수면장애 치료에 중요한 3가지 요소인 인지, 진단, 지속적 관리 면에서 각각 문제점이 관찰됨. 제한적 의료 급여 정책으로 인한 접근성 문제, 낮은 판독 일관성으로 인한 위음성 문제, 수면 주기 트래킹 미비로 인한 지속성 문제가 있음 |
| (8-2) 과제: 기존연구와의 비교 | 현재 알라미, Sleep Cycle, Pillow 등 수면 주기 위주의 트래킹을 제하는 어플리케이션이 시장에 나와있음. 그러나 이러한 수면 트래킹을 수면장애 위험도 및 개선 상황과 연계하는 서비스는 미비함 |
| (8-3) 과제: 제안 내용 | 접근성 및 판독 일관성 문제 해소를 위해 수면 호흡음 및 ekg 데이터에 대한 판독 자동화와 OSA(수면 무호흡증) risk를 산출하는 AI 모델을 기반으로 한 수면 습관 트래킹 서비스를 제안함 |
| (8-4) 과제: 과제의 주요 기능 | - 수면장애 위험도 산출 AI/판독 자동화 모델(사용자가 자신의 심전도와 수면호흡음을 전송하여 수면 장애 진단)<br>- 사용자 맞춤 수면 패턴 분석 및 수면장애 위험도 기반 트래킹 서비스 (현재 수면 패턴, 수면 패턴 개선 현황 조회 / 알람, 잘 시간 알림 서비스) |
| (8-5) 과제: 구현 방법 | i.	데이터 처리: 연구에 사용될 수면 데이터셋은 IRB 승인 후 AI-hub를 통해 확보되어야 하며, edf 파일 형식의 데이터를 처리할 수 있는 라이브러리가 필요함. 또한 사용자의 수면 정보를 애플리케이션을 통해 얻을 수 있어야함. 
Biosppy, MNE를 통해 생물학적 정보를 처리함.
Scipy, Sckit-learn을 통해 EDF 파일 형식의 데이터를 처리함.
Google Sleep API (Open API)를 통해 사용자의 수면 시간과 수면 질을 수집함.

ii.	서버 관리: 사용자의 데이터를 안전하게 저장할 수 있어야 하며, 사용자 경험을 향상시킬 수 있는 서버가 필요함. 
Django와 MariaDB를 통해 백엔드 서버를 개발함.
AWS S3를 통해 대용량 데이터를 안전하게 저장함.

iii.	AI 모델의 정확도: 자가수면검사 AI 모델은 수면무호흡증 위험도를 계측함. 연합학습 방식을 사용하여 프라이버시를 유지하면서 모델의 정확도를 높임. 
PyTorch를 이용한 기계학습.
90% 이상의 정확도를 목표로 함.

iv.	연합학습 구현: Non-IID 데이터 문제를 해결하면서 연합학습을 적용해야 하며, 이를 위한 알고리즘은 분산된 데이터로부터 효율적으로 학습할 수 있어야 함. 
중앙 집중형 모델과 비교하여 90% 이상의 정확도를 달성해야 함.

v.	어플리케이션 개발: 어플리케이션은 사용자의 수면 상태 데이터를 수집하고, 수면무호흡증 위험도를 사용자에게 피드백할 수 있는 인터페이스를 제공함. 
프론트엔드는 React Native로, 백엔드는 django를 사용하여 개발함.
Nginx와 Gunicorn을 이용한 서버 호스팅.
AI 모델을 서빙하는 API는 Flask로 개발함.

vi.	보안: 사용자의 민감정보를 보호할 수 있어야함
Django JWT를 이용해 회원 보안을 향상함
|
| (8-6) 과제: 세부 기술 |i.	AI API 설계	
•	Pandas, numpy 등을 활용하여 Raw Data Pre-processing : EDF및 mp3 형식의 수면 호흡음 데이터와 pdf 등의 형식인 심전도 데이터를 AI 모델에서 처리하기 용이하도록 전처리하는 과정을 거침. 수면 시간만큼의 방대한 데이터를 처리하므로 수면 호흡음의 경우 mel-spectrogram 형태로 변환, 심전도의 경우 구간별로 분할하여 전처리를 진행함. 이때, 질병 유무를 라벨링한 json file 또한 매칭하여 csv 파일을 준비함. 
•	Pytorch 등을 활용하여 AI 학습용 모델 구현 : 정제한 데이터를 활용하여 선형회귀 모델을 사용. Nn.Sequential을 활용하여 모듈 층을 구성하고, 결과값으로 전체 데이터셋에 대한 백분위를 도출할 수 있도록 함.
•	데이터셋 분할 및 학습 진행 : 학습 및 테스트에 사용될 데이터셋을 분할하고, 모델의 파라미터를 조정 및 최적화함. 데이터셋의 경우 파라미터로 사용할 데이터의 위치, binary로 변환된 OSA 유무 등을 포함한 csv 파일 형태임. 
•	Scikit-learn 및 Pytorch를 활용하여 모델 성능 평가 : 학습 및 테스트에 사용된 데이터셋의 임의 추출에 따라 모델이 얼마나 정확하게 위험도 백분위를 예측하였는지 성능을 평가함. 모델 학습에 사용되지 않은 기존 데이터셋 외의 자료 또한 추가적인 pre-processing을 거쳐 평가 등에 활용할 수 있음.
ii. 사용자의 수면 데이터 및 서버 관리
•	장고 및 마리아DB 활용: 장고 프레임워크와 마리아DB를 사용하여 강력하고 안정적인 백엔드 서버를 구축함. 
•	JWT 토큰을 통한 보안 강화: 사용자 인증 및 데이터 보안을 위해 JWT 토큰 방식을 채택하여 사용자의 민감 정보를 강력하게 보호함.
•	AWS S3를 이용한 데이터 저장: 사용자의 수면 호흡음 및 심전도 파일을 안전하게 저장하기 위해 대용량 데이터 관리에 용이한 AWS S3를 활용함. 
•	Google Sleep API 활용: 사용자의 수면 시간 및 수면 질을 분석하여 제공함으로써, 사용자가 자신의 수면 패턴을 이해하고 개선할 수 있도록 하는 기능을 백엔드 서버에 구축함.
 |
| (8-7) 과제: 기대 효과 및 의의 | 
i.	수면장애 고위험군 치료 확률 증대
본 어플리케이션은 사용자의 수면호흡음 및 심전도 데이터를 분석하여 수면장애 위험 수준을 이해하기 쉽게 구현하여 제시함. 이러한 판독 결과를 기반으로 수면장애 고위험군이 증상을 인지하고 병원에 내방하여 치료를 받기까지 소요되는 시간을 줄일 수 있음. 백분위 숫자가 적으면 적을수록 의료 급여 정책에서 소외될 확률 또한 적으므로 현재 치료가 필요한 인구가 적기에 의학적 도움을 받기를 기대할 수 있음. 
ii.	지속적인 관리를 통한 수면 습관 개선 용이
수면장애 진단을 받는다고 하더라도 매일 병원에서 수면 습관을 확인하기는 불가능에 가까움. 본 어플리케이션은 축적된 사용자의 데이터를 한눈에 보기 쉬운 그래프 형태로 제공함. 이러한 기능을 통해 사용자는 지난주, 혹은 지난달에 비해 본인의 수면 습관이 개선되었거나 악화되었는지에 대해 쉽게 인지할 수 있어 지속적인 관리가 가능.|
| (9) 데모 내용 | 
1. 회원가입 및 로그인 화면
2. 수면호흡음 및 심전도 측정 화면
3. 수면호흡음 및 심전도 검사결과 화면  
4. 프로필화면                                                               
5. 수면트래킹 화면 

주요 기능 뿐만 아니라 서브 기능도 데모에 포함함. 중간 데모 때 진행했던 심전도 부분과 더불어 수면호흡음 부분도 추가함. |
| (10) 기타 |  |
[Return TOP](#list-of-teamsprojects)
 
# Team-32
| (1) 과제명 | HobHub: 일상 속 활력 충전을 위한 AI 기반 취미 추천 및 취미 기록 아카이빙 웹 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 32-머니캐처 |
| (3) 팀원 역할 분담 | 박유진(2176149): 리더, 백엔드 개발, aws 서버 배포, 추천 알고리즘 개발<br>최예빈(2176382): 팀원, 프론트엔드 React 개발, UX/UI 디자인, 데이터 크롤링, 챗봇 개발<br>박혜진(2176161): 팀원, 플라스크 서버 구현, 추천 알고리즘 개발, 챗봇 개발 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 하광림 / 씨에스리 / 이사 |
| (6) 과제 키워드(keywords) | 맞춤형 추천, 취미, 아카이빙 |
| (7) 과제 내용 요약 | 맞춤형 추천 알고리즘을 기반으로 사용자에게 최적인 취미를 제공하여 간편하고 빠르게 취미활동을 시작할 수 있도록 돕는 서비스이다. 사용자가 챗봇을 통해 자신의 정보를 입력하면 취미를 추천받을 수 있을 뿐만 아니라 추천받은 취미를 공유하고 저장하는 아카이빙 서비스 또한 제공한다. |
| (8-1) 과제: 문제의 정의 | 개인마다 각자의 취향도 다르고 취미를 즐기는 목적도 다를텐데, 자신에게 맞는 취미를 찾기까지 소요되는 시간적 비용과 경제적 비용이 크다는점은 취미를 시작하는 사람들에게 어려움을 줄 수 있다. 또한 취미에 대한 정보가 너무 많고 여기저기 흩어져있기 때문에 취미를 시작하려고 해도 어디서 어떻게 시작해야할 지 모르는 경우가 있다. 그리고 취미를 새로 시작한다 해도 동기부여가 없어 지속적인 취미생활을 하기 힘들다는 문제점이 있다. |
| (8-2) 과제: 기존연구와의 비교 | 클래스101 : 온라인 강의를 제공하여 시간과 장소에 구애받지 않고 취미생활을 즐길 수 있도록 돕는 서비스이다. 온라인 강의와 준비물키트까지 함께 제공하여 사용자들이 언제 어디서든 취미생활을 즐길 수 있다는 강점이 있다. 이용자 사전 수요조사를 통해 수강자가 충분할 것이라고 확인되는 클래스만 개설하는 방식으로 서비스를 운영하여 수요가 적은 취미 활동들은 즐길 수가 없다는 약점이 있다.<br>솜씨당 : 지역기반 공방정보와 가격을 고객에게 제공하여 가까운 곳에서 취미생활을 즐길 수 있게 하는 서비스이다. 온라인과 오프라인을 연결해주는 o2o 서비스를 운영하여 실제 운영되고 있는 공방의 원데이클래스를 예약할 수 있는 플랫폼을 제공하고, 비대면을 원할경우 공방과 고객사이의 라이브강의가 가능한 플랫폼을 제공한다는 강점이 있다. 수공예 관련한 클래스들에만 집중되어 있어 다른 카테고리는 부실하다는 약점이 있다. |
| (8-3) 과제: 제안 내용 | 첫번째, 취미를 시작하는데 들이는 시간적, 경제적인 비용을 최소화하기 위해 사용자의 상황을 반영한 맞춤형 취미를 추천한다. 사용자의 나이대, 성별, 사는곳, 소득, 시간적여유, 그리고 취미를 하는 목적을 반영해서 사용자와 가장 유사한 조건에 있는 유저의 취미를 추천해준다.<br>두번째, 취미를 쉽고 빠르게 시작할 수 있도록 원데이클래스 사이트에서 크롤링한 원데이클래스 목록을 제공한다.<br>마지막으로 사용자에게 지속적인 취미생활의 동기부여를 제공하기 위해 취미 아카이브에 자신의 취미생활을 기록하고 공유할 수 있도록 한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 추천 알고리즘: 사용자의 정보를 입력받아 사용자와 조건이 유사한 다른 사용자의 취미를 추천해주는 유사도 기반 추천 시스템, 사용자가 정보를 제공하고싶지 않은 경우는 자신의 기존 취미를 입력하여 추천받는 사용자기반 협업 필터링 알고리즘을 사용한다.<br><br>2. 원데이클래스 목록: 취미를 추천 받은 뒤, 그 취미를 빠르게 시작할 수 있도록  그에대한 원데이 클래스를 크롤링해 보여준다. 이때 사용자들이 중요하게 생각할만한 원데이 클래스의 위치, 가격, 난이도, 소요시간에 대한 정보들을 중점적으로 보여주도록 구현했다.<br><br>3. 취미 아카이빙: 사용자는 취미 아카이브를 통해 취미생활을 기록할 수 있고, 사용자와 유사한 특징을 가진 다른 사용자들이 남긴 취미 기록을 확인하고 공유할 수 있다. |
| (8-5) 과제: 구현 방법 |1. Dialogflow를 이용한 챗봇 서비스<br>사용자는 Dialogflow를 사용해 구현한 챗봇을 통해 자신의 정보를 입력한다. 사용자는 자신의 성별, 사는지역, 취미를 하는 목표, 주중 취미를 즐길수 있는 시간 등을 입력하거나, 이미 기존 취미가 있는 경우에는 자신이 원래 가지고 있던 취미를 입력한다. 이렇게 입력한 정보는 Flask로 전달되어 추천 알고리즘의 입력값으로 들어간다.<br>2. 2가지 추천 알고리즘으로 취미 추천<br>Flask에서 유사도 기반 알고리즘을 통해 사용자의 기존 정보가 없는 경우, 챗봇으로 사용자의 정보를 입력받아 사용자와 조건이 가장 유사한 다른 유저의 취미를 추천해준다. 또한 기존의 취미가 있는 경우 협업 필터링을 사용해서 취미를 추천한다. 추천한 결과는 react를 통해 웹사이트에 보여지고, 취미 추가하기를 누르면 유저정보와 취미가 백엔드 스프링에 저장된다.<br>3. 추천받은 취미에 대한 원데이클래스 목록 제공<br>사용자가 취미를 추천받으면 Flask에서 실시간으로 사용자의 취미에 대한 원데이클래스를 불러온다. 이는 BeautifulSoup을 이용한 실시간 크롤링 기법을 사용하였으며, 사용자의 편의를 위해 원데이클래스의 가격대, 소요시간, 난이도 순으로 보여준다.<br>4. 취미 아카이빙 서비스<br>추천받은 취미에 대한 기록을 남길 수 있다. aws에서 제공하는 rds 서버를 통해 사용자의 정보를 관리하고 사용자가 남긴 취미기록 또한 저장하고 관리합니다.<br>5. 피드백 기능<br>추천받은 취미에 대한 피드백을 반영할 수 있다. 사용자는 챗봇을 통해 추춴받은 취미에 대한 평점을 남길 수 있고, 이는 다음 추천때 반영되어 더욱 정교한 추천을 해줄 수 있다.|
| (8-6) 과제: 세부 기술 | **1. 유사도 기반 알고리즘**<br>추천 알고리즘에서 흔히 발생하는 콜드스타트 문제를 해결하기 위해 도입한 알고리즘이다. 사용자가 서비스를 처음 사용하는 경우, 정보가 없어 추천해주지 못하기 때문에 먼저 챗봇을 이용해 사용자의 정보를 입력받는다. 유클리디언 유사도 기법을 써서 사용자가 입력한 정보와 가장 유사한 사용자를 찾고, 그 사용자가 가진 취미를 추천해주고 그에 대한 유사도가 몇퍼센트 나오는지 출력되도록 구현했다.<br>**2. 사용자기반 협업 필터링 알고리즘**<br>원데이클래스 사이트인 솜씨당에서 크롤링한 데이터를 바탕으로 구현했다. 사용자들이 경험한 취미와 경험하지 않은 취미들에 대한 데이터인데, 사용자들이 경험했던 취미를 5, 경험하지 않았던 취미는 3으로 두었다. 새로운 사용자가 자신이 기존에 했던 취미를 고르면, 다른 사용자들의 데이터와 비교해 가장 유사도가 높은 취미를 추천하도록 구현했다. 추천받은 취미의 벡터값은 5가 되지만 이 벡터값은 추후 피드백을 통해 조정될 수 있어서 만약 추천받은 취미가 잘 맞지 않았다면 피드백을 통해 값을 더 낮은 값으로 조정할 수 있다.|
| (8-7) 과제: 기대 효과 및 의의 |**1. 더 개인화된 취미 추천**<br>기존의 다른 서비스과 비교했을 때, 사용자의 상황을 최대한 반영해 더욱 개인화된 맞춤형 취미를 추천해주고자 한다. 사용자의 기존 취미를 반영하기도, 소득이나 위치 등과 같은 개인적인 정보들을 반영하기도 해, 이러한 데이터를 추천 알고리즘에 활용하고 있다. 또한, 취미 추천을 해준 이후에도, 챗봇을 통해 취미에 대한 피드백을 남길 수 있는 기능을 추가했고, 추후 최종발표에는 이러한 피드백이 취미 추천에 반영되어 추천 기능을 한층 더 개선하고자 하고 있다.<br>**2. 보다 다양한 취미에 대한 기회 제공**<br>취미에 대한 데이터 중 사용자에게 필요한 것들을 중점으로 모아서 보여줄 수 있다는 점에서 사용자에게 보다 많은 기회를 제공한다는 의미가 있다. 우리 서비스는 추천 받은 취미에 대한 실시간 원데이 클래스 정보를 제공해 원하는 취미를 쉽게 선택하고 즐길 수 있게끔 하고 있다. 또, 아카이브 기능을 통해 사용자들이 자신의 취미 기록을 공유할 수 있기 때문에 자신과 비슷한 조건을 가진 유저가 어떤 취미를 가지고있는지 알 수가 있어서 사용자들은 자신이 추천받은 취미 뿐만 아니라 더 다양한 취미를 접할 수 있다.|
| (9) 데모 내용 |1. 먼저 챗봇으로 사용자가 취미 추천을 받는 것으로 시작된다. 챗봇에게 인사를 건네고 취미 추천 받기 버튼을 선택한다.<br>기존 취미가 없는 사용자라는 가정 하에 그에 따라 성별, 나이, 위치, 소득, 목적, 주중/주간 시간에 대한 정보를 입력한다.정보 입력이 완료되면 취미 추천 페이지로 이동해 유사도 기반 알고리즘을 통해 산출된 추천 취미들을 볼 수 있다.<br>2. 그 다음 기존 취미가 있는 사용자라고 가정을 하고 (1)과 마찬가지로 챗봇을 통해 추천을 받아본다.<br>기존 취미를 개수 제한 없이 선택한 뒤 선택 완료 버튼을 누르면 협업 필터링 알고리즘을 통해 산출된 추천 취미들을 확인 할 수 있다.<br>3. 다음은 취미를 기록하는 아카이브 기능이다.<br>추천받은 취미 리스트에서 서랍장에 추가하기 버튼을 누르면 해당 취미 폴더가 추가된 것을 확인 할 수 있다. 그리고 폴더 안에 들어가면 사진을 첨부하는 등 그 취미와 관련된 기록을 남길 수 있다.|
| (10) 기타 | 시스템 아키택처![제목 없음](https://github.com/beenvyn/CapstoneDesign-24-1H/assets/109021332/dd0b7580-15f4-4fa5-a297-53e5e6be8d4c)|
 
[Return TOP](#list-of-teamsprojects)
 
# Team-33
| (1) 과제명 | 공유니폼 : 야구 팬을 위한 사용자 기반 추천 유니폼 대여 앱 및 대여 자판기
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 33-Donuts |
| (3) 팀원 역할 분담 | 권가현(2071059) : 리더, 백엔드, UI 기획, 경기 기록 기반 선수 추천 알고리즘<br>김선우(2076052) : 팀원, 백엔드, UI 기획, 사용자 간 유사도 기반 유니폼 추천 알고리즘<br>유지우(2076269) : 팀원, 프런트엔드, UI 디자인, 사용자 응답 기반 선수 추천 알고리즘 |
| (4) 팀 지도교수 | 박상수 교수님 |
| (5) 팀 멘토 | 이강현 / 돌핀씨엔씨 / 사업본부장 |
| (6) 과제 키워드(keywords) | 야구유니폼, 대여, 자판기 |
| (7) 과제 내용 요약 | 공유니폼은 비싼 야구 유니폼을 합리적인 가격으로 대여해주어 야구 직관을 더욱 즐기도록 도와주는 서비스입니다. 어플을 통해 유니폼의 디자인과 선수 이름, 등번호를 선택하고 결제합니다. 이후 발급된 QR 코드로 IOT 자판기에서 유니폼을 수령합니다. 저희는 이용자의 선택을 돕기 위해 야구 선수 및 유니폼을 추천해주는 알고리즘을 도입했습니다. 선수 기록 및 다른 이용자들과의 유사도를 통해 이용자에게 적합한 선수를 추천합니다. |
| (8-1) 과제: 문제의 정의 | 야구장에 가면 대부분의 팬들이 유니폼을 입고 응원합니다. 야구를 가끔 즐기는 사람들에겐 13만원이 넘는 유니폼 가격이 부담스러울 수 밖에 없습니다. 저희는 모든 사람이 야구 문화를 온전히 즐기도록 합리적인 가격에 유니폼을 대여해주는 서비스입니다. 또한 저희는 자판기와 어플을 통해 대여하는데 필요한 시간을 줄이고 어디서든 대여가 가능하게 도와줍니다. 또 야구 유니폼을 구매할 때 유니폼 선택지의 폭이 너무 넓다는 문제가 있습니다. 팬들은 좋아하는 선수와 디자인 역시 선택해야 하기 때문에 비싼 유니폼 구매를 앞두고 어떤 유니폼을 고를 것인가에 대해 많은 고민을 하게 됩니다. 따라서 비싼 가격과 넓은 선택지는 야구 팬들로 하여금 유니폼 구매를 망설이게 만들고 다양한 유니폼을 경험하는 것을 어렵게 만들고 있습니다. |
| (8-2) 과제: 기존연구와의 비교 | 기존의 서비스는 블로그 댓글로 유니폼 대여를 신청 한 후 다음날 야구장에서 수령하는 인건비가 많이 필요한 방식입니다. 게다가 블로그 댓글은 판매자가 일일이 종류 및 사이즈를 기록해야하는 불편함이 있습니다. 수동 기록이라 실수가 생기기도 합니다. <br>다른 경우는, 축구단에서 유니폼을 보증금 1만원을 받고 이벤트성으로 대여를 해준 적이 있습니다. 여긴 보증금이 낮고, 이벤트를 통해 축구장 관중 유입 효과를 노렸으며 기존 팬들도 입어보고 싶던 유니폼을 입는 등 좋은 반응을 이끌어냈습니다. |
| (8-3) 과제: 제안 내용 | 저희는 안드로이드 앱과 IOT자판기, 세 가지 추천 알고리즘을 통해 저희가 제안한 유니폼의 비싼 가격과 넓은 선택지라는 문제를 해결하려 합니다. 또한 다른 서비스와의 비교를 통해 사람의 손이 많이 가는 부분도 최소화 할 계획입니다. 자동화를 통해 인건비를 줄이고 대여 과정이 간단해지는 효과를 볼 수 있습니다.|
| (8-4) 과제: 과제의 주요 기능 | 공식 유니폼을 야구장에서 대여해주는 서비스<br>야구 선수 및 유니폼을 추천하는 서비스<br>- 경기 기록 기반 선수 추천<br>- 사용자 유사도 기반 유니폼, 선수 추천<br>IoT 자판기를 통해 대여 과정을 자동화 하는 기능 |
| (8-5) 과제: 구현 방법 | |
| (8-6) 과제: 세부 기술 | |
| (8-7) 과제: 기대 효과 및 의의 | |
| (9) 데모 내용 | |
| (10) 기타 | |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-34
| (1) 과제명 | 돈워리(Be happy) - 일정 및 소비데이터를 활용한 예산 사용량 예측 AI 기반 모바일 웹 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 34-고등어 |
| (3) 팀원 역할 분담 | 이규민(2076291): 리더, (백엔드) MySQL, Spring Framework, AWS, 데이터전처리<br>서선아(2003047): 팀원, (프론트엔드) Figma, React.js, AI<br>공채은(2176020): 팀원, (백엔드) OCR, MySQL, Spring Framework, AWS, AI |
| (4) 팀 지도교수 | 이민수 교수님 |
| (5) 팀 멘토 | 이성훈 / 나우썸 / 대표 |
| (6) 과제 키워드(keywords) | 예산, 일정, AI |
| (7) 과제 내용 요약 | "돈 워리(Be Happy)"는 일정과 소비 데이터를 학습시킨 AI 모델로 예산 사용량을 예측하고 사용자의 니즈에 맞게 한 달 예산을 분배하여 소비 습관이 잡히지 않은 사회초년생의 돈 관리를 돕는 서비스입니다. 일정과 가계부를 한 번에 작성함으로써, 각 일정이 소비생활과 직접적으로 연결됨을 보다쉽게 체감하고, 예산 예측량과 예산 사용 가능량을 비교하며 무분별한 소비를 경계합니다. 또한 친구와 예산 사용량(%)을 공유하고 자체 챌린지를 진행함으로써 돈 관리에 재미요소를 부여하고 리워드를 지급함으로써 동기부여 효과를 가져옵니다. |
| (8-1) 과제: 문제의 정의 | 건강한 소비활동에 대한 확실한 기준이 잡히지 않은 사회초년생은 카드 리볼빙이나 과소비 등의 위험에 쉽게 노출되어 있다. 사회초년생은 본격적인 경제활동을 시작함에 앞서 올바른 돈 관리 기준이 필요한 시기이다. 돈 관리에 스트레스와 번거로움을 느끼지 않도록 현명한 소비습관을 형성하면서 자산관리도 동시에 할 수 있는 차별화된 서비스가 필요하다. |
| (8-2) 과제: 기존연구와의 비교 | 기존 가계부 서비스와의 차별성 4가지<br>( banksalad, 편한가계부, 핀크, Uplanner, visual 가계부, 꼬박가계부, DAILY PAY 외 6개의 서비스를 분석해 4가지의 측면에서 차별성을 두었다.)<br><br> 1. 기록<br>기존에는 기록에 있어서 카드 연동과, 결제 내역을 자동으로 불러오는 기능이 있긴 하지만 가계부 관련 내역만을 불러오는데 돈워리는 가계부 내역과 일정 내역을 통합시켜 일정까지 관리할 수 있도록 하였다. 더불어 OCR기술을 도입해 편리하게 소비내역을 기록할 수 있도록 하였다.<br><br>2. 예산 기능<br>기존에는 예산을 손수 지출 카테고리별로 분배해야 했지만, 돈워리를 통해 일정내역을 통해서 머신러닝 알고리즘과 분배함수를 가지고 자동으로 분배해 좀 더 편리하게 만들어주고, 카테고리별 큰 분류뿐만 아니라 일정마다 세세하게 예산을 분배할 수 있도록 하였다. 또한 예산 목표를 설정할 때, 캐릭터로 시각화하여 차별화하였다.<br><br>3. 통계 기능<br>기존의 가계부 서비스들처럼 분석 메시지를 제공하되, 돈워리의 대상인 사회초년생를 타겟팅하는 메시지로 차별성을 두었다.<br><br>4. 챌린지 기능<br>기존의 몇몇 챌린지 기능은 목표를 설정한 후, 친구와 함께 챌린지를 할 수 있는 기능이 있으나, 이와 차별화하여 예산 사용량을 공유하고, 리워드와 랭킹 기능을 추가하는 것뿐만 아니라, 모으고자하는 목표금액에 멀어지는 게 감지되면, 그날 하루의 미션 팝업을 제공해 행동으로 이어질 수 있도록 유도하는 기능을 추가했다. |
| (8-3) 과제: 제안 내용 | 1. 사용자가 등록한 일정과 소비내역 데이터를 바탕으로 소비 패턴을 분석하고, 각 일정에 대한 예산 사용량을 예측하고 제공한다. 또한 사용자의 니즈에 맞는 소비 가이드라인을 제시하여 한 달 예산을 적절하게 분배하여 사용하도록 돕는다. <br>2. 건강한 소비 습관을 보다 쉽게 구축하도록 가계부에 일상적으로 사용하는 일정 리스트 기능을 넣고, ocr 기술 적용해 소비 기록의 편의성을 높인다. 또한 사용량 공유, 챌린지로  친구와 서비스 사용을 함께함으로써 돈 관리에 적당한 동기부여와 재미를 제공한다. |
| (8-4) 과제: 과제의 주요 기능 | 1) 일정 데이터 CRUD<br>2) 가계부 기능 <br>: 수입/지출 데이터 CRUD<br>3) 예산 사용량 예측 기능<br>: 사용자의 일정-가계부 데이터로 학습시킨 다중선형회귀모델을 이용하여 새로운 일정에 대한 예산 사용량을 예측하는 기능. 일정 카테고리를 메인으로 사용한다.<br>4) 예산 분배 기능<br>: 사용자가 카테고리별 소비 가중치와 절약 정도를 직접 선택하면 각 일정 및 지출 카테고리에 대해 월별 예산을 분배해주는 기능<br>5) OCR 활용 지출 등록 기능<br>: OCR을 활용해 사용자의 결제 문자를 스캔해 가계부 지출에 입력해주는 기능<br>6) 통계 기능<br>: 사용자의 월별 사용량을 분석해 소비패턴을 한눈에 파악할 수 있도록 보여주는 기능<br>7) 챌린지 기능<br>: 사용자가 자신의 소비습관에 맞는 챌린지에 참여하며 돈관리에 재미를 주는 기능<br>7-1) 사용량 공유 기능<br>: 친구와 예산 사용량을 공유함으로써 돈 관리의 동기부여와 재미를 제공한다. |
| (8-5) 과제: 구현 방법 | 1. 모바일 웹 페이지<br>: React로 개발한다.<br> <br>2. 일정 관리 기능<br>: 데이터베이스에 일정을 등록하고, 조회하고, 수정하고, 삭제한다. CRUD 처리 로직은 Spring Boot로 구현한다. 메인화면에서 가계부 데이터와 함께 확인할 수 있다. <br> <br>3. 가계부 관리 기능<br>: 데이터베이스에 수입, 지출 내역을 등록하고, 조회하고, 수정하고, 삭제한다. CRUD 처리 로직은 Spring Boot로 구현한다. 메인화면에서 일정과 함께 확인할 수 있다. 특정 일정에서의 소비와 일반 소비는 분리된다.<br> <br>4. 예산 사용량 예측 기능<br>: 구글 코랩에서 scikit-learn를 이용해 일정 데이터와 가계부 데이터로 다중선형회귀모델을 학습시키고 flask api로 래핑하여 배포한다. API 서버에서 flask api로 해당 모델을 사용한다. 사용자가 새로 입력한 일정에 대한 예산 사용량을 예측하여 제공한다.<br> <br>5. 예산 분배 기능<br>: 백엔드 서버에서 구현한 비즈니스 로직이 일정, 소비내역, 예산 예측 데이터를 바탕으로 전체 예산에 대한 한달 예산 사용 계획을 제안한다. 사용자는 예산 분배 플랜 화면에서 전체 예산 절약 정도, 매일 절약 금액, 카테고리별 절약 정도 중 원하는 것을 선택할 수 있다. <br> <br>6. OCR 소비 스캔 기능<br>: 소비 등록 화면에서 결제 문자 캡쳐 사진을 업로드하여 자동으로 지출을 등록한다. OCR이 사진에서 인식한 텍스트를 전달하면 백엔드 서버에서 가계부 등록과 같은 방식으로 데이터를 처리하고 데이터베이스에 저장한다. <br> <br>7. 챌린지 기능<br>: 데이터베이스에서 사용자가 진행 중인 챌린지를 조회해 데이터를 가져온다. 사용자는 챌린지 화면에서 자신의 챌린지를 확인하고 새로운 챌린지를 진행할 수도 있다. <br>1) 예산 사용량 챌린지: 이메일로 친구를 초대해 서로의 예산 사용량을 공유한다. 친구와 나의 예산 사용량을 막대그래프로 한눈에 비교하고 확인할 수 있다. 데이터베이스에서 사용자의 친구 목록과 해당 친구의 예산 대비 사용량을 불러온다. <br>2) 친구와 예산 사용량 및 목표 금액 달성률 공유: 사용자의 친구로 저장되어 있는 사용자들의 예산 사용량 및 목표 금액 달성률을 합산한 후 막대그래프로 사용자와 비교해 보여줌 <br>3) 목표 금액 달성률: 목표 금액을 얼만큼 달성했는지 막대그래프로 보여줌<br>4) 한달 목표 금액 달성 여부: 매달 목표금액을 달성했는지 월별로 여부를 보여줌<br>5) 무지출 챌린지 10번: 이번달에 하루 무지출 챌린지를 10번 수행했는지 미션을 부여하고 현재까지 달성한 횟수를 보여줌. <br>6) 한달에 특정 “카테고리”의 소비 제한: 사용자의 최대 소비 카테고리에 대해 지정한 제한 횟수를 지켰는지 월별로 보여줌.<br>7) 뱃지 기능: 챌린지 목표를 달성할 때마다 뱃지를 수여한다. <br> <br>8. 통계 기능<br>: 데이터베이스에서 사용자의 월별 가계부 데이터를 조회하고 수입-지출을 카테고리별로 구분지어 금액 총합을 보여준다. 막대 그래프로 카테고리별 사용량을, 꺾은선 그래프로는 예산 사용 추이를 확인할 수 있다.<br> <br>9. 로그인 기능<br>: OAuth2.0으로 구글 로그인을 구현한다. 사용자는 자신의 구글 계정으로 서비스에 로그인할 수 있다. 첫 로그인 시 데이터베이스에 이메일 주소와 계정 이름을 저장한다. 저장된 데이터는 사용자 인증이 필요한 서비스 이용이나 친구 초대 시 사용된다.<br> <br>10. 웹 애플리케이션 배포<br>: 프론트 웹 애플리케이션은 NginX로, 백엔드 웹 애플리케이션은 AWS EC2 인스턴스로 배포한다. 클라우드 데이터베이스로는 AWS RDS MySQL 데이터베이스를 사용한다. |
| (8-6) 과제: 세부 기술 | 1. 프론트엔드: React <br>React로 사용자에게 제공되는 웹 애플리케이션 인터페이스를 구현한다. UI를 표시하여 사용자와의 상호작용을 담당한다. Figma를 이용해 UI 컴포넌트를 디자인한다. <br>사용자가 일정과 가계부를 작성하고 저장된 내역을 조회할 수 있다. 예산 절약 플랜을 선택하고 진행 중인 챌린지 목록을 확인할 수 있다. 예산 사용에 대한 통계와 예산 사용 예측 값을 제공한다.  <br>비동기 이벤트 기반 구조를 가지는 웹서버 Nginx로 React를 배포해 외부 클라이언트 요청을 컨트롤한다. Nginx는 클라이언트인 웹 브라우저로부터 HTTP 요청을 받아들이고 React로 작성한 문서인 웹페이지를 반환하는 식으로 작동한다. <br> <br>2. 백엔드: Spring Boot <br>Spring Boot 프레임워크로 시스템의 핵심 비즈니스 로직을 구현한다. 사용자 요청을 받아 처리하고 데이터베이스와의 상호 작용을 담당한다. 예산 예측 모델을 사용해야 하는 경우 Flask API에 대한 요청을 보내고 응답을 처리한다.  <br> Spring Boot 애플리케이션은 AWS EC2 인스턴스 Ubuntu SERVER 22.04 LTS에서 배포되고 내장 tomcat을 웹 서버로 사용하여 서비스를 제공한다. Spring Data JPA를 사용하여 데이터베이스에서 데이터를 읽고 쓰는 작업을 수행한다.  <br> <br>3. 데이터베이스: AWS RDS MySQL <br>AWS RDS에 MySQL 데이터베이스 서버를 호스팅한다. 사용자가 프론트엔드에서 입력한 데이터는 사용자 권한 확인을 거쳐 데이터베이스에 저장된다. 데이터베이스는 사용자 정보, 일정 정보, 가계부 내역, 예산 정보 등을 저장한다.  <br> <br>4. 보안 및 인증: Spring Security, OAuth 2.0 <br>Spring Security는 사용자 인증 및 권한 부여를 담당하며, OAuth 2.0 프로토콜을 사용하여 사용자 로그인을 처리한다. 사용자가 OAuth 2.0을 사용하여 로그인하고 인증 서버로부터 액세스 토큰을 발급받는다. API 서버는 해당 토큰이 유효한지 검증함으로써 요청을 보낸 사용자를 인증하고 요청을 처리한다. 필요시 데이터베이스와 통신한다. OAuth 2.0 액세스 토큰 검증 로직은 Spring Security를 통해 API 서버에 구현된다. <br> <br>5. 외부 서비스 연동: Flask, scikit-learn, OCR <br> scikit-learn을 사용하여 머신러닝 모델을 학습시키고, 학습된 모델은 Flask API로 배포한다. 또한 OCR을 사용하여, 캡쳐된 결제 문자 이미지에서 텍스트를 추출하고 그 내용을 가계부 내역으로 등록한다.  <br>구글 코랩에서 scikit-learn 머신러닝 라이브러리를 사용해 예산 사용량 예측을 위한 다중선형회귀모델을 학습한다. 학습에는 사용자가 입력한 일정 데이터, 가계부 데이터가 사용된다. 학습된 모델을 Flask API로 래핑하여 서버에 배포하여 Spring Boot 애플리케이션에서 접근할 수 있도록 한다. Flask API로 Spring Boot 애플리케이션에서는 학습된 모델을 사용하여 예측을 수행하고 결과를 처리한다.  <br>사용자가 웹 브라우저를 통해 업로드한 결제 문자 캡쳐는 OCR 서비스에 전달되고, OCR 서비스는 이미지에서 텍스트를 추출하고 인식한다. 추출된 결과 텍스트를 클라이언트로 반환하고 필요한 부분만 필터링하여 데이터베이스 가계부 테이블에 저장한다.|
| (8-7) 과제: 기대 효과 및 의의 | 1.기대효과<br> <br>-소비량 예측값 제공 관점 <br>:사용자는 자신의 자산으로 얼마 정도의 소비가 적절한지 알 수 있으며 일상생활을 하며 자신이 어떠한 지출을 추가적으로 하는지 쉽게 파악할 수 있다. 일정을 입력할 수 있는 탭과 소비-지출 내역을 입력할 수 있는 탭을 구분하여 작성할 수 있게 하며 일정이 리스트 형태로 나타나면서 예상 사용량과 사용 가능량을 동시에 표시하여 쉽게 비교할 있도록 한다. 자신이 입력한 월별 수입으로부터 기반한 사용 가능량과 예상 사용량을 비교하게 되면 실시간으로 자신이 과소비를 하고 있는지 확인할 수 있다. 평소 과소비를 하는 사용자는 예측값을 보며 자신의 소비량을 줄이려는 노력을 할 수 있고, 지나치게 저축을 지향하는 사용자는 최소 사용 가능량을 확인하며 좀 더 융통성 있는 소비를 할 수 있다. 또한 자신의 수입 대비 적절한 지출 수준을 확인할 수 있어 과소비의 지표가 되어줄 것이다.<br> <br>-챌린지 및 리워드 관점 <br>:사용량 예측뿐만 아니라 소비 챌린지로 돈 관리에 대한 재미를 심어줄 수 있다. 소비자가 스스로 하루의 소비 상한선을 정해 소비 줄이기에 도전하는 나만의 챌린지와 비슷한 나이대의 사람들과 소비량을 퍼센트로 비교하며 자신의 소비 수준을 알아볼 수 있고, 성공시 리워드를 지급받아 돈관리에 재미를 붙이도록 유도한다.<br><br>-소비량 공유 관점<br>:친한 친구와 사용량 퍼센트를 공유하면서 서로의 소비를 주의할 수 있고 함께 챌린지를 만들고 성공할 경우 리워드를 지급하는 방식으로 돈 관리에 흥미를 제공한다. <br><br>2. 의의<br><br>우리 서비스는 돈관리의 양극에 있는 사람들이 현명한 소비를 할 수 있도록 가이드를 제공하고 돈 관리가 어렵고 낯선 사회초년생에게는 돈 관리에 챌린지와 같은 재미요소를 더해준다. 가계부가 익숙하지 않을 수 있는 점을 보완하기 위해 일정과 가계부를 통합하여 돈 관리를 일정 관리의 일부분처럼 일상에 녹아들게 함으로써 돈 관리를 자연스럽게 습관화 시킨다. 또한 예산 예측량을 제공해 사용자의 수입에 맞는 적절한 소비량을 알려주어 사용자가 과소비를 멀리할 수 있도록 한다. 돈워리(Be Happy)는 일정과 가계부를 통합하여 사용자가 일정별 예측 사용량과 사용 가능 예산을 한눈에 비교하며 과소비를 피할 수 있도록 하며, 챌린지 등 재미 요소까지 포함한, 이제 막 돈 관리를 시작하는 사회초년생에게 필요한 차별화된 서비스로 그 의미가 있다. |
| (9) 데모 내용 | 중간데모<br><br>1) 가계부-일정 통합 기능<br>가계부와 일정을 통합하여 리스트 형식으로 보여주는 화면으로, 데모 날짜에 해당하는 일정과 가계부 데이터를 데이터베이스에서 불러와 화면으로 보여주었다.<br>2) 새 일정 추가 기능<br>가계부-일정 통합 화면에서 아래쪽의 버튼을 눌러 새 일정을 입력할 수 있는 모달이 뜨는 것을 보여주었다. 모달에 일정 이름을 입력하고, 날짜와 카테고리를 선택해서 추가하는 기능을 보여주었다.<br>3) 예산 예측 기능<br>가계부-일정 리스트 화면에서, 새 일정을 등록하면, 프론트와 연결된 flask 서버의 budget.py의 budgetpredict 함수가 실행되면서, 다중선형회귀 모델이 일정에 대한 예산 사용량을 예측한 후, 등록된 새 일정과 함께 예측 예산 사용량을 보여주었다.<br>4) 예산 사용량 기능<br>이번달의 현재까지의 예산 사용량을 막대그래프로 보여주었다.<br>5) OCR 기능<br>새 지출 내역을 등록할 때, 사진 파일에서 불러온 문자 내역을 화면에 보여주었다. 그리고 flask 서버에 연결된 app.py의 easyocr가 실행되면서 문자 내역 속에서 날짜, 가게 이름, 지출 금액을 인식한 것을 팝업을 띄워 보여주었다. 인식한 내용이 올바른지 확인한 후 등록하게 되면 마찬가지로 가계부-일정 리스트 화면에 새로 추가되는 것을 보여주었다.<br><br>추가될 데모<br> <br>1) 예산 예측 및 분배 기능<br>예산, 목표금액, 달성 기간, 고정지출 카테고리를 입력하는 화면을 데모한다. 예산 사용량을 일정별로 분배할 수 있는 로직을 만들고 이를 잘 보여줄 수 있는 화면을 데모한다.<br>2) 챌린지 기능<br>사용자가 예산 사용량 막대 그래프를 친구와 공유하는 기능을 데모한다. 설정한 목표금액 달성률을 보여줄 수 있는 막대그래프를 데모한다. 사용자의 소비성향에 따라 메시지를 제공하는 화면을 데모한다. 목표금액을 모을 수 있도록 그날 할 수 있는 미션을 제공하는 것을 데모한다.<br> |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-35
| (1) 과제명 | 영상 일기 플랫폼 log: NLP를 활용한 간편하고 생생한 일기 기록
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 35-log |
| (3) 팀원 역할 분담 | 배주연(1971023): 리더, UI/UX 디자인, 프론트/백엔드 서버 프로그래밍,  MySQL 구축<br>김희진(2029011): 팀원, NLP 모델링, 프론트/백엔드 서버 프로그래밍, 서버 구축,  MySQL 구축<br>정지혜(2029037): 팀원, NLP 모델링, 프론트/백엔드 서버 프로그래밍, MySQL 구축 |
| (4) 팀 지도교수 | 심재형 |
| (5) 팀 멘토 | 문효진 / 네이버 / 개발자 |
| (6) 과제 키워드(keywords) | 영상일기, 자연어처리, 소셜 네트워크 |
| (7) 과제 내용 요약 | 일기를 쓰는 것은 일상을 기록하는 것 이상의 효과가 있습니다. 하루를 돌아보며 오늘의 의미를 찾을 수 있고, 자아 성찰을 하며 ‘나’에 대해 깊게 이해하도록 도와주기도 합니다. 이로써, 저희 팀은 AI로 간단하게 기록하는 하루의 영상일기 플랫폼 log를 기획하였습니다. 영상 녹화 방식을 이용하여 글보다도 더 쉽고 생생하게 전달할 수 있습니다. log는 일기 요약본, 해시태그, 배경음악도 만들어줍니다. |
| (8-1) 과제: 문제의 정의 | 디지털 문화가 일상이 된 현대 사회에서 아직 일기만 아날로그 형태로 남았습니다. 기존의 텍스트 기반 일기에 분명 한계가 있지만, 이를 해소하는 새로운 일기 플랫폼이 없습니다. 글로는 기억을 생생하게 기록하기도, 친한 친구끼리만 공유하기도 어렵습니다. 영상과 음성 미디어를 활용하여 일기를 작성하고 친한 친구들에게 공유할 수 있는 혁신적인 새로운 일기 플랫폼이 필요합니다. |
| (8-2) 과제: 기존연구와의 비교 | 기존의 텍스트 기반 일기 플랫폼은 널리 사용되고 있으나, 새로운 미디어를 활용한 일기 플랫폼은 상대적으로 부족합니다. 소수의 타 서비스를 분석했을 때, 간편하게 영상으로 일기를 기록할 수 있는 어플은 이미 있지만, 영상 내용에 대한 분석보다는 영상 길이 및 영상을 찍은 장소, 날씨 관련된 통계만을 제공합니다. 개인화된 서비스라기보다, 그저 종이 일기 형태를 온라인으로 옮긴 플랫폼이 대다수였습니다. log는 타 서비스들과 확연히 다릅니다. 사용자들은 영상으로 기억을 더 생생하게 기록하고, AI로 생성된 일기 요약본과 해시태그를 확인하여 간편히 일기 내용을 글로도 볼 수 있습니다. 다른 사용자 간 연결과 공유 기능도 포함됩니다. 영상을 기록하고 공유할 수 있는 서비스를 제공하는 소셜 네트워크 서비스와 달리, log는 일기 서비스에 집중합니다. 영상 속 음성을 텍스트로 변환하여 데이터베이스에 저장하기 때문에 영상 내용을 검색할 수 있다는 차별점을 갖고 있습니다. 본 서비스는 10대~30대를 아우르는 간편하게 영상 일기로 일상을 기록하고 싶은 사람들을 타겟한 서비스입니다. 숏폼 미디어 시대에 맞춰 사용자에게 시각적이면서 간편한 서비스를 제공합니다. |
| (8-3) 과제: 제안 내용 | [달력형 UI]<br>- 달력 형태로 디자인된 로그를 통해 월별 일기를 한 눈에 확인할 수 있습니다.<br><br>[요약문 생성]<br>- 일기 영상 속 음성을 텍스트로 추출하여 요약문을 생성합니다.<br>- 영상을 몇 문장으로 간단히 요약하여 영상을 보지 않고도 내용을 파악할 수 있습니다.<br>- 사용자가 문구를 직접 추가, 수정도 가능합니다.<br><br>[해시태그 생성]<br>- 일기 내용에 대한 해시태그를 AI가 자동으로 생성합니다.<br>- 사용자가 추가하고 싶은 해시태그를 직접 추가, 수정도 가능합니다.<br><br>[친구 공유]<br>- 게시물을 올릴 때 공유 범위를 설정하여 사용자만 볼 수 있는 게시물인지, 친구와 공유할 게시물인지 설정할 수 있습니다.<br>- ID를 검색하여 친구를 신청/수락하고 친구를 맺을 수 있습니다.<br>- 일기별 공개 범위를 설정하여 개인 소장을 하거나 친구와 공유할 수 있습니다.<br>- 친구들의 최근 게시물들을 보고 좋아요와 댓글을 남기며 친구와 소통할 수 있습니다.<br><br>[월별 통계]<br>- 사용자가 해당 달에 가장 많이 사용한 5개의 해시태그 통계를 제공합니다.<br>- 사용자가 영상 일기를 기록할 때 선택한 감정에 대한 월별 통계를 제공합니다.<br><br>[배경음악 추가]<br>- 일기 내용에 알맞은 배경음악을 추가할 수 있습니다.<br>- 일기를 기록할 때 입력한 오늘의 감정을 기반으로 배경 음악을 선정해줍니다.<br>- 일기 영상에 배경 음악이 잔잔하게 재생됩니다.<br><br>[검색]<br>- 사용자는 자신의 일기를 날짜, 공개 범위, 키워드 등을 활용하여 필터링할 수 있습니다.<br>- STT 기능으로 영상 내용을 텍스트로 변환하여 저장하기 때문에 영상 속 내용도 검색이 가능합니다.<br>|
| (8-4) 과제: 과제의 주요 기능 | [Speech-To-Text]<br>- 파이썬의 moviepy 라이브러리를 사용하여 음성 파일 생성<br>- Google Cloud Speech To Text API를 사용하여 텍스트 생성<br><br>[영상 내용 요약 및 해시태그 생성]<br>- KoBART 모델을 fine-tuning하여 일기 요약본 생성<br>- 요약본을 바탕으로 해시태그 생성<br>- rouge score 기준 0.3, bert score 기준 0.8 이상의 성능을 달성하는 것을 목표로 파인튜닝<br><br>[BGM 선정]<br>- 감정 기반 item-based 추천 시스템을 사용하여 선정된 BGM을 영상에 추가 |
| (8-5) 과제: 구현 방법 | [모바일 친화적인 웹페이지]<br>- React로 반응적이면서 깔끔한, 트렌드가 반영된 웹을 완성했습니다.<br>- 달력 형식으로 사용자의 일기 기록을 한눈에 파악할 수 있도록 메인 화면을 구성하였습니다.<br><br>[일기 녹화]<br>- 사용자는 앱 내에서 영상을 찍거나, 앨범에서 영상을 선택하여 업로드 할 수 있습니다.<br>- 일기 녹화 후, 요약문, 해시태그, 배경음악, 공개범위 그리고 오늘의 감정을 선택합니다.<br>- 일기 전문을 저장한 뒤, 사용자 희망대로 데이터베이스에 일기 정보를 반영합니다. 모든 일기의 음성을 추출한 뒤, Google Cloud Speech To Text API를 사용하여 텍스트 전문을 저장합니다.<br>- 만약 요약문과 해시태그 생성을 선택한 경우, 생성 모델을 사용합니다. KoBART 모델을 fine-tuning한 자연어처리 모델을 사용하여 요약본과 해시태그를 생성합니다. 요약본은 일기 전문 STT 텍스트를 기반으로 생성하고, 해시태그는 일기 요약본을 기반으로 생성합니다.<br>- 사용자는 생성된 내용을 수정할 수 있으며 최종적으로 일기를 저장할 수 있습니다.<br>- 사용자가 선택한 감정 기반 item-based 추천 시스템으로 BGM을 추천해줍니다.<br><br>[검색]<br>- 지난 일기에 날짜, 공개 범위, 해시태그, 키워드 등의 제약 조건에 맞는 video_info만 MYSQL 데이터베이스에서 추출하여 텍스트 기반으로 영상일기를 검색할 수 있습니다.<br>- 검색된 일기를 다시 시청하거나, 요약문과 해시태그를 확인할 수 있습니다. 공개 일기의 경우 친구들의 댓글과 좋아요를 확인할 수도 있습니다.<br><br>[통계]<br>- 데이터베이스에서 월별로 사용자의 일기 데이터를 조회합니다. 해당 월에 생성된 해시태그별 횟수를 집계하여 가장 많이 사용된 해시태그 5개와 감정에 대한 통계 자료를 그래프 기반으로 제공합니다.<br><br>[친구 피드]<br>- 데이터베이스에서 현재 친구를 맺은 사용자를 조회합니다. 이후, 영상 정보를 조회하며 일주일 이내 생성된 친구 일기가 있다면 피드에 포함합니다. 친구 일기의 해시태그와 요약문으로 한눈에 일기를 확인할 수 있으며, 영상을 재생하며 전체 일기를 시청할 수도 있습니다. 좋아요와 댓글을 남긴다면 각 정보를 데이터베이스 테이블에 저장합니다.<br><br>[계정 관리]<br>- 계정을 새로 만들기 위해서는 유효한 이메일, 아이디, 비밀번호를 입력해야 합니다. 계정 정보가 새롭게 데이터베이스에 추가되며 사용자 로그인이 가능해집니다.<br>- 올바른 유저네임과 비밀번호를 입력하면 로그인이 됩니다. Flask session 라이브러리를 사용하여 로그인 후 사용자 세션을 유지합니다.<br>- 사용자의 비밀번호는 Flask bcrypt 라이브러리를 사용하여 암호화 합니다. 만약 비밀번호를 재설정 하고 싶다면, 이전 비밀번호를 확인한 뒤, 새롭게 데이터베이스에 저장합니다.<br>- 계정을 삭제한다면 경고 메세지로 사용자 의사를 다시 한번 확인합니다. 최종 삭제 시, 데이터베이스에서 사용자 정보가 삭제됩니다.<br>- 친구 유저네임을 검색하면 친구 요청을 보낼 수 있습니다. 이때 데이터베이스에 친구 요청이 만들어집니다. 친구 요청이 수락되어야만 최종적으로 친구가 맺어집니다.<br>- 친구 요청을 받았다면, 수락 또는 거절할 수 있습니다. 수락 시 친구가 맺어지며 데이터베이스에 친구 상태가 성립됩니다. 친구는 서로 일기 내용을 공유하고, 일기 내용에 소통할 수 있습니다. 친구요청을 거절하면 요청이 삭제됩니다.<br>- 로그아웃 시 세션 정보와 세션 저장소를 비운 뒤, 로그인페이지로 redirect 됩니다.|
| (8-6) 과제: 세부 기술 | [개발 기술]<br>- 웹 개발 (React, Flask 프레임워크)<br>- 데이터 크롤링 (모델링을 위한 데이터셋 구축)<br>- KoBART 모델 파인튜닝 <br><br>[웹 내 상세 기술]<br>- 데이터베이스에서 사용자 정보 조회 후 로그인과 세션 유지 <br>- 서버에 영상 및 이미지 저장 <br>- 친구 정보 조회 후 소셜 피드로 친구 영상과 좋아요, 댓글 정보 로딩 <br>- 친구 영상에 좋아요 / 댓글 남기는 경우 DB와 화면에 반영 <br><br>[일기 녹화]<br>- 사용자는 앱 내에서 영상을 찍거나, 앨범에서 영상을 선택하여 업로드 할 수 있습니다.<br>- 일기 녹화 후, 요약문, 해시태그, 배경음악, 공개범위 그리고 오늘의 감정을 선택합니다.<br>- 일기 전문을 저장한 뒤, 사용자 희망대로 데이터베이스에 일기 정보를 반영합니다. 모든 일기의 음성을 추출한 뒤, Google Cloud Speech To Text API를 사용하여 텍스트 전문을 저장합니다.<br>- 만약 요약문과 해시태그 생성을 선택한 경우, 생성 모델을 사용합니다. KoBART 모델을 fine-tuning한 자연어처리 모델을 사용하여 요약본과 해시태그를 생성합니다. 요약본은 일기 전문 STT 텍스트를 기반으로 생성하고, 해시태그는 일기 요약본을 기반으로 생성합니다.<br>- 사용자는 생성된 내용을 수정할 수 있으며 최종적으로 일기를 저장할 수 있습니다.<br>- 사용자가 선택한 감정 기반 item-based 추천 시스템으로 BGM을 추천해줍니다.<br><br>[검색]<br>- 지난 일기에 날짜, 공개 범위, 해시태그, 키워드 등의 제약 조건에 맞는 video_info만 MYSQL 데이터베이스에서 추출하여 텍스트 기반으로 영상일기를 검색할 수 있습니다.<br>- 검색된 일기를 다시 시청하거나, 요약문과 해시태그를 확인할 수 있습니다. 공개 일기의 경우 친구들의 댓글과 좋아요를 확인할 수도 있습니다.<br><br>[친구 피드]<br>- 데이터베이스에서 현재 친구를 맺은 사용자를 조회합니다. 이후, 영상 정보를 조회하며 일주일 이내 생성된 친구 일기가 있다면 피드에 포함합니다. 친구 일기의 해시태그와 요약문으로 한눈에 일기를 확인할 수 있으며, 영상을 재생하며 전체 일기를 시청할 수도 있습니다. 좋아요와 댓글을 남긴다면 각 정보를 데이터베이스 테이블에 저장합니다. |
| (8-7) 과제: 기대 효과 및 의의 | 사용자를 위해 만들어진 log는 인터페이스가 간편하고, 실용적이며, 사용자의 입력을 최소화합니다. 온라인 플랫폼이기 때문에 일기 작성에 제한이 없으며, 디바이스에 제한받지 않습니다. 사용자가 하루를 기록하는 영상을 업로드하면, log 앱은 영상 내용을 요약하고, 영상 내용 속 키워드를 추출하여 해시태그를 생성해 줍니다. 이전 영상일기 기록을 열면 키워드와 어울리는 배경음악을 자동으로 선정해서 영상과 함께 재생하며, 월별 사용자의 기록을 통계로 확인할 수도 있습니다. 사용자의 일기에 AI가 자동으로 공감, 위로 등의 감상을 남겨주어 사용자는 정서적 안정감을 느낄 수도 있습니다. 영상의 공개 범위를 설정할 수 있어 개인 기록용으로 저장하거나 서로 팔로우 되어 있는 친구들 간에 공유하며 사용할 수도 있습니다. 해당 기능을 활용하여 일기를 통해 일종의 커뮤니티를 구축할 수도 있습니다. |
| (9) 데모 내용 |  [log 웹앱 배포 버전 실행 데모 워크플로우]<br>1) 사용자 계정 생성과 로그인<br>2) 오늘의 일기 녹화<br>3) 요약본, 해시태그 생성과 수정<br>4) 일기 저장과 친구 추가<br>5) 친구 피드 확인<br>6) 통계 확인<br>7) 일기 검색<br><br>[동작 환경]<br>도메인 qr 코드를 제공하여 웹으로 접근 가능 (크롬/사파리 에서 원활하게 작동, 사용자가 실제로 계정을 만들고 로그인하여 일기를 녹화할 수 있도록 데모 시연할  예정)|
| (10) 기타 | <br><a href='https://ifh.cc/v-Y1tCqJ' target='_blank'><img src='https://ifh.cc/g/Y1tCqJ.png' border='0'></a><br>React: client-side 렌더링, 텐센트 클라우드에 배포하여 도메인 접근 가능하도록 구축할 예정 Flask: 백엔드 API 정의 <br>MySQL DB: 사용자 계정, 영상 정보, 영상과 사진 저장 위치 등 사용자 정보 저장 <br>앱 내에서 일기를 텍스트로 변환할 때 Google Cloud STT API 사용 <br>일기별 요약문과 해시태그 생성에는 각각 fine-tuned KoBART 모델 활용 <br> |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-36
| (1) 과제명 | Neverland: 생성형 AI 기반 단체 추억 아카이빙 앱 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 36-레쏘 |
| (3) 팀원 역할 분담 | 지소민(2080035): 리더, 백엔드, 기획<br>김중현(2076088): 팀원, 백엔드, Cloud(AWS EC2, RDS, S3), DB(MySQL, Redis), CI/CD, 기획<br>곽서진(2076016): 팀원, 프론트엔드, 기획, 디자인 |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 고지현 / 이스토닉,디자인코딩 / 대표 |
| (6) 과제 키워드(keywords) | 단체, 추억, 아카이빙 |
| (7) 과제 내용 요약 | 개인 위주의 추억을 넘어서, 추억을 함께한 모두가 하나의 공동 기록을 남기는 단체 추억 아카이빙 서비스, Neverland를 만든다. 단체의 모든 멤버가 함께한 추억을 각자 피드로 기록한 후 피드들을 모아 Stable Diffusion을 통해 대표 이미지를 생성한다. 그 결과, 새로운 추억 기록이 피드로 생성된다.<br>또한, 단체별 추억 기록들을 시간과 공간에 따라 아카이빙함으로써 단체의 발자취를 들여다 볼 수 있고, 추억이 깃든 여러 장소를 지도를 통해 시각적으로 볼 수 있다. |
| (8-1) 과제: 문제의 정의 | 기존 서비스에서의 추억 회상은 개인의 단편적인 기억으로 이루어진다. 하나의 추억에 대해 각자가 기억하고 있는 바가 다르기 때문에 개인이 작성한 기록은 단체 모두의 기억을 반영하는 공통된 추억이 될 수 없다.<br>또한 단체의 추억을 아카이빙하기 어렵다. 단체에 속하더라도 개인의 기록들로 흩어져 있을 뿐, 단체의 추억들을 모아 기록하기 어렵다. |
| (8-2) 과제: 기존연구와의 비교 | 페이스북과 같은 기존의 유사 서비스에서는 그룹 기능이 있지만 그룹 안에서만 피드를 공유한다는 점만 다를 뿐, 개인의 기록이라는 점에서 일반 피드와 다른 것이 없다. 하지만 “Neverland”에서는 같은 추억에 대한 멤버들의 서로 다른 기억들을 합쳐 단체의 공동 추억 기록을 생성한다는 점에서 차별점을 가진다. <br>또한, 페이스북의 그룹 기능의 경우 개인이 작성한 피드의 나열에 그칠 뿐, 그룹의 추억을 아카이빙한다고는 할 수 없다. “Neverland”에서는 한 단체의 추억을 아카이빙할 수 있는 것뿐만 아니라, 그 기록들을 시간, 공간을 기준으로 기록할 수 있다는 점에서 단체 추억 기록의 새로운 접근 방식을 제공한다. |
| (8-3) 과제: 제안 내용 | 함께한 추억들을 같이 기록하고 싶은 사람들에게 다음의 해결책을 제공한다. <br>1. 각자 다르게 기억하는 추억을 모아 하나의 공동 추억 기억으로 자동 생성한다.<br>2. 단체의 추억을 아카이빙할 기회를 제공한다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 그룹의 각 유저가 한 추억에 대한 기억을 글과 이미지를 포함한 피드로 기록한다. 해당 추억에 함께한 모든 유저가 작성한 피드를 모아 Stable Diffusion을 통해 하나의 대표 이미지를 생성한다. 하나의 추억을 대표하는 이미지를 포함한 새로운 추억 기록을 피드로 생성해 기록한다.<br><br>2. 솔루션 1)에서 생성한 단체 추억 기록을 시간과 공간을 기준으로 아카이빙할 수 있다.<br>그저 개인이 작성한 기록의 나열이 아닌, 추억에 함께한 모두의 기억을 합쳐 만든 단체의 추억을 시간의 흐름에 따라 나열해 단체의 발자취를 들여다 볼 수 있다.<br>또한, 단체의 추억이 깃든 여러 장소를 지도를 통해 시각적으로 모아볼 수 있다.<br>    - 시간<br>    그룹별로 기록된 추억 기록들을 시간 순으로 보여준다.<br>    Stable Diffusion으로 생성한 공동의 추억 기록만을 따로 모아보는 기능을 통해 그룹의 추억을 시간 순으로 나열한다.<br>    - 공간<br>    그룹별로 기록된 추억 기록들의 장소를 지도에 나타낸다.<br>    공동의 추억 기록 피드에 작성된 장소를 지도에 좌표로 나타낸다. 이 때, 추억 기록 피드의 대표 이미지를 마커로 사용한다. |
| (8-5) 과제: 구현 방법 | 본 과제의 최종 형태는 iOS 앱이며, 구현하고자 하는 시스템의 구조는 아래와 같다. <br>![architecture](https://github.com/lemonssoju/neverland-client/assets/81500249/4080fd81-6831-4669-add1-9ae7ca3af182) <br> 유저는 iOS 앱을 통해 서비스를 이용할 수 있으며, 유저 측으로부터 여러 요청이 들어오면 가장 먼저 앱 서버(AWS EC2)가 받게 된다. 들어오는 요청에 따라 앱 서버 내부에 실행되고 있는 Spring Boot 프레임워크에서 적절한 로직을 수행하게 되는데, 만약 데이터 접근이 필요한 경우에는 DB(MySQL)와 통신해 데이터를 주고 받는다. 또한, 유저 프로필 이미지나 피드에 포함된 이미지와 같은 이미지 데이터를 저장해야 할 경우에는 이미지 저장용 DB(AWS S3)를 활용한다. “Neverland”의 주요 기능인 공동 추억 기록 자동 생성을 구현하기 위해, 거대언어모델인 Chat-GPT와 이미지 생성 AI인 Stable Diffusion을 활용한다. 가장 먼저, 추억을 함께한 유저들이 작성한 텍스트들을 입력값으로 해 Chat-GPT를 호출하면 텍스트들을 합쳐 하나의 정리된 결과값을 반환한다. 그 반환된 결과 텍스트와 추억 피드에 포함된 이미지를 Stable Diffusion에 입력하면 새로운 공동 추억 이미지를 얻을 수 있다. AI가 자동으로 생성한 추억 이미지와 결과 텍스트를 피드 형태로 만들어 유저에게 다시 반환하면, 유저는 자동으로 생성된 공동 추억 기록을 볼 수 있게 된다.|
| (8-6) 과제: 세부 기술 | [Frontend]<br>- Typescript, React Native를 활용해 크로스 플랫폼 앱을 구축한다. <br>- Axios 라이브러리를 활용해 API를 연결한다. <br>- Kakao Map API를 활용해 지도 뷰를 생성하고, 이미지를 마커로 띄운다. <br><br>[Backend]<br>- Authorization <br>Json Web Token, OAuth2를 활용해 인증/인가 기능을 구현한다. <br>회원가입, 로그인, 로그아웃, 회원탈퇴 기능을 구현한다. <br>- Cloud<br>AWS EC2를 활용해 앱 서버를 구축한다.<br>AWS S3를 활용해 이미지를 저장한다.<br>AWS Route53, ALB를 활용해 도메인 설정 및 HTTPS 프로토콜을 적용한다. <br>- DB<br>AWS RDS(MySQL)와 Redis로 Database를 구축한다.<br>- CI/CD<br>Docker, Github Actions를 활용해 배포 자동화 시스템을 구축한다.<br>- External API<br>Kakao Map API를 활용해 위치 좌표를 저장 및 제공한다.<br><br>[AI]<br>- LLM<br>Chat-GPT를 API로 활용해 여러 개의 추억 기록 텍스트를 튜닝해 Stable Diffusion input용 프롬프트를 효과적으로 생성한다.<br>- Stable Diffusion<br>유저에게 받은 추억 이미지와 Chat-GPT로 튜닝한 프롬프트를 Stable Diffusion의 입력값으로 하여 공동 추억 이미지를 생성한다.|
| (8-7) 과제: 기대 효과 및 의의 |1. 단체의 유대감 강화<br>개인이 아닌 추억을 함께한 모두의 관점을 반영하여 하나의 공동 추억 기록을 자동 생성함으로써, 각자가 다르게 기억하는 추억들을 효과적으로 통합할 수 있다. 이를 통해 단체 내부의 공감대를 형성하고, 모든 단체 구성원이 함께한 추억이 보다 완전히 기록된다. 이를 함께 공유하는 것은 단체 간 유대감을 높이고, 단체의 지속적인 소통과 상호 이해를 촉진할 것이다.<br><br>2. 추억 회상 과정의 효율성 개선<br>단체의 공동 추억 기록을 시간과 공간의 차원에서 아카이빙함으로써, 단체의 발자취를 확인할 수 있다. 시간 순으로 정리된 공동 추억 기록을 한 눈에 볼 수 있고, 공간의 경우 지도를 통해 단체가 함께한 다양한 활동의 위치를 시각적으로 확인할 수 있다. 이를 통해 단체의 구성원들은 함께했던 추억을 보다 쉽게 찾을 수 있다. 또한 함께했던 추억을 생생하게 회상할 수 있게 되어 추억의 특별함을 다시금 깨달을 수 있다. |
| (9) 데모 내용 | [동작환경]<br> - iOS 17.4 환경에서 전체 화면 구성 및 기능을 보인다.<br><br>[데모 실행 플로우]<br>1. Chat-GPT, Stable Diffusion을 활용한 공동 추억 기록 자동 생성 플로우를 보인다.<br>2. 생성된 공동 추억 기록들을 시간, 공간의 관점에서 아카이빙하는 기능을 보인다.|
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-37
| (1) 과제명 | 사용자와 자유로운 상호작용이 가능한 Gen AI 기반 스마트 스케줄링 웹 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 37-re:coding |
| (3) 팀원 역할 분담 | 전혜승(2076364): 팀장, AWS, Spring Boot, MySQL 등 벡엔드<br>최민주(2076409) :팀원, Next.js 프론트엔드<br>황채원(1976435) :팀원, GPT-4 API, FAST API, AWS, Chroma DB 인공지능 백엔드 |
| (4) 팀 지도교수 | 오세은 교수님 |
| (5) 팀 멘토 | 엄재홍 / 현대오토에버 / 부장 |
| (6) 과제 키워드(keywords) | LLM, 비서, 스케줄링 |
| (7) 과제 내용 요약 | 팀 Re:coding은 단순히 일정을 기록하는 역할만 보조했던 기존 스케줄링 서비스의 ‘자동화 부재’를 극복하고자 합니다. 이에 스케줄러의 개인화 기능, 그리고 프로액티브한 일정 관리 기능을 강화한 생성형 인공지능 비서를 만들고자 합니다. '네스'와 함께라면 업무 스케줄링은 물론 개인의 일상까지 한층 더 간편하고 직관적으로 만들 수 있습니다. |
| (8-1) 과제: 문제의 정의 | 정보통신기술의 발달로 개인의 업무량이 크게 증가한 현대 사회에서 다양한 일정을 효율적으로 관리하는 능력은 핵심 역량이 되었다. 이를 보조하기 위한 다양한 일정 관리 앱이 시장에 나왔지만, 대부분이 아날로그 다이어리를 핸드폰에 옮겨놓은 것에 불과했다. 이로 인해 사용자들은 일정을 등록하고 수정할 때마다 번거로운 형식에 맞춰 직접 입력해야 했다. 기존의 앱들은 능동적 스케줄링 보조를 제공하지 않아 사용자가 자신의 일정에 맞는 적절한 사전 준비를 하기 어렵게 만들었다. 더 나아가, 각기 다른 용도의 여러 일정 앱을 사용함으로써 도구의 분산이라는 문제를 겪고 있다. 이 문제를 해결하기 위해 팀 re:coding은 AI 기술을 활용하여 사용자의 의도에 맞는 능동적 스케줄링을 하나의 도구로 제공하는 제품을 개발하려고 한다.<br><br>1. 기존의 스케줄러 어플들을 이용하기 위해서는, 해당 어플의 사용법을 숙지해야했다. 스케줄러 어플에서 통용되는 일정 입력 및 삭제와 같은 기본적인 기능들은 사용자가 별다른 학습 없이도 이용이 가능했지만, 해당 어플에서 편의성 개선을 위해 추가한 고급 기능들을 사용하기 위해서는 어플 이용법 숙지를 위한 사용자의 학습이 요구되었다. 이에 사용자들은 해당 어플의 고급 기능을 이용하기 위한 사용법 숙지를 위해 시간을 투자하거나, 해당 기능을 사용하지 않고 기본적인 기능만을 사용하는데 그쳤다. 이에 자유로운 스케줄링이 불가했기에 사용자들은 보조적인 수단으로 메모장 어플이나, 공책 등의 물리적 기록 수단을 사용하기도 하였다. re:coding 팀에서 약 200명의 대학생을 대상으로 실행한 설문조사 결과, 메모장 어플을 보조적 수단으로 이용하는 사용자들이 76퍼센트, 공책을 보조적 수단으로 사용하는 사람들이 46퍼센트에 달했다.<br><br>2. 기존의 스케줄링 어플들은 아날로그적 수단인 다이어리를 모바일로 그대로 옮겨놓은 것에 불과할 뿐, 사용자의 일정에 필요한 사전 준비, 사후 피드백을 적극적으로 제공해주지 못한다. 일정 수립 시 사전 준비물, 장소 선정, 일기 예보 확인 등 다양한 요소를 고려할 필요할 필요가 있음에도 스케줄링 어플들에선 이러한 관리방식을 제공하지 않는다. 이는 오롯이 사용자의 업무로 돌아가 할 일을 더 가중시킬 뿐이다. 더 나아가 일정 관리에 대한 달성 성공/실패 여부와 같은 일차원적인 피드백 밖에 제공해주지 못해 사용자의 생활 개선에 도움을 제공해주지 못했다. |
| (8-2) 과제: 기존연구와의 비교 | 리코딩 팀은 현존하는 목표 관리 앱들이 어떠한 강점과 취약점을 가지고 있는지 약 한달여 간의 자료조사를 통해 분석하였다.<br><br>1. 투두메이트<br>투두메이트는 심플하면서도 트렌디한 UI, 그리고 직관적인 사용법으로 인해 많은 고객들을 확보했다. 그러나 인터뷰 등을 통해 상당한 수의 사용자들이 짧은 기간 내에 앱 사용을 포기하는 모습을 볼 수 있었는데, 앞서 제시한 설문조사 결과와 연관지어 생각해볼 때, 사용자가 직접 투두 리스트를 작성하고 그룹화할 뿐 아니라 정렬해야 한다는 점이 약점으로 작용했다는 점을 알 수 있었다.<br><br>2. TimeBlocks<br>TimeBlocks는 월별 일정을 간편하게 한 눈에 볼 수 있다는 점, 그리고 다양한 테마를 스토어에서 구입해 쉽게 커스터마이즈가 가능하다는 점에서 많은 사용자들을 모았다. 그러나 화면 구성 상 월별 일정을 한 눈에 보여줘야 한다는 한계는 적재할 수 있는 계획의 수를 제한 시킨다는 문제를 발생시킨다. 때문에 사용자는 중요한 일정을 주로 적게 되고, 전체적인 일정 관리를 위해서는 추가적인 서비스를 이용해야 한다는 문제점이 존재했다.<br><br>리코딩 팀은 위와 같은 자료 조사 및 설문조사를 통해 지금까지의 서비스들과는 다른 ‘네스’만의 강점을 인풋 자율성의 극대화에 두고자 하였다. 즉, 앱에서 지정한 인풋 형식, 카테고리화에서 벗어나 사용자에게 극강의 자율성을 주고 자체 서비스를 통해 플래닝을 진행시키는 개인 비서로서의 역할을 더욱 공고히 하고자 한 것이다.<br><br>‘네스’ 서비스 기획을 발전시키던 과정에서, 리코딩 팀은 인공지능을 활용해 플래닝을 도와주는 Reclaim.ai 라는 서비스를 발견하였다.<br><br>3. Reclaim.ai<br>Reclaim.ai는 구글 캘린더와 연동시켜 활용하는 개인/팀 플래닝 ai 서비스이다. 각 팀원들이 가능한 시간대와 일정 등을 적으면, 자동적으로 충돌이 나는 시간대를 피해 회의 시간을 선정하고 최적화 시켜준다. 다만, 이 IT 서비스 또한 정형화된 사용자의 인풋 입력과 한정적인 스케쥴링 기능이라는 한계점을 갖고 있는 만큼, 본 네스’ 프로젝트는 한층 더 나아가 입력 형식의 자율성이나 ui/ux 측면에서 더욱 발전된 결과물을 도모하고자 한다.<br><br>4. Google Calendar<br>구글 캘린더는 구글에서 제공하는 온라인 일정 관리 서비스로, 구글 계정을 가지고 있다면 개인 뿐 아니라  회사와 같은 공동의 일정을 효율적으로 관리할 수 있다. 특히, 같은 단체 내의 일정 공유 및 알림 설정, slack과 같은 다른 협업 툴과의 연동 가능성은 대규모의 인력을 관리해야 하는 회사에서 상품의 가치를 높여주었다. 하지만, 캘린더를 조작함에 있어 스스로 일정을 생성하고 상대의 일정을 확인 및 초대해야 하기 때문에, 1차원적인 캘린더의 틀에서 벗어나지 못했다는 한계점이 있다. |
| (8-3) 과제: 제안 내용 | NESS는 스케줄러에 챗봇 기능을 도입하여 “상호작용을 통한 편리한 스케줄링 관리”를 이룰 수 있다. NESS는 일정의 설정, 삭제, 변경을 돕고, 적절한 변경안도 제시해주기 때문이다. 반복적인 일정, 혹은 예외적인 일정도 명령어 한 줄로 설정이 가능하며, 사용자는 하나의 입력창으로 네스의 모든 기능을 제어할 수 있다.<br><br>또한, NESS는 사용자의 입력을 기다리기만 하는 게 아니라 스스로 일정을 분석하고 먼저 추천하는 똑똑한 비서이기도 하다. 사용자의 데이터를 기반으로 미리 일정에 대한 알림을 주기도 하고, 사용자가 스케줄러에 기입한 정보가 부족할 때 먼저 리마인드를 주는 능동적인 비서이다. 이를 통해서 기존의 아날로그 다이어리의 디지털화에 불과했던 일정 관리를 개선할 수 있다. |
| (8-4) 과제: 과제의 주요 기능 | [입력 처리]<br>사용자 입력의 차별화: 사용자는 비서에게 이야기하듯이 자신만의 스타일로 자유롭게 일정을 입력할 수 있다. 이렇게 입력받은 텍스트를 LLM이 처리하여 스케쥴 관리를 자동화한다. 이를 통해 일정관리 어플의 편집, 알람설정, 반복설정, 일정조정 등의 번거로움을 개선한다.<br>요약: 사용자가 자유롭게 일정을 입력하면, LLM이 할 일 목록으로 요약한다. 복잡하게 서술한 내용도 명료하게 요약해 정리한다(예: 오늘은 친구랑 여의도에서 밥 먹어야지. -> 친구와 저녁 약속(at: 여의도))<br><br>[스케줄링]<br>반복 일정 관리: 루틴 설정을 챗봇 형식으로 편리하게 해결 가능하다. (예: 헬스장에 가는 일정을 챗봇에 입력하면 자동으로 스케줄에 정리된다.)<br>추천: 사용자에게서 입력받은 일정에 대해 사전에 준비해야 할 사항들을 알려준다. (예: 토요일에 면접 일정이 있다면, 면접에 일반적으로 필요한 준비물들을 미리 알려준다.)<br><br>[분석]<br>분석 레포트 및 솔루션 제공: 사용자의 일정을 분석하여 레포트를 제공한다. 일정을 간략하게 요약하고 이에 태그를 생성해주는 등의 분석을 진행한다.<br><br>우리는 이 서비스를 통해 사용자의 만족도와 생산성을 높이며, 혁신적인 기술을 통해 스케줄링을 넘어 개인 비서로서의 역할을 수행할 것을 기대한다. |
| (8-5) 과제: 구현 방법 | [ML/AI 기술]<br>- LLM의 프롬프트 엔지니어링 : LLM의 가장 중요한 특징은, fine-tuning 없이 few-shot, one-shot, 혹은 zero-shot으로도 우수한 output을 낼 수 있다는 것이다. 사용자의 입력을 요약, 태그에 따른 자동분류 등을 수행하는 것은 LLM의 프롬프트 엔지니어링을 통해 구현할 예정이다. 또한, 사용자에게 분석 레포트 및 솔루션을 제공할 때 문장을 생성하는 것 역시 LLM을 통해 구현한다. 다방면에서 우수한 성능을 보이며, 가격이 합리적인 OpenAI의 GPT-4 API를 사용하였다.<br>- RAG based LLM: NESS의 핵심기술은 RAG based LLM이다. 근 몇 년 사이 언어모델을 평정한 사전학습된 거대언어모델의 한계는, 사전학습에 포함되지 못한 정보는 알지 못한다는 것이었다. RAG, 즉 Retrieval Augmented Generation은, 쿼리와 관련된 문서를 효율적으로 검색하여 쿼리와 함께 언어모델에 전달하는 방식이다. 이 방식을 이용하면, 추가적인 학습 없이 모델 외부의 데이터를 이용할 수 있다. 따라서 개인화된 경험 제공을 위하여 실시간으로 업데이트 되는 사용자 데이터의 활용이 핵심이 되는 NESS 서비스에 매우 중요한 역할을 한다.<br>- LangChain&VectorDB: LangChain은 AI 모델, 에이전트 및 프롬프트를 구조적으로 만들고 연결하여, LLM 관련 작업을 중앙에서 제어할 수 있는 오케스트레이션 프레임워크이다. 또한 모델에 context-enhanced 프롬프트를 전달하기 위해서는 사용자 쿼리에 관련된 문서를 벡터유사도에 기반하여 검색하게 되는데, 이를 위해 데이터를 벡터로 저장할 수 있는 VectorDB를 사용할 예정이다.<br>- LLM의 finetuning : 우리는 챗봇 기능의 구현 중 LLM의 프롬프트 엔지니어링만으로는 채팅 상황의 분류 성능이 떨어진다는 것을 확인하였다. 기존에 구현하고자 하였던 기능이 구현완료되면, 해당 성능의 개선을 위해 finetuning을 고려 중이다. finetuning을 통해 채팅 케이스 분류에 특화된 모델을 구축하여 더욱 사용자 만족도를 높일 수 있는 서비스를 만들어나갈 예정이다. finetuning의 데이터 생성으로는 GPT-3.5, finetuning 모델으로는 무료로 사용가능한 모델인 baby llama를 고려 중이다.<br><br>[FE/BE 기술]<br>- Spring Boot&FastAPI: 웹 서비스의 벡엔드는 Spring Boot를 사용하고, ChatGPT의 API와 연동하기 위해 FastAPI를 사용할 예정이다. 각 프레임워크별 백엔드 서버를 따로 두고 REST API를 통한 통신을 진행한다.<br>- Next.js&TypeScript: Next.js를 통해 CSR(CLient Side Rendering)의 최적화를 위해 노력한다. 웹 서비스이지만 모바일 기기를 소지한 사용자들 역시 편리하게 이용할 수 있도록 반응형 개발을 진행하며, Next.js의 비동기적 특성을 이용하여 간편하면서도 사용자들의 눈을 사로잡을 수 있는 UI/UX를 구현할 에정이다. TypeScript를 이용해 확장 용이성을 높이고, 발전된 형태의 structure 설계를 하고자 한다.|
| (8-6) 과제: 세부 기술 | - Vector DB(chromaDB): 백터DB에 데이터를 저장하고, 코싸인 유사도 기반 쿼리를 통해서 유사도가 높은 사용자의 일정을 검색하는 데 성공하였다.<br>- RAG: 백터DB에서 가져온 사용자의 일정과, 사용자의 채팅 내역을 합쳐서 LLM에게 제공하는 기능을 테스트하였고, LLM이 사용자의 일정 데이터 기반으로 답변을 생성하는 것을 확인하였다.<br>- OAuth 2.0(소셜 로그인): 카카오, 네이버, 구글 계정을 기반으로 로그인 및 회원가입이 가능한 것을 확인하였다.|
| (8-7) 과제: 기대 효과 및 의의 |[거대언어모델과 생성형 AI 기반으로 만드는 인공지능 비서, NESS]<br>팀 re:coding은 생성형 AI 기반 챗봇을 통해 사용자와 자유로운 의사소통이 가능한 스마트 스케줄링 서비스를 개발할 예정이다. 사용자가 마치 채팅을 하듯 일정을 입력하면, 대규모 언어모델(LLM)이 비정형 데이터를 처리하여 맥락을 파악하고, 사용자의 의도에 부합하는 최적의 스케줄을 도출한다. 이 서비스는 개별 누적 데이터를 기반으로 관련 활동 및 장소를 추천하며, 일정 준비를 위한 사전 피드백과 추후 스케줄링 개선을 위한 사후 피드백을 제공하여 사용자의 일정 관리를 능동적으로 지원한다. 일간, 주간, 할 일 목록을 제공함으로써 다양한 일정을 통합 관리할 수 있는 기능 또한 제공한다. 이를 통해 단순히 일정을 저장하는 수준을 넘어 '인공지능 기반 개인 맞춤형 일정 관리 비서'로서의 기능을 제공하는 것이 목표이다.<br><br>[서비스의 확장 가능성]<br>뛰어난 사용자 경험을 제공하기 위해 다양한 외부 서비스와의 통합을 통해 기능을 확장할 수 있는 구조로 서비스를 설계하였다. 이를 통해 사용자들은 단일 플랫폼에서 다양한 활동을 수행하고 자신의 일상을 보다 간편하게 관리할 수 있다. 아래는 통합 가능한 타 서비스와 기능에 대한 설명이다.<br>- 캘린더 서비스 API 통합: 사용자의 일정 및 일정 관리를 강화하기 위해 주요 캘린더 서비스와의 API 통합을 지원한다. 이를 통해 사용자는 하나의 플랫폼을 통해 다양한 캘린더 서비스 (예: Google 캘린더, Apple 캘린더, Outlook 등)의 일정을 연동하고 중앙에서 효율적으로 관리할 수 있다. 사용자들은 NESS 서비스를 통해 여러 캘린더에서 예약 및 일정을 통합적으로 확인하고 조정할 수 있으며, 일정 충돌 및 중복을 방지할 수 있다.<br>- 쇼핑 서비스 API 통합: 사용자들이 쇼핑 활동을 원활하게 관리할 수 있도록 주요 쇼핑 서비스와의 API 통합을 지원한다. 네이터 쇼핑 등의 서비스와 통합하여 쇼핑 목록, 할인 및 프로모션 정보, 주문 추적 등을 모두 관리할 수 있다. 이를 통해 사용자들은 쇼핑 활동과 일정을 통합할 수 있으며, 쇼핑한 물품이 도착하는 일정까지 모두 관리 가능하다.<br>-지도 및 위치 기반 서비스 API 통합: 위치 기반 정보 및 지도 서비스와의 통합을 통해 사용자들은 일정을 관리할 수 있다. 예를 들어, 회의 위치와 가장 가까운 커피숍을 추천받을 수 있다. |
| (9) 데모 내용 | 1. 메인페이지<br>a. 메인페이지는 NESS가 제공하는 전체적인 서비스를 요약하여 보여준다.<br>b. 사용자의 일정 DB를 분석하여 한 줄의 활동 추천 멘트를 생성 및 제공한다.<br>c. 오늘의 일정을 한 눈에 파악할 수 있는 리마인드 section이 있다.<br>d. 지난 한달 간의 일정을 분석한 간단한 보고서 및 통계를 제공한다.<br><br>2. 채팅창<br>a. 사용자가 자유롭게 채팅을 입력하면 생성형 AI를 통해 NESS가 답을 준다.<br>b. 일정 추가와 관련된 채팅을 입력하면(ex. 나 내일 채원언니랑 도서관 가) 일반적인 대화와 다른 case로 판단하여 일정을 정리 및 추가할 수 있는 응답이 온다. (‘4/15’, ‘채원언니', ‘도서관 방문’ 일정 추가)<br>c. 일정 추가 버튼을 누르면 사용자의 일정 DB에 해당 일정이 추가되고, 월별 및 일별 페이지에서 확인할 수 있다.<br><br>3. 월별 페이지<br>a. 생성된 일정들을 캘린더 뷰로 확인할 수 있다.<br>b. 각 날짜를 클릭하면 일별 modal 페이지를 볼 수 있다.<br><br>4. 일별 페이지<br>a. 각 일자에 해당하는 일정을 확인할 수 있다.<br>b. 장소, 인물, 시간 등은 태그 형태로 확인할 수 있다.<br><br>5. 추가 기능<br>a. 플로팅 NESS ICON<br>i. 항상 오른쪽 아래에 존재하는 NESS ICON 플로팅 버튼을 누르면 채팅창으로 바로 이동한다.  |
| (10) 기타 | 스타트 때 기획을 열심히 진행한 만큼, 그로쓰 수업 시간에는 조금 더 기술적으로 배울 수 있는 강연이나 기회가 있었으면 좋겠습니다. 사실, 학생 입장에서 졸업 프로젝트만큼 제대로 오랜 시간을 들여 서비스를 개발하는 기회가 흔치 않은데, 이 기회를 통해 기획 뿐만 아니라 기술에서의 전문성도 키우고 싶습니다. |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-38
| (1) 과제명 | 스킨트리: 협업필터링과 머신러닝을 활용한 성분 맞춤형 화장품 추천 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 38-화이 |
| (3) 팀원 역할 분담 | 정다희(2076367): 리더, 프론트엔드, 백엔드 프로그래밍<br>안민영(2045025): 팀원, 백엔드 프로그래밍, DB<br>임수화(2176313): 팀원, 머신러닝 및 알고리즘 프로그래밍 |
| (4) 팀 지도교수 | 최병주 |
| (5) 팀 멘토 | 김수보 / 한빛미디어 / 소장 |
| (6) 과제 키워드(keywords) | 화장품, 성분, 추천 |
| (7) 과제 내용 요약 | 스킨트리는 수많은 화장품 속에서 나의 피부에 딱 맞는 화장품을 쉽게 찾을 수 있도록 돕는 서비스입니다. 사용자가 사용해보고 잘 맞았다고 생각하는 제품을 입력하면 해당 제품의 성분을 분석해 머신러닝과 협업 필터링을 거쳐 성분 민감도가 유사한 성분 메이트를 찾아 맞춤형 화장품을 찾아드립니다.|
| (8-1) 과제: 문제의 정의 |  1) 제품을 선택할 때 피부 유형과 민감도를 고려하여 화장품을 선택하는 것은 소비자들에게 복잡한 과정으로 여겨진다. 잘못된 제품 선택으로 인해 피부에 부정적인 영향을 미칠수 있기 때문에 각 개인의 성분 민감도와 알레르기 반응을 고려해야 하지만 이를 위해 필요한 정보를 일일이 찾아보는 것은 번거롭다.<br><br> 2) 화장품 시장에는 다양한 브랜드와 제품이 존재하며, 이로 인해 소비자는 적합한 제품을 선택하는 것에 어려움을 겪을 수 있다. 이러한 다양성 때문에 소비자는 제품 선택을 위해 많은 시간과 비용이 소요할 수 있다.<br><br> 3) 기존에 사용하던 제품이 단종되거나 가격이 인상되면 소비자는 다른 제품을 찾게 되는데 이와 유사한 대체 제품을 찾는 것은 소비자에게 어려운 과제일 수 있다.<br><br> 4) 현재 화장품을 추천하는 경우, 가장 많이 쓰이는 방법은 피부 타입 별 추천인데 대부분의 추천은 건성인지 지성인지와 같은 상위 분류만을 따지기 때문에 개인의 피부상태와 정확히 일치하는 화장품 추천이 어렵다. 이에 기존의 피부타입 분류에서 더 나아가 개인에게 더 밀접한 화장품 추천이 필요하다. |
| (8-2) 과제: 기존연구와의 비교 | 1) 화해: 화장품별 전성분구성을 기본으로 제공하고 주의, 알레르기 성분, 목적 별 성분정보, 피부타입 관련 성분 정보를 제공한다. <br> 장점: 식품의약품안전처나 대한피부과의사회 발표자료에 따른 성분에 대한 정보를 제공하여 성분에 대한 일반화된 정보를 알 수 있다.<br> 단점: 화장품 성분 정보 제공이 메인 기능으로 즐겨 찾는 성분을 직접 입력 해야하는 불편함이 있고 성분이 비슷한 ‘같은’ 카테고리의 화장품 1:1 추천만 제공한다.<br><br> 2) 올리브영: 구매 순 랭킹 제공하고 사용자가 조회한 상품과 유사한 제품 혹은 성분이 비슷한 ‘같은’ 카테고리의 화장품을 추천한다. <br> 장점: 카테고리별 구매랭킹을 다양한 기간으로 설정하여 볼 수 있어 대중적으로 인기있는 상품 구매를 할 수 있다. <br> 단점: 단순 구매 순 랭킹은 개인 맞춤형 화장품 추천이라는 목표와 벗어나고 기획 이벤트, 마케팅적 요소에 의한 결과일 수 있다는 한계가 존재한다.<br><br> 3) 잼페이스: 퍼스널 컬러 별 화장품 추천, AI 화면 인식을 통한 피부타입 및 피부고민 측정에 따른 화장품 추천 기능을 제공한다.<br> 장점: AI를 통해 피부상태를 판단하여 중점적으로 케어 해야 할 고민과 그에 따른 추천상품을 알 수 있다. <br>단점: 조명, 카메라 화질에 따라 달라지는 AI 피부측정의 부정확성이 존재하고, AI 를 통해 판단된 피부타입별로 미리 정해진 추천 화장품이 제공되기 때문에 피부타입에서 더 세분화된 추천은 제공하지 않는다. |
| (8-3) 과제: 제안 내용 | 사용자와 성분 민감도가 비슷한 다른 사용자의 경험을 바탕으로 소비자들이 화장품을 고를 때 본인에게 잘 맞지 않을 수도 있는 불확실성을 줄이고 보다 소비자에게 최적화된 제품 선택지를 제시하여 편리한 선택을 할 수 있도록 돕는 서비스를 제안한다. 현재 화장품 선택을 도와주는 유사 경쟁 서비스들은 제품 자체의 성분만을 비교하여 추천을 제공하는 반면 이 서비스는 사용자들에게 기존에 본인이 잘 사용하는 화장품을 입력 받아 이를 기반으로 사용자의 성분 민감도를 계산하여 더욱 정교하고 높은 신뢰성의 맞춤형 추천을 제공한다. 전체적인 과정은 다음과 같다. 사용자로부터 기존에 본인에게 잘 맞았던 화장품을 입력 받아 이로부터 각 제품의 전 성분 분석을 통한 사용자의 성분 리스트를 생성한다. 이를 기반으로 해당 사용자와 성분 유사도가 높은 그룹을 협업 필터링 알고리즘을 통해 추출하여 그 그룹에서 적합하다고 입력한 화장품을 사용자에게 추천한다. |
| (8-4) 과제: 과제의 주요 기능 | 두가지 추천 기능<br><br>1. 사용자 간의 성분 유사도를 계산하여 매칭 사용자를 찾아 매칭 사용자가 입력한 화장품을 추천하는 기능<br>:메모리 기반 협업 필터링 알고리즘을 사용하며 인풋으로는 사용자의 입력 데이터(기존에 잘 사용하던 제품)를 기반으로 해당 제품의 성분을 추출한 개별 사용자의 성분 리스트를 사용합니다.<br><br>2. 화장품 성분과 사용자의 성분 민감도 간의 유사도를 계산하여 제품을 추천하는 기능<br>:K평균 군집화 비지도 학습을 사용하며 모델의 피처로는 제품 데이터의 전성분을 벡터화하여 2 차원으로 축소한 피처 공간을 사용합니다. |
| (8-5) 과제: 구현 방법 |크롤링으로 화장품 데이터를 수집하고 협업 필터링과 비지도학습 군집화 모델을 이용한다.<br> 1. Application의 동작 환경 (서비스 환경): 크롬 웹 브라우저<br> 2. frontend: html, css, flask<br> 3. backend: flask, AWS EC2 Ubuntu 22.04<br> 4. database: mysql<br> 5. 머신러닝: scikitlearn, numpy, pandas, bs4, matplotlib<br> 6. 수집 데이터: https://kcia.or.kr/cid/main/ (대한화장품협회 성분사전), Incidecoder의 Product List, Product & Ingredients|
| (8-6) 과제: 세부 기술 |1) 자연어 처리(Natural Language Processing, NLP): 사용자가 입력한 화장품의 성분 정보를 처리하고 성분 간의 유사도를 계산하는 데에 사용한다. NLP 기술을 사용하여 성분 정보를 토큰화하고 벡터화하여 성분 유사도를 측정하는데, 적용 가능성을 검증하기 위해 전처리된 자연어를 출력하여 올바른 형태인지 분석한 후 벡터화된 성분들을 확인하여 해당 벡터의 값이 올바른 값인지 검증한다.<br><br>2) 유사도 계산 알고리즘: 협업 필터링 알고리즘과 자카도 유사도를 사용하여 구현하고 적용할 수 있다. 사용자의 성분 리스트에 들어간 값들과 유사도 계산 결과를 비교하여 추출된 유사도의 정확도를 검증한다.<br><br> 3) k평균 클러스터링 모델: K평균 군집화를 사용하여 제품들을 군집화하고 사용자의 성분 민감도와 군집 내 제품들 간의 유사도를 계산한다. 이때 전채 군집화의 실루엣 계수를 계산하여 군집화의 수준을 검증하고 각 군집의 실루엣 계수와 비교하여 해당 클러스터링이 사용자에게 맞춤형 제품을 추천할 수 있는 군집인지 확인할 수 있다. |
| (8-7) 과제: 기대 효과 및 의의 |1) 맞춤형 제품 추천을 통해 사용자들의 피부 건강을 증진시킬 수 있도록 한다. 각 사용자의 피부 타입과 민감도를 고려하여 최적의 제품을 추천함으로써 사용자는 피부 문제를 예방하고 개선할 수 있다. <br> 2) 잘못된 화장품 선택으로 인해 버려지는 화장품 낭비를 막는다. 이를 통해 사용자들은 지속 가능한 소비를 이루며 환경에 미치는 부정적인 영향을 최소화할 수 있다.<br> 3) 화장품 선택의 편의성을 증진시킨다. 간편한 추천을 통해 적합한 제품을 찾는 시간과 비용을 절약하고 뷰티 쇼핑이 더 편리해지도록 한다. |
| (9) 데모 내용 | 데모환경 : 크롬 웹브라우저 (모바일 환경이 메인)<br> 1) 이메일 입력 후 추천 버튼 클릭<br> 2) 사용자 데이터 입력(기존에 사용하던 제품)<br> 3) 카테고리 선택<br> 4) 성분 프렌즈 추천 목록 띄우기<br> 5) 다시 추천받기 버튼 클릭 후 기존 제품 추천 화면으로 이동<br> 6) 새로운 사용자 데이터 입력<br> 7) 카테고리 선택<br> 8) 에디터 추천 목록 띄우기  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-39
| (1) 과제명 | 객체 인식과 OCR을 활용한 객관·단답식 시험지 채점 AI 소프트웨어
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 39-순간포착 |
| (3) 팀원 역할 분담 | 이주현(1871041): 리더, 계획 및 데이터 라벨링 및 AI training 및 정확도 평가<br>성아정(1971026): 팀원, UI 설계·구축 및 데이터 라벨링 및 데이터 후처리<br>정나영(2129033): 팀원, 자료조사 및 데이터 라벨링 및 데이터 전처리 |
| (4) 팀 지도교수 | 반효경 교수 |
| (5) 팀 멘토 | 김영우 / 크몽 / SRE/DevOps Engineer |
| (6) 과제 키워드(keywords) | 시험지 채점, 채점 자동화, 객체 인식 |
| (7) 과제 내용 요약 | 저희는 시험지 대량 채점 자동화를 위한 시험 기관용 PC 실행 어플리케이션, <포인트 체커>를 개발하고 있습니다. 객체 인식과 OCR을 사용하여, 별도의 답안지 없이 응시자의 시험지를 스캔 이미지의 형태로 입력 받아 채점 결과를 데이터 파일로 출력하는 프로그램을 개발 중입니다. 배포는 실행 어플리케이션의 형태로 할 예정입니다. 채점에 들어가는 인력과 비용을 감축하여, 편하고 빠른 채점 경험을 시험 기관에 제공하는 것이 <포인트 체커>의 목표입니다. |
| (8-1) 과제: 문제의 정의 | 현재 채점방식의 문제 분석 및 정의<br><br> 1. PBT (Paper Based Test) :  컴퓨터 상에서 시험을 진행하는 방식<br>   a. 수기 채점 방식 : 채점자가 직접 채점<br>    -단점 : 많은 인력과 시간 소요, 부정확성<br>   b. OMR 채점 방식 : OMR 카드에 마킹된 답안을 컴퓨터를 사용해 채점<br>     -단점 : 별도의 답안지 작성 필요, OMR 마킹 실수 발생, 단답 채점 불가능, OMR 카드 구매 필요<br><br> 2. CBT (Computer Based Test) : 종이 서류 상에서 시험을 진행하는 방식<br>    -단점 : 네트워크나 컴퓨터 하드웨어 문제 발생 가능, 부정행위의 가능성, 눈의 피로 야기, 응시자 집중도 하락 야기 |
| (8-2) 과제: 기존연구와의 비교 | 1. 연구<br>   a. 딥러닝 기반 어린이 손글씨 답안 자동 채점 시스템<br>     -선생님이 하나씩 손글씨 답안지를 직접 보고 채점하는 것이 아니라, 어린이 손글씨를 인식하여 텍스트로 변환 후, 정답과 비교해 자동으로 채점.<br>     -강점: 답안 영역을 찾아 이미지로 저장해 이미지를 필기체 인식을 통해 텍스트로 변환하고 이를 정답과 비교하여 자동으로 채점.<br>     -약점: 글씨가 배경과 겹치거나 낙서 또는 일정하지않은 글씨로 인해 정확도가 낮음.<br>   b. EasyOCR을 이용한 정형화된 객관식 답안지의 자동채점 시스템 구현<br>     -정형화된 답안지에 필기체로 답안지를 작성하면, easyOCR을 사용하여 자동 채점하는 시스템.<br>     -강점: 숫자인식 모델의 성능을 개선하여 93%의 인식률을 가짐<br>     -약점: 정형화된 답안지를 따로 작성해야 함.<br><br> 2. 서비스<br>   a. 이코딩 (http://edu-coding.co.kr/)<br>     -omr을 사용하는 것이 아닌 앱의 스마트 omr을 사용하여 자동 채점.<br>     -강점: 학원용, 학생용, 학부모용으로 나뉘어 맞춤 제공 서비스가 존재, 출결, 결제, 채팅 등 다양한 기능이 존재하며, 자동으로 오답만 뽑아 정리해줌.<br>     -약점: 앱을 통해 문제를 풀어야 채점이 자동으로 됨. <br>   b. 에듀허브 (https://eduhub.co.kr/)<br>     -omr 종이 없이, 일반 a4에 omr 양식을 인쇄하여 이를 omr지 대신 사용 가능.<br>     -강점: omr 종이를 따로 구매하지 않아도 스캐너를 통해 채점할 수 있음. 자동으로 오답만 뽑아 정리해줌.<br>     -약점: a4에 omr 인쇄 후 스캐너로 채점하거나 스마트 omr을 사용해야 채점이 자동으로 됨. 스캐너를 사용한 경우, 객관식 문제만 자동 채점이 가능함. omr 양식의 답안지를 무조건 사용해야함.<br><br> 3. 시스템<br>   a. OMR<br>     -별도의 규칙이 있는 답안지를 따로 제작하여 답안지에 빛을 비추어 표시된 위치를 얻는 기술.<br>     -강점: OMR 카드 전용 리더기를 사용할 경우 대량의 답안지를 매우 빠르고 정확한 속도로 채점이 가능함.<br>     -약점: 특정 양식을 준수한 답안지만 사용해야하며, 시험지 외에 별도의 답안지를 따로 구매해야해서 비용이 발생함. OMR카드 전용 리더기가 비싸서 소규모의 업장에서는 하드웨어 구매 시 부담을 느낌. 단답식의 채점은 불가함. |
| (8-3) 과제: 제안 내용 | CBT 방식의 한계점과 PBT 방식의 한계점을 모두 극복하기 위해, 별도의 마킹 답안지 없이 시험 지에 적힌 필기를 인식하여 자동으로 채점해 주는 AI 소프트웨어를 개발할 것입니다. 이를 통해 응시자는 가독성이 좋다는 PBT 방식의 장점과 더불어, OMR 마킹을 위한 시간을 따로 마련하지 않아도 된다는 장점을 누리게 될 것이며, 채점자는 간소화된 채점 과정을 통해 채점에 들어가는 인력 및 시간과 비용을 절감하는 효과를 누릴 수 있을 것입니다. 또한 객관식과 더불어 단답식 채점 구현을 통해, 단순 채점을 넘어선 복잡한 채점 소프트웨어 구현을 하여 보편성과 사용성 확 보를 기대할 수 있습니다. |
| (8-4) 과제: 과제의 주요 기능 | 1. 시험지 양식 적용: 응시자별 시험지 구분을 위해 입력받은 응시 인원과 페이지수에 따른 문자와 ID 쓰는 부분을 나타내는 선 삽입<br><br>2. 각 시험지 구분을 위한 응시자 정보 인식 기능: 대량의 시험지를 입력 받을 예정이므로, 각 시험지 구분을 위해 첫 장에 표시된 응시자 정보를 인식하도록 Yolov8 모델을 학습시켰습니다.<br><br>3. 각 시험지의 문제와 답 영역을 추출: 객체 인식 모델인 Yolov8을 사용하여 문항과 답을 묶어 인식하며, 객관식/주관식/잘린 객관식/잘린 주관식을 나눠서 저장합니다.<br><br>4. 추출한 문제와 답 영역 중 잘린 문제 처리: 잘려나간 문제는 주로 두 부분으로 나뉘므로, 부족한 정보를 인식해 매칭하는 Yolov8 모델을 통해 잘린 문제를 이어붙여 저장합니다.<br><br>5. 각 문항에 표시한 응시자의 필기를 분석: 각 문항에서 객관식 선지를 골랐거나 단답식 서술을 하여 시험지에 기록한 답안을 Yolov8을 사용해 인식해 전산화합니다.<br><br>6. 응시자별 답안 채점: 전산화 된 응시자의 답과 입력된 정답을 비교하여 채점합니다.<br><br>7. 최종 결과를 데이터 파일 형태로 제공<br><br>8. 응시자의 필기 데이터를 시각화하여 이미지로 제공 |
| (8-5) 과제: 구현 방법 | 1. 객체 인식 기술 사용<br>   -딥러닝 기반의 CNN을 사용하여 각 시험지 이미지의 특징을 추출하고 패턴을 학습.<br><br> 2. 데이터 수집 및 라벨링<br>   -표지 인식 모델을 훈련시키기 위한 시험지 로우 데이터를 수집하고 라벨링함. 처음에는 체크만으로 이루어진 시험지로 학습하고, 점차 다양한 유형의 표식과 다양한 시험지 양식을 포함해 모델을 발전시킴.<br><br> 3. 소프트웨어 인터페이스 개발<br>   -사용자가 쉽게 사용할 수 있는 소프트웨어 인터페이스를 개발해 사용자가 시험지를 업로드하면 채점 결과를 확인할 수 있도록 함.<br><br> 4. 성적 결과 제공<br>   -시험지 채점 결과를 계산해 성적 제공.<br><br> 5. 모델 성능 평가 및 지속적인 개선<br>   -사용자 피드백을 수집해 모델의 성능을 지속적으로 향상시킴. 추가적인 훈련 데이터를 확보하고 모델의 가중치 및 하이퍼 파라미터를 조정해 정확도를 높임. |
| (8-6) 과제: 세부 기술 | YOLOv8, easyOCR, OpenCV, labelImg |
| (8-7) 과제: 기대 효과 및 의의 | 1. 비용 절감<br>   -채점에 필요한 인력 낭비를 줄임으로써 인건비 절감<br>   -OMR 용지나 컴퓨터용 싸인펜 구매 비용 절감<br><br> 2. 환경 보호<br>   -OMR 용지를 따로 제작하지 않아도 되어 이에 사용되는 종이 절약<br><br> 3. 응시자의 표기 다양성 존중<br>   -정해진 규격에 맞추어 응답을 하지 않아도 되므로 개인별로 자신에게 익숙한 표기 법을 이용하여 답을 표기 가능<br><br> 4. 다양한 사람들에게 시험 응시 기회 제공<br>   -답안지를 따로 작성할 필요가 없어, OMR 작성이 어려운 응시자들도 쉽게 시험에 응시 가능<br><br> 5. 답안지 작성 교육 및 연습 불필요<br>   -답안지 작성에 대한 별도의 교육 불필요|
| (9) 데모 내용 | Demo1. 시험지 양식 적용<br>  1) 포인트체커 어플리케이션 실행<br>  2) '시험지 양식 적용' 버튼 클릭<br>  3) 응시자 수 입력<br>  4) 시험지 원본 파일을 선택<br>  5) '인쇄용 파일 저장' 버튼 클릭<br>  6) 저장된 파일 확인<br><br> Demo2. 객관식/주관식 문항 채점 후 결과 확인<br>  1) 포인트체커 어플리케이션 실행<br>  2) 시험 정보 입력<br>  3) 채점할 시험지 파일 업로드<br>  4) 정답 입력<br>  5) '채점하기' 버튼 클릭<br>  6) '결과 확인하기' 버튼 클릭<br>  7) 출력된 결과 확인<br>  8) '결과 다운로드' 버튼 클릭<br>  9) 저장된 파일 열어 보여주기 |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-40
| (1) 과제명 | FingerSpell: 초등학생 장애 인식 개선을 위한 모션인식 수화 게임
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 40-흰토끼 |
| (3) 팀원 역할 분담 | 김지수(2117009): 리더, 계획 수립, 문서화, 데이터셋 제작<br>신소현(2071029): 게임 내 주요 시스템 구현, 데이터셋 제작<br>Tan Jiali(2071085): 게임 스테이지 구현 및 제작 |
| (4) 팀 지도교수 | 이미정 |
| (5) 팀 멘토 | 이정욱 / (주)엔테코 인터렉티브 / CEO |
| (6) 과제 키워드(keywords) | 모션인식, 게임, 수화 |
| (7) 과제 내용 요약 | 초등학생 수화 인식 개선을 위한 모션 인식 수화 게임을 개발한다. 수화는 한글의 자음, 모음을 표현하는 지화에 한한다. 플레이 가능한 게임은 2개 scene이 있다. 기본 학습을 위한 퍼즐 요소가 있는 횡스크롤 2D 플랫폼 게임과, 심화 학습을 위한 타임어택 게임으로 구성되어 있다. 계획 상, 기본 학습에서는 ㄱ,ㄴ,ㄷ,ㄹ까지 학습할 수 있을 것이고, 심화 학습에서는 모든 지화를 학습 가능할 것이다. |
| (8-1) 과제: 문제의 정의 | 심화되는 장애인 차별과, 비장애인 학생들이 장애학생을 자신과는 아예 다른 존재라고 이해하고, 장애에 대한 이질성과 거부감을 더욱 느끼게 만드는 형식적인 장애이해교육 |
| (8-2) 과제: 기존연구와의 비교 | popsign :미국 수화 교육용 퍼즐 보블류 게임. 게임을 통해 수화를 배울 수 있으며, 플레이어가 직접 수화를 하는 것이 게임에 반영된다. 하지만 한국 수화는 지원하지 않는다 <br>중국 학교 수화교육과정: 중국의 학교와 교육기관에서 제공하는 수화교육과정으로 중국수화(CSL)나 중국수화의 다양한 형태를 가르치기 위한 것. 이 수업들은 수화 기초, 수화 어휘, 문법 규칙 등을 다룬다. 그러나 교육자 및 학생 간의 상호작용과 효과적인 교육 방법이 중요하며, 이는 교육자의 역량에 의존하기 때문에, 향상시키는데 어려움이 있을 수 있다. |
| (8-3) 과제: 제안 내용 | 초등학생 수화 인식 개선을 위한 모션인식 수화 게임을 개발한다. 수화의 범위는 지화(자음, 모음)에 한한다.|
| (8-4) 과제: 과제의 주요 기능 | 1. 손동작 인식<br>2. 지화의 의미 파악<br>3. 플레이 가능한 게임 scene 2개<br>3-1. 수화 기본 학습 scene : 퍼즐 요소가 있는 횡스크롤 2D 플랫폼 게임<br>3-2. 수화 심화 학습 scene : 떨어지는 자음, 모음을 일정 시간 내에 수화로 맞추는 게임 |
| (8-5) 과제: 구현 방법 | 1. Mediapipe 를 활용한 손동작 인식 <br>2. KNN 알고리즘을 활용한 지화의 의미 파악 <br>3. Unity 게임 엔진을 활용한 플레이 가능한 게임 scene 2 개 <br>3-1. 퍼즐 요소가 있는 횡스크롤 2D 플랫폼 게임 <br>3-2. 떨어지는 자음, 모음을 일정 시간 내에 수화로 맞추는 게임 |
| (8-6) 과제: 세부 기술 | 게임개발 툴 Unity 와 AI 모션인식 기술 Mediapipe 를 함께 사용하여, 게임 내에서 카메라를 통해 플레이어의 손과 각 관절을 인식할 수 있도록 한다. 관절 사이의 각도를 계산하여, KNN 알고리즘을 활용해 플레이어가 어떤 수화를 하고 있는지 해석한다. 수화 기본 학습 scene에서는, 캐릭터 이동, 오브젝트 값과 일치하는 수화를 입력 받을 시 오브젝트 파괴, 조건에 따른 심화 학습 scene 불러오기 등의 기술이 사용된다. 수화 심화 학습 scene에서는, 오브젝트의 실시간 무작위 배치, 캐릭터 hp 관리, 조건에 따른 Game Over, Game Clear 관리 등의 기술이 사용된다. |
| (8-7) 과제: 기대 효과 및 의의 |2024 년 3 월 26 일 기준, 모션인식 기술을 활용한 한국 수화 교육 게임은 존재하지 않는다. 따라서, 새로운 형식의 수화 교육이라는 점에서 의의가 있으며, 이를 통해 장애이해도를 향상시키고, 사회 통합과 안정을 가져올 수 있을 것으로 기대된다.  |
| (9) 데모 내용 | 1. 수화 기본 학습 scene : <br>1) 플레이어 움직임 구현 <br>2) 수화 인식 및 입력 받은 수화와 일치하는 오브젝트 파괴 <br>3)NPC 이동 및 대사창 구현 <br>2.수화 심화 학습 scene: <br>1) 오브젝트의 무작위 배치와 플레이어 캐릭터로의 이동 <br>2) 플레이어 캐릭터가 오브젝트에 닿을 시 hp 감소 <br>3)조건에 따른 엔딩화면 scene으로의 이동  |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-41
| (1) 과제명 | MATHORY: 재미있는 프롬포트 생성 기반 스토리텔링형 초등 수학 교육 게임
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 41-초이배리 |
| (3) 팀원 역할 분담 | 이나영(2071090): 리더, 프론트엔드: 게임 클라이언트(Unity), 백엔드: 게임 서버 (ASP.NET Core), AWS 연결 <br>배소현(2076183): 팀원, 백엔드: chat GPT 파인 튜닝 모델, 게임 서버 (ASP.NET Core), AWS 연결<br>Choi Hannah Vanessa(2171001): 백엔드: chat GPT 파인 튜닝 모델, 게임 서버 (ASP.NET Core), AWS 연결 |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 조광래 / 넷마블 잼팟 / CTO |
| (6) 과제 키워드(keywords) | 초등학교 수학, 게임, 스토리텔링 |
| (7) 과제 내용 요약 | Mathory는 초등학생을 대상으로 한 스토리텔링형 수학 교육 게임으로, 프롬포트 생성 기술인 chatGPT 파인튜닝을 이용하여 다양한 스토리와 해당 스토리와 관련된 수학 문제를 만든다. 학생들은 매번 플레이할 때마다 달라지는 새로운 스토리와 함께 게임을 즐기며 흥미롭게 수학 공부가 가능하다. 따라서 공부하는 동안 계속 흥미가 유지될 수 있으므로, 아이들은 모르는 개념을 배우는 수학 공부의 과정을 즐기며 수학을 배울 수 있다. |
| (8-1) 과제: 문제의 정의 | 많은 초등학교 학생들이 수학을 재미없고 어려운 영역으로 여기기에, 학생들에게 학습 동기와 흥미 유발이 필요하다. |
| (8-2) 과제: 기존연구와의 비교 | 1. Toon Math<br>장점: 수학 연산 및 난이도를 설정할 수 있어 사용자의 수준별로 게임 플레이를 할 수 있다.<br>단점: 수학 학습이 중점인 게임라기보다는 부가적인 요소로 들어간 게임으로, 학습 효과가 부족할 것으로 보인다.<br><br>2.토도수학<br>장점: 직관적인 룰의 사용으로 이해가 쉽다. 처음 게임 실행 시, 사용자의 수학 수준을 선택할 수 있어 사용자의 수준별로 게임 플레이를 할 수 있다.<br>단점: 게임이라기보단 퀴즈에 더 가까워보이는 게임의 룰. 아이들의 흥미를 끌 만한 요소가 적어서 쉽게 지루해질 수 있다.<br><br>3. 수학의 제왕<br>장점: UI와 게임의 규칙이 직관적이다.<br>단점: 게임이라기보단 퀴즈에 더 가까워보이는 게임의 룰. 게임 단계를 설정하지 못하고 순서대로 게임을 진행해야 함.<br><br>세 가지 게임 모두 다른 문제점이 있지만, 종합적으로 보았을 때 교육적인 측면이나 오락적인 측면에 치중하여 다른 하나를 놓친다는 문제점을 볼 수 있었다. 또한, 일부 게임에서는 사용자의 교육 수준을 파악하지 못하고 가장 낮은 수준부터 게임을 진행해야 하였다. <br>'Mathory'에서는 세 가지 게임과 다르게 "스토리텔링" 요소를 강조하여 차별점을 두었다. 또한, 회원가입 시 사용자의 학년을 입력함으로써 사용자들의 수준에 맞게 게임을 플레이 할 수 있도록 한다. 따라서 문제 수준에 따라 단계적이고, 오락 및 교육적인 측면까지 모두 고려한 수학 교육 게임을 개발하고자 한다. |
| (8-3) 과제: 제안 내용 | [게임 진행 방식] <br>1. 사용자는 존재하는 캐릭터 중, 자신의 게임에 등장시키고자 하는 2~3명을 고른다. <br>2. ChatGPT를 활용하여 주인공과 사용자가 고른 캐릭터의 성격과 특성에 맞게 스토리가 진행된다. 큰 틀에서의 배경과 테마/주제는 설정되어 있지만, 주인공과 선택한 캐릭터에 성격에 따라 이야기의 결말은 다양하게 진행된다.<br>3. 스토리를 진행 중간에 수학 퀴즈를 풀어야 하는 구간이 있고 퀴즈는 진행되는 스토리와 연관되어 있다. 모든 퀴즈를 풀었으면 스토리를 완성하고 다음 레벨로 통과할 수 있다. 틀린 문제가 있으면 틀린 문제에 대한 풀이를 보여준다.  |
| (8-4) 과제: 과제의 주요 기능 | 1. 선택된 캐릭터와 게임 줄거리를 제공하는 프롬프트에 따른 게임 시나리오 생성 <br>2. 게임 레벨 및 생성된 스토리에 따른 자연어 퀴즈 생성 <br>3. 사용자의 정보 제공 페이지 |
| (8-5) 과제: 구현 방법 | 1. Unity를 이용하여 게임 프론트 생성 <br>2. ASP.NET CORE를 이용하여 서버 구축 및 게임 프론트(Unity)와 연결 <br>3. MSSQL를 통한 데이터 저장 <br>4. Microsoft Azure의 VM으로 ASP.NET CORE과 MSSQL 운영 <br>5. chatGPT를 활용한 스토리 및 퀴즈 생성 모델 구축 <br>6. Canva의 이미지 생성 기능(Magic Media)을 통한 스토리 배경 및 인물 그림 생성 |
| (8-6) 과제: 세부 기술 | 1. 게임 줄거리를 제공하는 프롬프트에 따라 chatGPT의 파인튜닝을 활용하여 게임 시나리오를 생성한다. <br>1)사용자가 스토리에 등장시키고 싶은 캐릭터를 2-3명을 고른 후, [이야기 프롬프트 만들기]코드를 통해 랜덤으로 스토리의 목표가 선택된다. <br>2)목표에 따라 [스토리 생성 모델]의 프롬프트가 생성된다. [스토리 모델]에서는 프롬프트에 맞게 발단-전개-위기-결말의 양식으로 스토리가 생성된다. <br><br>2. 게임이 진행되는 중간에는 해당 레벨에 맞고, 게임의 스토리와 연관이 있는 수학 문제가 chatGPT의 파인튜닝 모델을 활용하여 생성된다. <br>1)학년에 맞게 수학 식을 [수학 식 만들기] 코드를 통해 생성한다. 단, 수학 식은 식으로 나타낼 수 있는 것만 포함되며 도형, 그래프 등 그림과 관련된 문제는 제공하지 않는다. <br>2)[수학 퀴즈 생성 모델]은 [스토리 생성 모델]에서 생성한 스토리를 발단-전개-위기-결말에 따라 나눈 이야기의 일부와 학년에 맞는 수학 식을 input으로 받아서 이야기에 맞는 해당 수학 식을 사용하는 자연어로 작성된 수학 문제를 생성한다. |
| (8-7) 과제: 기대 효과 및 의의 | 사용자들이 매번 플레이 할 때 마다 달라지는 새로운 스토리와 함께 게임을 즐기며 흥미롭게 수학 공부가 가능하다. 따라서 공부하는 동안 계속 흥미가 유지될 수 있으므로, 아이들은 모르는 개념을 배우는 수학 공부의 과정을 즐기며 수학을 배울 수 있다. |
| (9) 데모 내용 | 1. 아이디를 입력하여 게임에 접속한다. <br>2. 원하는 게임 레벨을 선택한다. <br>3. 이야기에 등장시키고자 하는 캐릭터 2-3명을 선택한다. <br>4. 선택한 캐릭터들이 등장하는 이야기와 해당 이야기와 어울리는 수학 퀴즈가 만들어져 각 이야기 및 퀴즈는 유니티 화면을 통해 보여진다. <br>5. 퀴즈를 맞추고 게임이 끝나면, 퀴즈의 풀이가 제공된다. |
| (10) 기타 |  |
 
[Return TOP](#list-of-teamsprojects)
 
# Team-42
| (1) 과제명 | DRIVE GUARDIAN : 운전자 모니터링 앱 서비스
|:---  |---  |
| (2) 팀 번호 / 팀 이름 | 42-왈라비 |
| (3) 팀원 역할 분담 | 이하진(2176308): 리더, Landmark detection, UI/UX 프로그래밍, DB<br>박지현(2176155): 팀원, Object detection, UI/UX 프로그래밍<br>이지원(2171038): 팀원, Landmark detection |
| (4) 팀 지도교수 | 이형준 교수님 |
| (5) 팀 멘토 | 이태영 / 신한은행 / 연구원 |
| (6) 과제 키워드(keywords) | CV, 운전자 모니터링, 졸음 탐지 |
| (7) 과제 내용 요약 | &emsp;Drive Guardian은 운전자들에게 스스로 이상행동을 모니터링 할 수 있는 앱 서비스를 제공하여 사고발생 위험을 줄이고자 합니다. 운전자의 상태는 평상시, 주의력 부족으로 인한 부주의 상태, 수면부족으로 인한 졸린 상태, 위험 상태로 분류됩니다. 부주의 상태에서는 흡연과 운전자 이탈을 감지하고, 졸린 상태는 하품, 눈 깜박임 횟수와 눈 크기를 종합하여 졸림여부를 판정합니다. 부주의 상태 또는 졸음상태가 감지되면 각 상태에 따라 경고 방식을 달리하여 운전 중 졸음과 부주의를 방지합니다. |
| (8-1) 과제: 문제의 정의 | &emsp;졸음 운전과 주시 태만으로 인한 교통사고는 사망자 비율이 80%에 육박합니다. 또한 교통안전공사의 조사에 따르면 화물차 운전자 10명 중 8명이 최근 1년 사이에 졸음운전을 경험한 것으로 나타납니다. 졸음운전은 운전자는 물론 보행자나 다른 운전자까지 사망에 이르게 할 수 있기 때문에 제대로된 대비책이 마련되어야 하는 심각한 사안입니다. 이러한 문제를 예방하기 위해 운전자 모니터링에 대한 선행 연구들이 많이 있다고는 하지만 거의 대부분의 이러한 서비스들은 특화 장치 구매를 필요로 합니다. DSM처럼 자동차 자체에서 제공하는 서비스는 아직 상용화되지 않았기 때문에 장시간 운전해야하는 화물차, 택배 운전기사와 같이 졸음운전에 취약한 운전자들을 포함한 대부분의 운전자들은 아직까지 졸음 운전 방지 서비스를 제공받지 못하고 있습니다. 따라서 저희는 이렇게 모든 운전자들에게 접근성이 높은 졸음방지 앱 서비스를 제공하여 사고발생 위험을 줄이고자 합니다. |
| (8-2) 과제: 기존연구와의 비교 | &emsp;현대모비스, 기아의 운전자 상태 모니터링 시스템 DSM은 적외선 카메라와 영상 센싱 기술로 운전자의 얼굴과 동공 상태를 감지하여 정상적인 운전 상태가 아니라고 판단될 경우 주의를 주는 시스템입니다. 또한, 차량과 별개로 사용자가 구입할 수 있는 ‘AIKEEP’도 출시되어 있습니다. 기존 제품의 장점은 최적화된 소프트웨어에 의한 빠른 프로세싱 속도입니다. 다만, 대부분 아직 상용화되지 않았으며, AI딥러닝 기술과 하드웨어 시스템의 조합으로 구성되어 있기에 상용화 과정에서 하드웨어의 비용 문제가 발생할 수 있다는 단점이 있습니다.<br><br>&emsp;이에 본 팀은 사용자의 부담을 덜고 접근성을 높이기 위해 운전 중 스마트폰을 통해 졸음을 모니터링하고 알림을 받을 수 있는 앱 서비스를 개발하고자 합니다. 또한, 기존 제품들의 기능에 더하여 졸음뿐만 아니라 운전중 부주의 행동 또한 모니터링할 수 있도록 기획했습니다. |
| (8-3) 과제: 제안 내용 | &emsp;저희는 딥러닝 모델을 이용한 운전자 모니터링 앱 서비스 ‘Drive Guardian’을 개발하고 있습니다. 이미지를 인식하고 분류하는 Object Detection과 얼굴을 인식할 수 있는 Landmark Detection, 사람의 몸을 인식할 수 있는 Pose Estimation 모델을 이용하여 운전 중 졸음과 부주의 행동을 탐지합니다. 일정 기준 이상의 졸음과 부주의 행동이 탐지되면 Alert를 실행하여 운전자가 위험 상황에서 벗어나게 합니다.이를 효과적으로 구현하기 위하여, 운전자의 상태는 크게 평상시 상태, 부주의 상태, 졸음 상태로 구분됩니다.<br>&emsp;부주의 상태를 탐지할 때에는 흡연, 운전자 자리 이탈(전방 미주시, 몸을 조수석을 돌리는 행위 등) 두 가지 요소에 대한 Object Detection을 각각 실행하고, 두 모델의 탐지 결과의 빈도나 양상이 일정 기준 이상에 해당하면 Alert로 주의를 환기하는 경고 음성을 출력하여 빠르게 부주의 상태에서 벗어날 수 있도록 합니다.<br>&emsp;졸음은 또다시 졸린 상태와 완전히 수면 상태에 접어든 위험 상태로 구분됩니다. 졸린 상태를 탐지할 때에는 하품에 대한 Object Detection, 눈 깜빡임 빈도와 눈 크기에 대한 Landmark Detection을 실행하여, 두 모델의 탐지 결과를 종합하여 부주의 상태와 마찬가지로 일정 기준 이상일 시 졸린 상태로 판정합니다. 이때 Alert로 졸음 쉼터를 안내하는 등의 경고 음성을 출력합니다.<br>&emsp;위험 상태는 Pose Estimation으로 얼굴의 숙인 각도를 탐지하여 위험상태로 판정합니다. 이 경우 Alert 음성을 다른 단계들에 비해 강한 강도로 출력합니다.사용자는 앱을 이용하여 운전 모니터링 서비스를 편리하게 사용할 수 있고, 이 앱을 통하여 졸음 및 부주의 운전 방지에 좋은 효과를 가져올 수 있을 것입니다. |
| (8-4) 과제: 과제의 주요 기능 | &emsp;Drive Guardian은 운전자의 부주의와 졸린 상태를 중점적으로 탐지합니다. 부주의는 흡연과 자리 이탈 탐지로 detect합니다. 흡연과 자리 이탈이 감지되면 그 즉시 경고 메시지 음성 안내를 하여 운전자의 주의력을 회복시킵니다. 졸린 상태는 눈 크기와 눈 깜박임과 하품으로 detect합니다. 이 세 가지의 항목을 multi-label classification으로 구현합니다. 졸린 상태로 판단되면 흥미로운 음성 안내나 주위의 휴게소를 안내하는 음성을 반복적으로 재생하도록 하여 운전자가 자신의 상태를 인지하고 극복할 수 있도록 도와줍니다. 위험 상태로 인식되면 계속해서 경고를 울려 운전자가 일단 졸음 상태에서 빠져나올 수 있도록 도와줍니다. |
| (8-5) 과제: 구현 방법 | &emsp;개발 툴로는 Android Studio를 바탕으로 CameraX 라이브러리와 안드로이드 sdk를 사용합니다. Android Studio에서 앱의 전반적인 작동과 프론트엔드를 구현합니다. 데이터베이스와 인증은 Firebase를 사용합니다. Android Studio에 AI 모델을 임베딩하기 위하여 OpenCV, OpenPose, Tensorflow 라이브러리를 불러와 사용합니다.<br>&emsp;부주의 단계의 detection은 object detection, pose estimation을 사용하고 졸린 상태의 detection은 object detection, landmark detection을 사용하며, 위험 단계는 pose estimation과 졸린 상태 탐지결과를 사용합니다. 이 과정에서 EAR 알고리즘과 EMA Smoothing 알고리즘을 사용합니다. 이 모든 detection을 하나로 묶어 부주의, 졸린 상태, 위험 상태 중 하나로 real time으로 탐지하는 multilabel classification을 최종적으로 구현합니다. 사용자가 얼굴을 운전 중에 카메라에 비추는 동안 모델이 구동되어 특정 상태가  detect 되면 각 단계에 맞는 알림 시스템을 취합니다. |
| (8-6) 과제: 세부 기술 | &emsp;부주의는 흡연과 자리 이탈 탐지로 detect합니다. 흡연은 Roboflow의 smoking dataset과 YOLOv5를 이용하여 하품을 탐지하도록 training했습니다. 그리고 자리 이탈은 Pose Estimation을 통해 탐지합니다. ML kit에서 제공하는 Pose Estimation 모델을 불러와 각각의 Landmark들을 표시하는 점을 이어 자세의 각도를 탐지하여 자리 이탈을 detect 합니다. 흡연과 자리 이탈이 감지되면 그 즉시 경고 메시지 음성 안내를 하여 운전자의 주의력을 회복시킵니다.<br>&emsp;졸린 상태는 눈 크기와 눈 깜박임과 하품으로 탐지합니다. 눈 크기와 눈 깜박임은 ML kit에서 제공하는 Landmark Detection 모델을 사용합니다. 운전자의 눈이 감기는 정도를 판단하기 위해 해당 모델을 사용합니다. 눈 크기 비율 계산은 EAR(eye aspect ratio) 공식을 따릅니다. 이를 이용해 실시간으로 탐지되는 눈 크기 비율과 그래프의 경향을 통해 졸린 상태를 판정하도록 합니다. Landmark detection 모델에 의해 얼굴에 Landmark point들이 그려지면 그 point들을 이용하여 눈의 경계에 사각형을 그리는 좌표값 함수와 눈 크기의 임계값을 의미하는 적절한 k를 이용하여 눈 깜박임을 탐지합니다. 깜박임은 이 사각형의 넓이가 k 일 때 count되는 방식으로 구현할 예정입니다. 마지막으로 하품 탐지는 Roboflow의 Drowsiness Dataset과 YOLOv5를 이용하여 하품을 탐지하도록 training했습니다. Real time으로 탐지해야 하는 만큼 가볍고 빠른 YOLO를 선택했고 버전 중 가장 가벼운 nano model을 선택했습니다. 이 세가지의 항목을 통합하여 졸린 상태 classification으로 구현합니다. 눈을 깜박이는 횟수가 증가하고 눈의 크기가 평소의 0.6 이하로 떨어지고 하품이 감지된다면 졸린 상태에 가까운 상태가 되었다고 판단합니다. 졸린 상태로 판단되면 흥미로운 음성 안내나 주위의 휴게소를 안내하는 음성을 반복적으로 재생하도록 하여 운전자가 자신의 상태를 인지하고 극복할 수 있도록 도와줍니다.<br>&emsp;졸린 상태가 일정 시간 내 3회 이상 detect 되어 위험 상태로 인식되면 계속해서 경고를 울려 운전자가 일단 졸음 상태에서 빠져나올 수 있도록 도와줍니다. 추가로 오탐을 방지하게 위해서 비정상적으로 깜박임이 잦은 경우에는 눈 깜박임이 m회 이상 과도하게 반복되면 무시하도록 설정합니다. 눈을 작게 뜨는 경우는 눈 깜박임 탐지 사각형의 k값이 일반적인 상황을 포괄할 수 있도록 설정합니다. |
| (8-7) 과제: 기대 효과 및 의의 | &emsp;Drive Guardian을 통하여 사용자는 운전 중에 졸거나, 운전에 집중하지 않는 상황을 방지하고, 미연의 사고의 가능성 또한 줄일 수 있을 것입니다. 고가의 장치를 구매하지 않아도 간단하게 앱을 설치하는 것만으로 모니터링이 가능하므로 쉽게 앱에 접근하여 안전하게 운전할 수 있게 됩니다. 또한 계속해서 모니터링되고 있다는 사실 자체로 운전자에게 경각심을 심어줄 수 있을 것입니다. |
| (9) 데모 내용 | 최종 데모<br><br>제목: Drive Guardian 의 부주의, 졸린 상태, 위험 상태 단계의 detection 및 alert 시연<br>데모 내용:<br>• 운전자로 가정된 시연자 1명의 얼굴 및 상체 일부가 휴대폰 카메라에 잡히도록 세팅한다.<br>• 사용자가 Drive Guardian에 회원가입 / 로그인한다.<br>• 사용자가 카메라 아이콘을 눌러 카메라 화면에 진입힌다.<br>• detect 버튼을 누르면 부주의(흡연, 전방 주시)/졸린(눈 크기, 눈 깜박임, 하품)/위험 상태에 대해 real-time 탐지가 시작된다.<br>• 사용자가 연이어 조수석 쪽으로 몸을 돌리면 부주의 상태에서 벗어나도록 하는 안내 메시지가 음성으로 출력된다.<br>• 사용자가 연이어 하품을 하면 졸린 상태에서 벗어나도록 하는 경고 메시지가 음성으로 출력된다.<br>• 사용자가 눈을 자주 깜빡이거나, 눈을 감은 상태가 지속되면 졸린 상태에서 벗어나도록 하는 경고 메시지가 음성으로 출력된다.<br>• 사용자가 고개를 숙이고 수면을 취하는 상태가 지속되면 위험 상태로 판단하여 긴급 알림을 출력한다. |
| (10) 기타 | 없음 |

 
[Return TOP](#list-of-teamsprojects)
 
